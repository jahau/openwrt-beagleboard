From 961e2425435e07fce00969d861fbb7d7ce7b3062 Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <x00omar@ti.com>
Date: Fri, 29 Aug 2008 21:20:39 -0500
Subject: [PATCH] BRIDGE: Checkpatch Cleanup

Deleted unused function typedefs and structures associated with them

Signed-off-by: Fernando Guzman Lugo <x0095840@ti.com>
Signed-off-by: Omar Ramirez Luna <x00omar@ti.com>
Signed-off-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
---
 arch/arm/plat-omap/include/bridge/_chnl_sm.h   |    2 -
 arch/arm/plat-omap/include/bridge/cod.h        |   63 +----
 arch/arm/plat-omap/include/bridge/dbldefs.h    |  366 +-----------------------
 arch/arm/plat-omap/include/bridge/dblldefs.h   |    4 -
 arch/arm/plat-omap/include/bridge/dev.h        |   21 +--
 arch/arm/plat-omap/include/bridge/dldr.h       |   75 -----
 arch/arm/plat-omap/include/bridge/dldrdefs.h   |  315 --------------------
 arch/arm/plat-omap/include/bridge/getsection.h |    5 +-
 arch/arm/plat-omap/include/bridge/isr.h        |   65 -----
 arch/arm/plat-omap/include/bridge/prcs.h       |   17 +-
 arch/arm/plat-omap/include/bridge/rmstypes.h   |    1 -
 drivers/dsp/bridge/hw/GlobalTypes.h            |    7 +-
 drivers/dsp/bridge/wmd/_msg_sm.h               |    8 +-
 13 files changed, 11 insertions(+), 938 deletions(-)
 delete mode 100644 arch/arm/plat-omap/include/bridge/dldr.h
 delete mode 100644 arch/arm/plat-omap/include/bridge/dldrdefs.h

--- a/arch/arm/plat-omap/include/bridge/_chnl_sm.h
+++ b/arch/arm/plat-omap/include/bridge/_chnl_sm.h
@@ -110,8 +110,6 @@ struct loadMonStruct {
 
 #endif
 
-	typedef u32 SMWORD;
-
 	enum SHM_DESCTYPE {
 		SHM_CURROPP = 0,
 		SHM_OPPINFO = 1,
--- a/arch/arm/plat-omap/include/bridge/cod.h
+++ b/arch/arm/plat-omap/include/bridge/cod.h
@@ -105,27 +105,6 @@
 					     void *pBuf, u32 ulNumBytes,
 					     u32 nMemSpace);
 
-	typedef bool(CDECL *COD_ALLOCFXN) (void *pPrivRef, u32 space,
-					    u32 ulNumBytes, u32 ulAlign,
-					    u32 *ulDspAddr, bool fReserved);
-
-	typedef bool(CDECL *COD_FREEFXN) (void *pPrivReg, u32 ulDspAddr,
-					   u32 space, u32 ulNumBytes,
-					   bool fReserved);
-
-/*
- *  ======== COD_LOADATTRS ========
- *
- *  Attributes that specify alloc, free, and write functions when loading
- *  or unloading a section.
- */
-	 struct COD_LOADATTRS {
-		void *pWHandle;	/* Handle to pass to write fxn */
-		void *pAHandle;	/* Handle to pass to alloc/free fxns */
-		COD_WRITEFXN pfnWrite;
-		COD_ALLOCFXN pfnAlloc;
-		COD_FREEFXN pfnFree;
-	} ;
 
 /*
  *  ======== COD_Close ========
@@ -377,27 +356,6 @@
 					     COD_WRITEFXN pfnWrite, void *pArb,
 					     char *envp[]);
 
-/*
- *  ======== COD_LoadSection ========
- *  Purpose:
- *      Load a named section in the COFF file. (For overlay support).
- *  Parameters:
- *      hManager:       COD manager.
- *      pstrSect:       Name of the section, with or without leading "."
- *      pAttrs:         Specifies alloc, free, and write function.
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EFWRITE:    Failed to write section to target.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pstrSect != NULL;
- *  Ensures:
- *
- */
-	extern DSP_STATUS CDECL COD_LoadSection(struct COD_MANAGER *hManager,
-					      IN char *pstrSect,
-					      IN struct COD_LOADATTRS *pAttrs);
 
 /*
  *  ======== COD_Open ========
@@ -470,25 +428,6 @@ extern DSP_STATUS COD_OpenBase(struct CO
 						OUT char *pstrContent,
 						IN u32 cContentSize);
 
-/*
- *  ======== COD_UnloadSection ========
- *  Purpose:
- *      Unload a named section in the COFF file. (For overlay support).
- *  Parameters:
- *      hManager:   COD manager.
- *      pstrSect:   name of the section, with or without leading "."
- *      pAttrs:     Specifies free function.
- *  Returns:
- *      DSP_SOK:    Success.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pstrSect != NULL;
- *  Ensures:
- *
- */
-	extern DSP_STATUS CDECL COD_UnloadSection(struct COD_MANAGER *hManager,
-					      IN char *pstrSect,
-					      IN struct COD_LOADATTRS *pAttrs);
+
 
 #endif				/* COD_ */
--- a/arch/arm/plat-omap/include/bridge/dbldefs.h
+++ b/arch/arm/plat-omap/include/bridge/dbldefs.h
@@ -39,10 +39,7 @@
 
 #define DBL_MAXPATHLENGTH       255
 
-#ifndef _SIZE_T			/* Linux sets _SIZE_T on defining size_t */
-typedef unsigned int size_t;
-#define _SIZE_T
-#endif
+
 
 /*
  *  ======== DBL_Flags ========
@@ -80,31 +77,7 @@ struct DBL_Symbol {
 typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
 			u32 *dspAddr, s32 segId, s32 req, bool reserved);
 
-/*
- *  ======== DBL_CinitFxn ========
- *  Process .cinit records.
- *  Parameters:
- *      hdl             - Opaque handle
- *      dspAddress      - DSP address of .cinit section
- *      buf             - Buffer containing .cinit section
- *      nBytes          - Size of .cinit section (host bytes)
- *      mtype           - Page? (does not need to be used)
- *
- *  Returns:
- *      nBytes          - Success
- *      < nBytes        - Failure
- *
- *  Note: Cinit processing can either be done by the DSP, in which case
- *  the .cinit section must have already been written, or on the host,
- *  in which case we need to use the data in buf.
- */
-typedef s32(*DBL_CinitFxn) (void *hdl, u32 dspAddr, void *buf,
-			    u32 nBytes, s32 mtype);
 
-/*
- *  ======== DBL_CloseFxn ========
- */
-typedef s32(*DBL_FCloseFxn) (void *);
 
 /*
  *  ======== DBL_FreeFxn ========
@@ -115,11 +88,6 @@ typedef bool(*DBL_FreeFxn) (void *hdl, u
 			    bool reserved);
 
 /*
- *  ======== DBL_FOpenFxn ========
- */
-typedef void *(*DBL_FOpenFxn) (const char *, const char *);
-
-/*
  *  ======== DBL_LogWriteFxn ========
  *  Function to call when writing data from a section, to log the info.
  *  Can be NULL if no logging is required.
@@ -127,15 +95,6 @@ typedef void *(*DBL_FOpenFxn) (const cha
 typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
 				      u32 addr, u32 nBytes);
 
-/*
- *  ======== DBL_ReadFxn ========
- */
-typedef s32(*DBL_ReadFxn) (void *, size_t, size_t, void *);
-
-/*
- *  ======== DBL_SeekFxn ========
- */
-typedef s32(*DBL_SeekFxn) (void *, long, int);
 
 /*
  *  ======== DBL_SymLookup ========
@@ -154,10 +113,6 @@ typedef s32(*DBL_SeekFxn) (void *, long,
 typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
 			      const char *name, struct DBL_Symbol **sym);
 
-/*
- *  ======== DBL_TellFxn ========
- */
-typedef s32(*DBL_TellFxn) (void *);
 
 /*
  *  ======== DBL_WriteFxn ========
@@ -197,323 +152,4 @@ struct DBL_Attrs {
 	void *(*fopen) (const char *, const char *);
 } ;
 
-/*
- *  ======== DBL_close ========
- *  Close library opened with DBL_open.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-typedef void(*DBL_CloseFxn) (struct DBL_LibraryObj *library);
-
-/*
- *  ======== DBL_create ========
- *  Create a target object, specifying the alloc, free, and write functions.
- *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
- *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
- */
-typedef DSP_STATUS(*DBL_CreateFxn) (struct DBL_TargetObj **pTarget,
-				    struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_delete ========
- *  Delete target object and free resources for any loaded libraries.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *  Ensures:
- */
-typedef void(*DBL_DeleteFxn) (struct DBL_TargetObj *target);
-
-/*
- *  ======== DBL_exit ========
- *  Discontinue use of DBL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      cRefs > 0.
- *  Ensures:
- *      cRefs >= 0.
- */
-typedef void(*DBL_ExitFxn) (void);
-
-/*
- *  ======== DBL_getAddr ========
- *  Get address of name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid library.
- *      name != NULL.
- *      ppSym != NULL.
- *  Ensures:
- */
-typedef bool(*DBL_GetAddrFxn) (struct DBL_LibraryObj *lib, char *name,
-			       struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getAttrs ========
- *  Retrieve the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *      pAttrs          - Location to store attributes on output.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-typedef void(*DBL_GetAttrsFxn) (struct DBL_TargetObj *target,
-				struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_getCAddr ========
- *  Get address of "C" name on the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      name != NULL.
- *      ppSym != NULL.
- *  Ensures:
- */
-typedef bool(*DBL_GetCAddrFxn) (struct DBL_LibraryObj *lib, char *name,
-				struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getSect ========
- *  Get address and size of a named section.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBL_GetSectFxn) (struct DBL_LibraryObj *lib, char *name,
-				     u32 *addr, u32 *size);
-
-/*
- *  ======== DBL_init ========
- *  Initialize DBL module.
- *  Parameters:
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      cRefs >= 0.
- *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
- */
-typedef bool(*DBL_InitFxn) (void);
-
-/*
- *  ======== DBL_load ========
- *  Load library onto the target.
- *
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      flags           - Load code, data and/or symbols.
- *      attrs           - May contain alloc, free, and write function.
- *      pulEntry        - Location to store program entry on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFREAD:     File read failed.
- *      DSP_EFWRITE:    Write to target failed.
- *      DSP_EDYNLOAD:   Failure in dynamic loader library.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBL_LoadFxn) (struct DBL_LibraryObj *lib, DBL_Flags flags,
-				  struct DBL_Attrs *attrs, u32 *entry);
-
-/*
- *  ======== DBL_loadSect ========
- *  Load a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains write function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *      DSP_EFWRITE:    Write function failed.
- *      DSP_ENOTIMPL:   Function not implemented.
- *  Requires:
- *      Valid lib.
- *      sectName != NULL.
- *      attrs != NULL.
- *      attrs->write != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBL_LoadSectFxn) (struct DBL_LibraryObj *lib,
-				      char *pszSectName,
-				      struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_open ========
- *  DBL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBL_load()/DBL_unload().
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      file            - Name of file to open.
- *      flags           - If flags & DBL_SYMB, load symbols.
- *      pLib            - Location to store library handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
- *      DSP_EFOPEN:         File open failure.
- *      DSP_EFREAD:         File read failure.
- *      DSP_ECORRUPTFILE:   Unable to determine target type.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      file != NULL.
- *      pLib != NULL.
- *      DBL_Attrs fopen function non-NULL.
- *  Ensures:
- *      Success:        Valid *pLib.
- *      Failure:        *pLib == NULL.
- */
-typedef DSP_STATUS(*DBL_OpenFxn) (struct DBL_TargetObj *target, char *file,
-				  DBL_Flags flags,
-				  struct DBL_LibraryObj **pLib);
-
-/*
- *  ======== DBL_readSect ========
- *  Read COFF section into a character buffer.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
- *      size            - Buffer size
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section does not exists.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pBuf != NULL.
- *      size != 0.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBL_ReadSectFxn) (struct DBL_LibraryObj *lib, char *name,
-				      char *content, u32 uContentSize);
-
-/*
- *  ======== DBL_setAttrs ========
- *  Set the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      pAttrs          - New attributes.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-typedef void(*DBL_SetAttrsFxn) (struct DBL_TargetObj *target,
-				struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_unload ========
- *  Unload library loaded with DBL_load().
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-typedef void(*DBL_UnloadFxn) (struct DBL_LibraryObj *library,
-			      struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_unloadSect ========
- *  Unload a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section not found.
- *      DSP_ENOTIMPL
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      sectName != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBL_UnloadSectFxn) (struct DBL_LibraryObj *lib,
-					char *pszSectName,
-					struct DBL_Attrs *attrs);
-
-struct DBL_Fxns {
-	DBL_CloseFxn closeFxn;
-	DBL_CreateFxn createFxn;
-	DBL_DeleteFxn deleteFxn;
-	DBL_ExitFxn exitFxn;
-	DBL_GetAttrsFxn getAttrsFxn;
-	DBL_GetAddrFxn getAddrFxn;
-	DBL_GetCAddrFxn getCAddrFxn;
-	DBL_GetSectFxn getSectFxn;
-	DBL_InitFxn initFxn;
-	DBL_LoadFxn loadFxn;
-	DBL_LoadSectFxn loadSectFxn;
-	DBL_OpenFxn openFxn;
-	DBL_ReadSectFxn readSectFxn;
-	DBL_SetAttrsFxn setAttrsFxn;
-	DBL_UnloadFxn unloadFxn;
-	DBL_UnloadSectFxn unloadSectFxn;
-};
-
 #endif				/* DBLDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/dblldefs.h
+++ b/arch/arm/plat-omap/include/bridge/dblldefs.h
@@ -40,10 +40,6 @@
 
 #define DBLL_MAXPATHLENGTH       255
 
-#ifndef _SIZE_T
-typedef unsigned int size_t;
-#define _SIZE_T
-#endif
 
 /*
  *  ======== DBLL_Target ========
--- a/arch/arm/plat-omap/include/bridge/dev.h
+++ b/arch/arm/plat-omap/include/bridge/dev.h
@@ -93,8 +93,6 @@
 /*  ----------------------------------- This */
 #include <devdefs.h>
 
-/* Notification callback for DEV clients BRD and CHNL */
-	typedef void(CDECL *DEV_CALLBACK) (void *pArb, u32 ulStatus);
 
 /*
  *  ======== DEV_BrdWriteFxn ========
@@ -717,24 +715,7 @@
 	extern DSP_STATUS CDECL DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
 						  u32 ulStatus);
 
-/*
- *  ======== DEV_RegisterNotify ========
- *  Purpose:
- *      Register a callback function and callback argument for DEV to call
- *      when a change in device status occurs.
- *  Parameters:
- *      hDevObject:  Handle to device object created with DEV_CreateDevice().
- *  Returns:
- *      DSP_SOK:       Success.
- *      DSP_EHANDLE:   Invalid Dev Object handle.
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- */
-	extern DSP_STATUS CDECL DEV_RegisterNotify(struct DEV_OBJECT
-						   *hDevObject,
-						   void *pArb,
-						   DEV_CALLBACK lpCallback);
+
 
 /*
  *  ======== DEV_RemoveDevice ========
--- a/arch/arm/plat-omap/include/bridge/dldr.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * bridge/inc/dldr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dldr.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge dynamic loader interface. See the file dldrdefs.h
- *  for a description of these functions.
- *
- *  Public Functions:
- *      DLDR_Allocate
- *      DLDR_Create
- *      DLDR_Delete
- *      DLDR_Exit
- *      DLDR_Free
- *      DLDR_GetFxnAddr
- *      DLDR_Init
- *      DLDR_Load
- *      DLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function header comments.
- *! 17-Apr-2002 jeh     Created.
- */
-
-#include <dbdefs.h>
-#include <dbdcddef.h>
-#include <dldrdefs.h>
-
-#ifndef DLDR_
-#define DLDR_
-
-	extern DSP_STATUS DLDR_Allocate(struct DLDR_OBJECT *hDldr,
-					void *pPrivRef,
-					IN CONST struct DCD_NODEPROPS
-					*pNodeProps,
-					OUT struct DLDR_NODEOBJECT
-					**phDldrNode);
-
-	extern DSP_STATUS DLDR_Create(OUT struct DLDR_OBJECT **phDldr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct DLDR_ATTRS *pAttrs);
-
-	extern void DLDR_Delete(struct DLDR_OBJECT *hDldr);
-	extern void DLDR_Exit();
-	extern void DLDR_Free(struct DLDR_NODEOBJECT *hDldrNode);
-
-	extern DSP_STATUS DLDR_GetFxnAddr(struct DLDR_NODEOBJECT *hDldrNode,
-					  char *pstrFxn, u32 *pulAddr);
-
-	extern bool DLDR_Init();
-	extern DSP_STATUS DLDR_Load(struct DLDR_NODEOBJECT *hDldrNode,
-				    enum DLDR_PHASE phase);
-	extern DSP_STATUS DLDR_Unload(struct DLDR_NODEOBJECT *hDldrNode,
-				    enum DLDR_PHASE phase);
-
-#endif				/* DLDR_ */
--- a/arch/arm/plat-omap/include/bridge/dldrdefs.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * bridge/inc/dldrdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dldrdefs.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge loader interface. This is the interface shared by
- *  all loaders (eg, static loader and dynamic loader). This interface will
- *  be used by NODE.
- *
- *! Revision History
- *! ================
- *! 16-Sep-2002 map Updated with code review changes
- *! 24-Apr-2002 jeh     Added DLDR_WRITEFXN.
- *! 05-Nov-2001 jeh     Changed some function error return codes.
- *! 17-Sep-2001 jeh     Added function typedefs.
- *! 22-Aug-2001 jeh     Created.
- */
-
-#ifndef DLDRDEFS_
-#define DLDRDEFS_
-
-#include <dbdcddef.h>
-#include <dev.h>
-
-#define DLDR_MAXPATHLENGTH       255
-
-/* DLDR Objects: */
-	struct DLDR_OBJECT;
-	struct DLDR_NODEOBJECT;
-
-/*
- *  ======== DLDR_LOADTYPE ========
- *  Load types for a node. Must match values in node.h55.
- */
-	enum DLDR_LOADTYPE {
-		DLDR_STATICLOAD,	/* Linked in base image, not overlay */
-		DLDR_DYNAMICLOAD,	/* Dynamically loaded node */
-		DLDR_OVLYLOAD	/* Linked in base image, overlay node */
-	} ;
-
-/*
- *  ======== DLDR_OVLYFXN ========
- *  Causes code or data to be copied from load address to run address. This
- *  is the "COD_WRITEFXN" that gets passed to the DBL_Library and is used as
- *  the ZL write function.
- *
- *  Parameters:
- *      pPrivRef:       Handle to identify the node.
- *      ulDspRunAddr:   Run address of code or data.
- *      ulDspLoadAddr:  Load address of code or data.
- *      ulNumBytes:     Number of (GPP) bytes to copy.
- *      nMemSpace:      RMS_CODE or RMS_DATA.
- *  Returns:
- *      ulNumBytes:     Success.
- *      0:              Failure.
- *  Requires:
- *  Ensures:
- */
-	typedef u32(CDECL *DLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
-					     u32 ulDspLoadAddr,
-					     u32 ulNumBytes, u32 nMemSpace);
-
-/*
- *  ======== DLDR_WRITEFXN ========
- *  Write memory function. Used for dynamic load writes.
- *  Parameters:
- *      pPrivRef:       Handle to identify the node.
- *      ulDspAddr:      Address of code or data.
- *      pBuf:           Code or data to be written
- *      ulNumBytes:     Number of (GPP) bytes to write.
- *      nMemSpace:      DBL_DATA or DBL_CODE.
- *  Returns:
- *      ulNumBytes:     Success.
- *      0:              Failure.
- *  Requires:
- *  Ensures:
- */
-	typedef u32(CDECL *DLDR_WRITEFXN) (void *pPrivRef,
-					      u32 ulDspAddr,
-					      void *pBuf,
-					      u32 ulNumBytes, u32 nMemSpace);
-
-/*
- *  ======== DLDR_ATTRS ========
- *  Attributes passed to DLDR_Create function.
- */
-	struct DLDR_ATTRS {
-		DLDR_OVLYFXN pfnOvly;
-		DLDR_WRITEFXN pfnWrite;
-		u16 usDSPWordSize;
-		u16 usDSPMauSize;
-	} ;
-
-/*
- *  ======== DLDR_PHASE ========
- *  Indicates node create, delete, or execute phase function.
- */
-	enum DLDR_PHASE {
-		DLDR_CREATE,
-		DLDR_DELETE,
-		DLDR_EXECUTE,
-		DLDR_NOPHASE
-	} ;
-
-/*
- *  Typedefs of loader functions imported from a DLL, or defined in a
- *  function table.
- */
-
-/*
- *  ======== DLDR_Allocate ========
- *  Allocate resources to manage the loading of a node on the DSP.
- *
- *  Parameters:
- *      hDldr:          Handle of loader that will load the node.
- *      pPrivRef:       Handle to identify the node.
- *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
- *      phDldrNode:     Location to store node handle on output. This handle
- *                      will be passed to DLDR_Load/DLDR_Unload.
- *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldr.
- *      pNodeProps != NULL.
- *      phDldrNode != NULL.
- *  Ensures:
- *      DSP_SOK:        IsValidNode(*phDldrNode).
- *      error:          *phDldrNode == NULL.
- */
-	typedef DSP_STATUS(*DLDR_ALLOCATEFXN) (struct DLDR_OBJECT *hDldr,
-					       void *pPrivRef,
-					       IN CONST struct DCD_NODEPROPS *
-					       pNodeProps,
-					       OUT struct DLDR_NODEOBJECT
-					       **phDldrNode,
-					       OUT bool *pfPhaseSplit);
-
-/*
- *  ======== DLDR_Create ========
- *  Create a loader object. This object handles the loading and unloading of
- *  create, delete, and execute phase functions of nodes on the DSP target.
- *
- *  Parameters:
- *      phDldr:         Location to store loader handle on output.
- *      hDevObject:     Device for this processor.
- *      pAttrs:         Loader attributes.
- *  Returns:
- *      DSP_SOK:                Success;
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *  Requires:
- *      DLDR_Init() called.
- *      phDldr != NULL.
- *      hDevObject != NULL.
- *  pAttrs != NULL.
- *  Ensures:
- *      DSP_SOK:        Valid *phDldr.
- *      error:          *phDldr == NULL.
- */
-	typedef DSP_STATUS(*DLDR_CREATEFXN) (OUT struct DLDR_OBJECT **phDldr,
-					     struct DEV_OBJECT *hDevObject,
-					     IN CONST struct DLDR_ATTRS
-					     *pAttrs);
-
-/*
- *  ======== DLDR_Delete ========
- *  Delete the DLDR loader.
- *
- *  Parameters:
- *      hDldr:          Node manager object.
- *  Returns:
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldr.
- *  Ensures:
- *  hDldr invalid
- */
-	typedef void(*DLDR_DELETEFXN) (struct DLDR_OBJECT *hDldr);
-
-/*
- *  ======== DLDR_Exit ========
- *  Discontinue usage of DLDR module.
- *
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DLDR_Init() successfully called before.
- *  Ensures:
- *      Any resources acquired in DLDR_Init() will be freed when last DLDR
- *      client calls DLDR_Exit().
- */
-	typedef void(*DLDR_EXITFXN) ();
-
-/*
- *  ======== DLDR_Free ========
- *  Free resources allocated in DLDR_Allocate.
- *
- *  Parameters:
- *      hDldrNode:      Handle returned from DLDR_Allocate().
- *  Returns:
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldrNode.
- *  Ensures:
- */
-	typedef void(*DLDR_FREEFXN) (struct DLDR_NODEOBJECT *hDldrNode);
-
-/*
- *  ======== DLDR_GetFxnAddr ========
- *  Get address of create, delete, or execute phase function of a node on
- *  the DSP.
- *
- *  Parameters:
- *      hDldrNode:      Handle returned from DLDR_Allocate().
- *      pstrFxn:        Name of function.
- *      pulAddr:        Location to store function address.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ESYMBOL:    Address of function not found.
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldrNode.
- *      pulAddr != NULL;
- *      pstrFxn != NULL;
- *  Ensures:
- */
-	typedef DSP_STATUS(*DLDR_GETFXNADDRFXN) (struct DLDR_NODEOBJECT
-						 *hDldrNode,
-						 char *pstrFxn, u32 *pulAddr);
-
-/*
- *  ======== DLDR_Init ========
- *  Initialize the DLDR module.
- *
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	typedef bool(*DLDR_INITFXN) ();
-
-/*
- *  ======== DLDR_Load ========
- *  Load create, delete, or execute phase function of a node on the DSP.
- *
- *  Parameters:
- *      hDldrNode:      Handle returned from DLDR_Allocate().
- *      phase:          Type of function to load (create, delete, or execute).
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EMEMORY:            Insufficient memory on GPP.
- *      DSP_EOVERLAYMEMORY:     Can't overlay phase because overlay memory
- *                              is already in use.
- *      DSP_EDYNLOAD:           Failure in dynamic loader library.
- *      DSP_EFWRITE:            Failed to write phase's code or date to target.
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldrNode.
- *  Ensures:
- */
-	typedef DSP_STATUS(*DLDR_LOADFXN) (struct DLDR_NODEOBJECT *hDldrNode,
-					   enum DLDR_PHASE phase);
-
-/*
- *  ======== DLDR_Unload ========
- *  Unload create, delete, or execute phase function of a node on the DSP.
- *
- *  Parameters:
- *      hDldrNode:      Handle returned from DLDR_Allocate().
- *      phase:          Node function to unload (create, delete, or execute).
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *  Requires:
- *      DLDR_Init() called.
- *      Valid hDldrNode.
- *  Ensures:
- */
-	typedef DSP_STATUS(*DLDR_UNLOADFXN) (struct DLDR_NODEOBJECT *hDldrNode,
-					     enum DLDR_PHASE phase);
-
-/*
- *  ======== DLDR_FXNS ========
- */
-	struct DLDR_FXNS {
-		DLDR_ALLOCATEFXN pfnAllocate;
-		DLDR_CREATEFXN pfnCreate;
-		DLDR_DELETEFXN pfnDelete;
-		DLDR_EXITFXN pfnExit;
-		DLDR_FREEFXN pfnFree;
-		DLDR_GETFXNADDRFXN pfnGetFxnAddr;
-		DLDR_INITFXN pfnInit;
-		DLDR_LOADFXN pfnLoad;
-		DLDR_UNLOADFXN pfnUnload;
-	} ;
-
-#endif				/* DLDRDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/getsection.h
+++ b/arch/arm/plat-omap/include/bridge/getsection.h
@@ -18,10 +18,7 @@
 #ifndef _GETSECTION_H_
 #define _GETSECTION_H_
 
-#ifndef _SIZE_T			/* Linux sets _SIZE_T on defining size_t */
-typedef unsigned int size_t;
-#define _SIZE_T
-#endif
+
 #include "dynamic_loader.h"
 
 /*
--- a/arch/arm/plat-omap/include/bridge/isr.h
+++ b/arch/arm/plat-omap/include/bridge/isr.h
@@ -21,13 +21,9 @@
  *      Interrupt services.
  *
  *  Public Functions:
- *      ISR_Disable
  *      ISR_Exit
- *      ISR_GetStatus
  *      ISR_Init
  *      ISR_Install
- *      ISR_Restore
- *      ISR_SimulateInt
  *      ISR_Uninstall
  *
  *  Notes:
@@ -80,19 +76,6 @@
 	typedef bool (CDECL *ISR_PROC) (void *pRefData);
 
 /*
- *  ======== ISR_Disable ========
- *  Purpose:
- *      Turns off interrupts to begin a critical section of code.
- *      Not implemented in CE
- *  Parameters:
- *      pFlags: Location to store flags.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-	extern void CDECL ISR_Disable(OUT u32 *pFlags);
-
-/*
  *  ======== ISR_Exit ========
  *  Purpose:
  *      Discontinue usage of the ISR module.
@@ -106,25 +89,6 @@
 	extern void CDECL ISR_Exit();
 
 /*
- *  ======== ISR_GetStatus ========
- *  Purpose:
- *      Return platform specific status flags containing information about
- *      a virtualized IRQ.  Used by clients for debugging only.
- *      Not implemented.
- *  Parameters:
- *      hIRQ:       Interrupt object handle as returned by ISR_Install().
- *      pdwFlags:   Location to store status flags on output.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_ENOTIMPL:   Not implemented
- *  Requires:
- *      pdwFlags != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS CDECL ISR_GetStatus(IN struct ISR_IRQ *hIRQ,
-					      OUT u32 *pdwFlags);
-
-/*
  *  ======== ISR_Init ========
  *  Purpose:
  *      Initialize the ISR module's private state.
@@ -170,36 +134,7 @@
 					    IN u32 dwIntrType,
 					    IN void *pRefData);
 
-/*
- *  ======== ISR_Restore ========
- *  Purpose:
- *      In CE, the client should use ISR_Install to restore the interrupt.
- *  Parameters:
- *      saveFlags: To save or not to save.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-	extern void CDECL ISR_Restore(IN u32 saveFlags);
 
-/*
- *  ======== ISR_SimulateInt ========
- *  Purpose:
- *      Simulate a hardware interrupt.
- *  Parameters:
- *      hIRQ:       Interrupt object handle as returned by ISR_Install().
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_ENOTIMPL:   Not yet implemented.
- *      DSP_EHANDLE:    Invalid hIRQ.
- *  Requires:
- *      DSP_SOK:    An interrupt handler must have been previously installed
- *                  with ISR_Install().
- *  Ensures:
- *      DSP_SOK:    The ISR installed by ISR_Install() will be called, before
- *                  or after this function returns.
- */
-	extern DSP_STATUS CDECL ISR_SimulateInt(IN struct ISR_IRQ *hIRQ);
 
 /*
  *  ======== ISR_Uninstall ========
--- a/arch/arm/plat-omap/include/bridge/prcs.h
+++ b/arch/arm/plat-omap/include/bridge/prcs.h
@@ -23,7 +23,6 @@
  *  Public Functions:
  *      PRCS_Exit
  *      PRCS_GetCurrentHandle
- *      PRCS_GetCurThreadHandle
  *      PRCS_Init
  *
  *! Revision History:
@@ -69,21 +68,7 @@
  */
 	extern DSP_STATUS PRCS_GetCurrentHandle(OUT HANDLE *phProcess);
 
-/*
- *  ======== PRCS_GetCurThreadHandle ========
- *  Purpose:
- *      Retrieve the current thread handle
- *  Parameters:
- *      phThread:       Location to store the current thread handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EPOINTER:   Invalid argument.
- *  Requires:
- *      PRCS initialized.
- *  Ensures:
- *      If returned DSP_SOK, phThread is a valid pseudo thread handle.
- */
-	extern DSP_STATUS PRCS_GetCurThreadHandle(OUT HANDLE *phThread);
+
 
 /*
  *  ======== PRCS_Init ========
--- a/arch/arm/plat-omap/include/bridge/rmstypes.h
+++ b/arch/arm/plat-omap/include/bridge/rmstypes.h
@@ -36,6 +36,5 @@
 #include <std.h>
 typedef u32 RMS_WORD;
 typedef char RMS_CHAR;
-typedef u32 RMS_STATUS;
 
 #endif				/* RMSTYPES_ */
--- a/drivers/dsp/bridge/hw/GlobalTypes.h
+++ b/drivers/dsp/bridge/hw/GlobalTypes.h
@@ -208,8 +208,7 @@
 #define READ_UPPER_8BITS_OF_16(value16bits)\
     (((u8)((u32)(value16bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
 
-/* 8 bit tpyes */
-typedef signed   char  WORD8;
+
 
 /* UWORD16:  16 bit tpyes */
 
@@ -232,9 +231,7 @@ typedef volatile unsigned long  REG_UWOR
  * Type to be used for floating point calculation. Note that floating point
  * calculation is very CPU expensive, and you should only  use if you
  * absolutely need this. */
-#ifndef OMAPBRIDGE_TYPES
-typedef float  FLOAT;
-#endif
+
 
 /* boolean_t:  Boolean Type True, False */
 /* ReturnCode_t:  Return codes to be returned by all library functions */
--- a/drivers/dsp/bridge/wmd/_msg_sm.h
+++ b/drivers/dsp/bridge/wmd/_msg_sm.h
@@ -81,10 +81,10 @@
  *  size -          Number of messages to be read by the GPP.
  */
 struct MSG {
-	SMWORD bufEmpty;	/* to/from DSP buffer is empty */
-	SMWORD postSWI;	/* Set to "1" to post MSG SWI */
-	SMWORD size;	/* Number of messages to/from the DSP */
-	SMWORD resvd;
+	u32 bufEmpty;	/* to/from DSP buffer is empty */
+	u32 postSWI;	/* Set to "1" to post MSG SWI */
+	u32 size;	/* Number of messages to/from the DSP */
+	u32 resvd;
 } ;
 
 /*
