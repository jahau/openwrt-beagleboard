--- a/arch/arm/plat-omap/include/bridge/brddefs.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/brddefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== brddefs.h ========
- *  Description:
- *      Global BRD constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr: Comment Exec changed to Monitor
- *! 22-Jul-1999 jeh Added BRD_LOADED state.
- *! 26-Mar-1997 gp: Added BRD_SYNCINIT state.
- *! 11-Dec-1996 cr: Added BRD_LASTSTATE definition.
- *! 11-Jul-1996 gp: Added missing u32 callback argument to BRD_CALLBACK.
- *! 10-Jun-1996 gp: Created from board.h and brd.h.
- */
-
-#ifndef BRDDEFS_
-#define BRDDEFS_
-
-/* platform status values */
-#define BRD_STOPPED     0x0	/* No Monitor Loaded, Not running. */
-#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended.  */
-#define BRD_RUNNING     0x2	/* Monitor loaded, and executing.  */
-#define BRD_UNKNOWN     0x3	/* Board state is indeterminate. */
-#define BRD_SYNCINIT    0x4
-#define BRD_LOADED      0x5
-#define BRD_LASTSTATE   BRD_LOADED	/* Set to highest legal board state. */
-#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress  */
-#define BRD_HIBERNATION 0x7		/* MPU initiated hibernation */
-#define BRD_RETENTION     0x8       /* Retention mode */
-#define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
-#define BRD_ERROR		0xA       /* Board state is Error */
-	typedef u32 BRD_STATUS;
-
-/* BRD Object */
-	struct BRD_OBJECT;
-
-#endif				/* BRDDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/cfgdefs.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/cfgdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== cfgdefs.h ========
- *  Purpose:
- *      Global CFG constants and types, shared between class and mini driver.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* in CFG_HOSTRES.
- *! 06-Sep-2000 jeh Added channel info to CFG_HOSTRES.
- *! 09-May-2000 rr: CFG_HOSTRES now support multiple windows for PCI support.
- *! 31-Jan-2000 rr: Comments changed after code review.
- *! 06-Jan-2000 rr: Bus Type included in CFG_HOSTRES.
- *! 12-Nov-1999 rr: CFG_HOSTRES member names changed.
- *! 25-Oct-1999 rr: Modified the CFG_HOSTRES Structure
- *!                 PCMCIA ISR Register/Unregister fxn removed..
- *!                 New flag PCCARD introduced during compile time.
- *! 10-Sep-1999 ww: Added PCMCIA ISR Register/Unregister fxn.
- *! 01-Sep-1999 ag: Removed NT/95 specific fields in CFG_HOSTRES
- *! 27-Oct-1997 cr: Updated CFG_HOSTRES struct to support 1+ IRQs per board.
- *! 17-Sep-1997 gp: Tacked some NT config info to end of CFG_HOSTRES structure.
- *! 12-Dec-1996 cr: Cleaned up after code review.
- *! 14-Nov-1996 gp: Renamed from wsxcfg.h
- *! 19-Jun-1996 cr: Created.
- */
-
-#ifndef CFGDEFS_
-#define CFGDEFS_
-
-/* Maximum length of module search path. */
-#define CFG_MAXSEARCHPATHLEN    255
-
-/* Maximum length of general paths. */
-#define CFG_MAXPATH             255
-
-/* Host Resources:  */
-#define CFG_MAXMEMREGISTERS     9
-#define CFG_MAXIOPORTS          20
-#define CFG_MAXIRQS             7
-#define CFG_MAXDMACHANNELS      7
-
-/* IRQ flag */
-#define CFG_IRQSHARED           0x01	/* IRQ can be shared */
-
-/* DSP Resources: */
-#define CFG_DSPMAXMEMTYPES      10
-#define CFG_DEFAULT_NUM_WINDOWS 1	/* We support only one window. */
-
-/* A platform-related device handle: */
-	struct CFG_DEVNODE;
-
-/*
- *  Host resource structure.
- */
-	struct CFG_HOSTRES {
-		u32 wNumMemWindows;	/* Set to default */
-		/* This is the base.memory */
-		u32 dwMemBase[CFG_MAXMEMREGISTERS];  /* SHM virtual address */
-		u32 dwMemLength[CFG_MAXMEMREGISTERS]; /* Length of the Base */
-		u32 dwMemPhys[CFG_MAXMEMREGISTERS]; /* SHM Physical address */
-		u8 bIRQRegisters;	/* IRQ Number */
-		u8 bIRQAttrib;	/* IRQ Attribute */
-		u32 dwOffsetForMonitor;	/* The Shared memory starts from
-					 * dwMemBase + this offset */
-		u32 dwBusType;	/* Bus type for this device */
-		u32 dwProgBase;	/* DSP ProgBase */
-		u32 dwProgLength;	/* DSP ProgBase Length */
-		u32 dwRegBase;	/* DSP memory mapped register base */
-		u32 dwRegLength;	/* DSP Register Base Length */
-		u32 ClientHandle;	/* Client Handle */
-		u32 SocketHandle;	/* Socket and Function Pair */
-		u32 CardInfo;	/* This will be used as a context data in
-				 * in the CardRequestIRQ */
-	/*
-	 *  Info needed by NODE for allocating channels to communicate with RMS:
-	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
-	 *                          reserved.
-	 *      dwChnlBufSize:      Size of channel buffer to send to RMS
-	 *      dwNumChnls:       Total number of channels (including reserved).
-	 */
-		u32 dwChnlOffset;
-		u32 dwChnlBufSize;
-		u32 dwNumChnls;
-
-#ifdef CONFIG_ARCH_OMAP3430
-		u32 dwPrmBase;
-		u32 dwCmBase;
-		u32 dwPerBase;
-		u32 dwWdTimerDspBase;
-		u32 dwMboxBase;
-		u32 dwDmmuBase;
-		u32 dwDipiBase;
-		u32 dwSysCtrlBase;
-#endif
-	} ;
-
-	struct CFG_DSPMEMDESC {
-		u32 uMemType;	/* Type of memory.                        */
-		u32 ulMin;	/* Minimum amount of memory of this type. */
-		u32 ulMax;	/* Maximum amount of memory of this type. */
-	} ;
-
-	struct CFG_DSPRES {
-		u32 uChipType;	/* DSP chip type.               */
-		u32 uWordSize;	/* Number of bytes in a word    */
-		u32 cChips;	/* Number of chips.             */
-		u32 cMemTypes;	/* Types of memory.             */
-		struct CFG_DSPMEMDESC aMemDesc[CFG_DSPMAXMEMTYPES];
-		/* DSP Memory types */
-	} ;
-
-#endif				/* CFGDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/cfg.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/cfg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== cfg.h ========
- *  Purpose:
- *      PM Configuration module.
- *
- *  Private Functions:
- *      CFG_Exit
- *      CFG_GetAutoStart
- *      CFG_GetCDVersion
- *      CFG_GetDevObject
- *      CFG_GetDSPResources
- *      CFG_GetExecFile
- *      CFG_GetHostResources
- *      CFG_GetObject
- *      CFG_GetPerfValue
- *      CFG_GetWMDFileName
- *      CFG_GetZLFile
- *      CFG_Init
- *      CFG_SetDevObject
- *      CFG_SetObject
- *
- *! Revision History:
- *! =================
- *! 26-Feb-2003 kc  Removed unused CFG fxns.
- *! 28-Aug-2001 jeh  Added CFG_GetLoaderName.
- *! 26-Jul-2000 rr:  Added CFG_GetDCDName to retrieve the DCD Dll name.
- *! 13-Jul-2000 rr:  Added CFG_GetObject & CFG_SetObject.
- *! 13-Jan-2000 rr:  CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *!                  CFG_GetWinBRIDGEDir/Directory,CFG_GetSearchPath removed.
- *! 15-Jan-1998 cr:  Code review cleanup.
- *! 16-Aug-1997 cr:  Added explicit cdecl identifiers.
- *! 12-Dec-1996 gp:  Moved CFG_FindInSearchPath to CSP module.
- *! 13-Sep-1996 gp:  Added CFG_GetBoardName().
- *! 22-Jul-1996 gp:  Added CFG_GetTraceStr, to retrieve an initial GT trace.
- *! 26-Jun-1996 cr:  Added CFG_FindInSearchPath.
- *! 25-Jun-1996 cr:  Added CFG_GetWinSPOXDir.
- *! 17-Jun-1996 cr:  Added CFG_GetDevNode.
- *! 11-Jun-1996 cr:  Cleaned up for code review.
- *! 07-Jun-1996 cr:  Added CFG_GetExecFile and CFG_GetZLFileName functions.
- *! 04-Jun-1996 gp:  Added AutoStart regkey and accessor function.  Placed
- *!                  OUT parameters in accessor function param. lists at end.
- *! 29-May-1996 gp:  Moved DEV_HDEVNODE to here and renamed CFG_HDEVNODE.
- *! 22-May-1996 cr:  Added GetHostResources, GetDSPResources, and
- *!                  GetWMDFileName services.
- *! 18-May-1996 gp:  Created.
- */
-
-#ifndef CFG_
-#define CFG_
-#include <host_os.h>
-#include <cfgdefs.h>
-
-/*
- *  ======== CFG_Exit ========
- *  Purpose:
- *      Discontinue usage of the CFG module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CFG_Init() was previously called.
- *  Ensures:
- *      Resources acquired in CFG_Init() are freed.
- */
-	extern void CFG_Exit();
-
-/*
- *  ======== CFG_GetAutoStart ========
- *  Purpose:
- *      Retreive the autostart mask, if any, for this board.
- *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      pdwAutoStart:   Ptr to location for 32 bit autostart mask.
- *  Returns:
- *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_RESOURCENOTAVAIL: Unable to retreive resource.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:        *pdwAutoStart contains autostart mask for this devnode.
- */
-	extern DSP_STATUS CFG_GetAutoStart(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwAutoStart);
-
-/*
- *  ======== CFG_GetCDVersion ========
- *  Purpose:
- *      Retrieves the version of the PM Class Driver.
- *  Parameters:
- *      pdwVersion: Ptr to u32 to contain version number upon return.
- *  Returns:
- *      DSP_SOK:    Success.  pdwVersion contains Class Driver version in
- *                  the form: 0xAABBCCDD where AABB is Major version and
- *                  CCDD is Minor.
- *      DSP_EFAIL:  Failure.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    Success.
- *      else:       *pdwVersion is NULL.
- */
-	extern DSP_STATUS CFG_GetCDVersion(OUT u32 *pdwVersion);
-
-/*
- *  ======== CFG_GetDevObject ========
- *  Purpose:
- *      Retrieve the Device Object handle for a given devnode.
- *  Parameters:
- *      hDevNode:       Platform's DevNode handle from which to retrieve value.
- *      pdwValue:       Ptr to location to store the value.
- *  Returns:
- *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_INVALIDPOINTER:   phDevObject is invalid.
- *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    *pdwValue is set to the retrieved u32.
- *      else:       *pdwValue is set to 0L.
- */
-	extern DSP_STATUS CFG_GetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwValue);
-
-/*
- *  ======== CFG_GetDSPResources ========
- *  Purpose:
- *      Get the DSP resources available to a given device.
- *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
- *      pDSPResTable:   Ptr to a location to store the DSP resource table.
- *  Returns:
- *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_RESOURCENOTAVAIL: The DSP Resource information is not
- *                              available
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    pDSPResTable points to a filled table of resources allocated
- *                  for the specified WMD.
- */
-	extern DSP_STATUS CFG_GetDSPResources(IN struct CFG_DEVNODE *hDevNode,
-				      OUT struct CFG_DSPRES *pDSPResTable);
-
-
-/*
- *  ======== CFG_GetExecFile ========
- *  Purpose:
- *      Retreive the default executable, if any, for this board.
- *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
- *      pstrExecFile:   Ptr to character buf to hold ExecFile.
- *  Returns:
- *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_INVALIDPOINTER:   pstrExecFile is invalid.
- *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into pstrExecFile,
- *                  and *pstrExecFile contains default executable for this
- *                  devnode.
- */
-	extern DSP_STATUS CFG_GetExecFile(IN struct CFG_DEVNODE *hDevNode,
-					  IN u32 cBufSize,
-					  OUT char *pstrExecFile);
-
-/*
- *  ======== CFG_GetHostResources ========
- *  Purpose:
- *      Get the Host PC allocated resources assigned to a given device.
- *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
- *      pHostResTable:  Ptr to a location to store the host resource table.
- *  Returns:
- *      DSP_SOK:                On success.
- *      CFG_E_INVALIDPOINTER:   pHostResTable is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    pHostResTable points to a filled table of resources
- *                  allocated for the specified WMD.
- *
- */
-	extern DSP_STATUS CFG_GetHostResources(IN struct CFG_DEVNODE *hDevNode,
-				       OUT struct CFG_HOSTRES *pHostResTable);
-
-/*
- *  ======== CFG_GetObject ========
- *  Purpose:
- *      Retrieve the Driver Object handle From the Registry
- *  Parameters:
- *      pdwValue:   Ptr to location to store the value.
- *      dwType      Type of Object to Get
- *  Returns:
- *      DSP_SOK:    Success.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    *pdwValue is set to the retrieved u32(non-Zero).
- *      else:       *pdwValue is set to 0L.
- */
-	extern DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType);
-
-/*
- *  ======== CFG_GetPerfValue ========
- *  Purpose:
- *      Retrieve a flag indicating whether PERF should log statistics for the
- *      PM class driver.
- *  Parameters:
- *      pfEnablePerf:   Location to store flag.  0 indicates the key was
- *                      not found, or had a zero value.  A nonzero value
- *                      means the key was found and had a nonzero value.
- *  Returns:
- *  Requires:
- *      pfEnablePerf != NULL;
- *  Ensures:
- */
-	extern void CFG_GetPerfValue(OUT bool *pfEnablePerf);
-
-/*
- *  ======== CFG_GetWMDFileName ========
- *  Purpose:
- *    Get the mini-driver file name for a given device.
- *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
- *      pWMDFileName:   Ptr to a character buffer to hold the WMD filename.
- *  Returns:
- *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_RESOURCENOTAVAIL: The filename is not available.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:        Not more than cBufSize bytes were copied
- *                      into pWMDFileName.
- *
- */
-	extern DSP_STATUS CFG_GetWMDFileName(IN struct CFG_DEVNODE *hDevNode,
-					     IN u32 cBufSize,
-					     OUT char *pWMDFileName);
-
-/*
- *  ======== CFG_GetZLFile ========
- *  Purpose:
- *      Retreive the ZLFile, if any, for this board.
- *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
- *      pstrZLFileName: Ptr to character buf to hold ZLFileName.
- *  Returns:
- *      DSP_SOK:                Success.
- *      CFG_E_INVALIDPOINTER:   pstrZLFileName is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      CFG_E_RESOURCENOTAVAIL: couldn't find the ZLFileName.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into
- *                  pstrZLFileName, and *pstrZLFileName contains ZLFileName
- *                  for this devnode.
- */
-	extern DSP_STATUS CFG_GetZLFile(IN struct CFG_DEVNODE *hDevNode,
-					IN u32 cBufSize,
-					OUT char *pstrZLFileName);
-
-/*
- *  ======== CFG_Init ========
- *  Purpose:
- *      Initialize the CFG module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CFG functions.
- */
-	extern bool CFG_Init();
-
-/*
- *  ======== CFG_SetDevObject ========
- *  Purpose:
- *      Store the Device Object handle for a given devnode.
- *  Parameters:
- *      hDevNode:   Platform's DevNode handle we are storing value with.
- *      dwValue:    Arbitrary value to store.
- *  Returns:
- *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
- *      DSP_EFAIL:              Internal Error.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:    The Private u32 was successfully set.
- */
-	extern DSP_STATUS CFG_SetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   IN u32 dwValue);
-
-/*
- *  ======== CFG_SetDrvObject ========
- *  Purpose:
- *      Store the Driver Object handle.
- *  Parameters:
- *      dwValue:        Arbitrary value to store.
- *      dwType          Type of Object to Store
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Internal Error.
- *  Requires:
- *      CFG initialized.
- *  Ensures:
- *      DSP_SOK:        The Private u32 was successfully set.
- */
-	extern DSP_STATUS CFG_SetObject(IN u32 dwValue, IN u32 dwType);
-
-#endif				/* CFG_ */
--- a/arch/arm/plat-omap/include/bridge/chnldefs.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/chnldefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== chnldefs.h ========
- *  Purpose:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 19-Jan-2002 ag  Added cBufSize to IOC.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 02-Dec-1999 ag: Added new chnl attribute pstrEventName.
- *! 12-Nov-1999 kc: Enabled hEvent attribute for tests.
- *! 01-Nov-1999 ag: hEvent attribute not supported(yet).
- *! 16-Jan-1997 gp: Moved private stuff into chnlpriv.h
- *! 14-Jan-1997 gp: Updated based on code review feedback:
- *!                 Removed CHNL_MODENOWAIT, CHNL_MODEDIRECT,
- *! 03-Jan-1997 gp: Added channel class library types.
- *! 14-Dec-1996 gp: Moved uChnlId field from CHNL_ATTRS to CHNL_Open().
- *! 10-Dec-1996 gp: Added CHNL_IsTimedOut() macro.
- *! 14-Nov-1996 gp: Renamed from wsxchnl.h.
- *! 09-Sep-1996 gp: Added hReserved2 field to CHNL_ATTRS. Updated CHNL_INFO.
- *! 10-Jul-1996 gp: Created from channel.h.
- */
-
-#ifndef CHNLDEFS_
-#define CHNLDEFS_
-
-/* Channel id option. */
-#define CHNL_PICKFREE       (~0UL)	/* Let manager pick a free channel. */
-
-/* Channel manager limits: */
-#define CHNL_INITIOREQS      4	/* Default # of I/O requests.       */
-
-/* Channel modes */
-#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP.      */
-#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP.    */
-
-/* GetIOCompletion flags */
-#define CHNL_IOCINFINITE     0xffffffff	/* Wait forever for IO completion. */
-#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available.   */
-
-/* IO Completion Record status: */
-#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed.             */
-#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled          */
-#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out.   */
-#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached.    */
-
-/* Macros for checking I/O Completion status: */
-#define CHNL_IsEOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
-#define CHNL_IsIOComplete(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
-#define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
-#define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
-
-/* CHNL types: */
-	typedef u32 CHNL_MODE;	/* Channel transfer mode.         */
-
-/* Channel attributes: */
-	struct CHNL_ATTRS {
-		u32 uIOReqs;	/* Max # of preallocated I/O requests.    */
-		HANDLE hEvent;	/* User supplied auto-reset event object. */
-		char *pstrEventName;	/* Ptr to name of user event object.  */
-		HANDLE hReserved1;	/* Reserved for future use.         */
-		u32 hReserved2;	/* Reserved for future use.        */
-
-	};
-
-/* I/O completion record: */
-	struct CHNL_IOC {
-		void *pBuf;	/* Buffer to be filled/emptied.           */
-		u32 cBytes;	/* Bytes transferred.                     */
-		u32 cBufSize;	/* Actual buffer size in bytes            */
-		u32 status;	/* Status of IO completion.               */
-		u32 dwArg;	/* User argument associated with pBuf.    */
-	} ;
-
-#endif				/* CHNLDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/chnl.h
+++ /dev/null
@@ -1,537 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/chnl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== chnl.h ========
- *  Description:
- *      WCD channel interface: multiplexes data streams through the single
- *      physical link managed by a mini-driver.
- *
- *  Public Functions:
- *      CHNL_AddIOReq
- *      CHNL_AllocBuffer
- *      CHNL_CancelIO
- *      CHNL_Close
- *      CHNL_CloseOrphans
- *      CHNL_Create
- *      CHNL_Destroy
- *      CHNL_Exit
- *      CHNL_FlushIO
- *      CHNL_FreeBuffer
- *      CHNL_GetEventHandle
- *      CHNL_GetHandle
- *      CHNL_GetIOCompletion
- *      CHNL_GetId
- *      CHNL_GetMgr
- *      CHNL_GetMode
- *      CHNL_GetPosition
- *      CHNL_GetProcessHandle
- *      CHNL_Init
- *      CHNL_Open
- *
- *  Notes:
- *      See DSP API chnl.h for more details.
- *
- *! Revision History:
- *! ================
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 24-Oct-1996 gp: Move CloseOrphans into here from dspsys.
- *! 09-Sep-1996 gp: Added CHNL_GetProcessID() and CHNL_GetHandle().
- *! 10-Jul-1996 gp: Created.
- */
-
-#ifndef CHNL_
-#define CHNL_
-
-#include <chnlpriv.h>
-
-/*
- *  ======== CHNL_AddIOReq ========
- *  Purpose:
- *      Enqueue an I/O request for data transfer with the DSP on this channel.
- *      The direction (mode) is specified in the channel object.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      pHostBuf:       Host buffer address source.
- *      cBytes:         Number of PC bytes to transfer. A zero value indicates
- *                      that this buffer is the last in the output channel.
- *                      A zero value is invalid for an input channel.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pHostBuf is invalid.
- *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
- *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
- *                      I/O is allowed.
- *      CHNL_E_EOS:     End of stream was already marked on a previous
- *                      IORequest on this output channel. Not returned for
- *                      input channels.
- *      CHNL_E_NOIORPS: No free IO request packets available for queuing.
- *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
- *                      the size of the physical shared memory output window.
- *  Requires:
- *      CHNL_Init() called.
- *      pHostBuf points to memory which can be safely accessed at interrupt
- *      time without page fault.
- *  Ensures:
- *      The buffer will be transferred if the channel is ready; otherwise, will
- *      be queued for transfer when the channel becomes ready.  In any case,
- *      notifications of I/O completion are asynchronous.
- *      If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's on
- *      this channel will fail with error code CHNL_E_EOS.  The corresponding
- *      IOC for this I/O request will have its status flag set to
- *      CHNL_IOCSTATEOS.
- */
-	extern DSP_STATUS CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
-					void *pHostBuf,
-					u32 cBytes);
-
-/*
- *  ======== CHNL_AllocBuffer ========
- *  Purpose:
- *      Allocate a zero-initialized buffer to be used in data transfers though
- *      a channel managed by this channel manager.
- *  Parameters:
- *      ppBuf:              Location to store buffer pointer.
- *      hChnlMgr:           Handle to a valid channel manager.
- *      cBytes:             Size of buffer in bytes. Must be greater than zero.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EPOINTER:       ppBuf is invalid.
- *      DSP_EHANDLE:        hChnlMgr is invalid.
- *      DSP_EMEMORY:        Insufficient memory to allocate buffer.
- *      DSP_EINVALIDARG:    Invalid cBytes value.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:            *ppBuf points to memory which can be accessed in
- *                          any context.
- *      else:               *ppBuf contains NULL if ppBuf != NULL.
- */
-	extern DSP_STATUS CHNL_AllocBuffer(OUT void **ppBuf,
-					   struct CHNL_MGR *hChnlMgr,
-					   u32 cBytes);
-
-/*
- *  ======== CHNL_CancelIO ========
- *  Purpose:
- *      Return all I/O requests to the client which have not yet been
- *      transferred.  The channel's I/O completion object is
- *      signalled, and all the I/O requests are queued as IOC's, with the
- *      status field set to CHNL_IOCSTATCANCEL.
- *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
- *  Parameters:
- *      hChnl:          Channel object handle.
- *  Returns:
- *      DSP_SOK:           Success;
- *      DSP_EHANDLE:       Invalid hChnl.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      Subsequent I/O requests to this channel will not be accepted.
- */
-	extern DSP_STATUS CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
-
-/*
- *  ======== CHNL_Close ========
- *  Purpose:
- *      Ensures all pending I/O on this channel is cancelled, discards all
- *      queued I/O completion notifications, then frees the resources allocated
- *      for this channel, and makes the corresponding logical channel id
- *      available for subsequent use.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *  Requires:
- *      CHNL_Init() called.
- *      No thread must be blocked on this channel's I/O completion event.
- *  Ensures:
- *      DSP_SOK:        The I/O completion event for this channel is freed.
- *                      hChnl is no longer valid.
- */
-	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
-
-/*
- *  ======== CHNL_CloseOrphans ========
- *  Purpose:
- *      Close open channels orphaned by a closing process.
- *  Parameters:
- *      hChnlMgr:       Channel manager holding the channels.
- *      hProcess:       Kernel mode handle of the process claiming the channels.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_SFALSE:     No channels were left open by this process.
- *      DSP_EHANDLE:    Invalid hChnlMgr handle.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_CloseOrphans(struct CHNL_MGR *hChnlMgr,
-					    HANDLE hProcess);
-
-/*
- *  ======== CHNL_Create ========
- *  Purpose:
- *      Create a channel manager object, responsible for opening new channels
- *      and closing old ones for a given board.
- *  Parameters:
- *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
- *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels:   Max channels
- *      pMgrAttrs->bIRQ:        Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
- *  Returns:
- *      DSP_SOK:                Success;
- *      DSP_EHANDLE:            hDevObject is invalid.
- *      DSP_EINVALIDARG:        cChannels is 0.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
- *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
- *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
- *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
- *      CHNL_E_MGREXISTS:       Channel manager already exists for this device.
- *  Requires:
- *      CHNL_Init() called.
- *      phChnlMgr != NULL.
- *      pMgrAttrs != NULL.
- *  Ensures:
- *      DSP_SOK:                Subsequent calls to CHNL_Create() for the same
- *                              board without an intervening call to
- *                              CHNL_Destroy() will fail.
- */
-	extern DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct CHNL_MGRATTRS *pMgrAttrs);
-
-/*
- *  ======== CHNL_Destroy ========
- *  Purpose:
- *      Close all open channels, and destroy the channel manager.
- *  Parameters:
- *      hChnlMgr:           Channel manager object.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        hChnlMgr was invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:            Cancels I/O on each open channel.
- *                          Closes each open channel.
- *                          CHNL_Create may subsequently be called for the
- *                          same board.
- */
-	extern DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
-
-/*
- *  ======== CHNL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CHNL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CHNL_Init() previously called.
- *  Ensures:
- *      Resources, if any acquired in CHNL_Init(), are freed when the last
- *      client of CHNL calls CHNL_Exit().
- */
-	extern void CHNL_Exit();
-
-/*
- *  ======== CHNL_FlushIO ========
- *  Purpose:
- *      For an output stream (to the DSP), flush all pending IO requests to the
- *      output device.  This function will wait for IO completion for each of
- *      the queued IO requests, up to the specified timeout (per IOR).   For
- *      input streams (from the DSP), will cancel all pending IO requests.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      Timeout in milliseconds to wait for I/O completion.
- *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
- *                      The value of CHNL_IOCNOWAIT is not allowed.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EINVALIDARG:    dwTimeOut value of CHNL_IOCNOWAIT was given.
- *      CHNL_E_WAITTIMEOUT: Wait for flush of output stream timed out.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:        No I/O requests will be pending on this channel.
- */
-	extern DSP_STATUS CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
-					u32 dwTimeOut);
-
-/*
- *  ======== CHNL_FreeBuffer ========
- *  Purpose:
- *      Free a buffer previously allocated using CHNL_AllocBuffer().
- *  Parameters:
- *      hChnlMgr:       Handle to a valid channel manager.
- *      cBytes:         Size of buffer in bytes.
- *      pBuf:           Buffer pointer returned by CHNL_FreeBuffer().
- *  Returns:
- *      DSP_SOK:           Success.
- *      DSP_EHANDLE:       hChnlMgr is invalid.
- *      DSP_EINVALIDARG:   pBuf is NULL.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_FreeBuffer(struct CHNL_MGR *hChnlMgr,
-					  u32 cBytes,
-					  void *pBuf);
-
-/*
- *  ======== CHNL_GetEventHandle ========
- *  Purpose:
- *      Retrieve this channel's I/O completion auto-reset event.
- *  Parameters:
- *      hChnl:          Handle to a valid channel object.
- *      phEvent:        Location to store the I/O completion event object.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   phEvent is invalid.
- *  Requires:
- *      CHNL_Init() called.
-
- */
-	extern DSP_STATUS CHNL_GetEventHandle(struct CHNL_OBJECT *hChnl,
-					      OUT HANDLE *phEvent);
-
-/*
- *  ======== CHNL_GetHandle ========
- *  Purpose:
- *      Retrieve the channel handle given the logical ID and channel manager.
- *  Parameters:
- *      hChnlMgr:           Handle to a valid channel manager, or NULL.
- *      uChnlID:            Channel ID.
- *      phChnl:             Location to store channel handle.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnlMgr.
- *      DSP_EPOINTER:       phChnl == NULL.
- *      CHNL_E_BADCHANID:   Invalid channel ID.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:            *phChnl points to a valid channel object,
- *                          if phChnl != NULL.
- */
-	extern DSP_STATUS CHNL_GetHandle(struct CHNL_MGR *hChnlMgr,
-					 u32 uChnlID,
-					 OUT struct CHNL_OBJECT **phChnl);
-
-/*
- *  ======== CHNL_GetIOCompletion ========
- *  Purpose:
- *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
- *      completion record, which contains information about the completed
- *      I/O request.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      Timeout in milliseconds to wait for completion.
- *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
- *                      A value of CHNL_IOCNOWAIT will simply dequeue the
- *                      first available IOC.
- *      pIOC:           On output, contains host buffer address, bytes
- *                      transferred, and status of I/O completion.
- *      pIOC->status:   I/O Completion status: see chnldefs.h for definitions.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pIOC is invalid.
- *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
- *                      yet no I/O completions were queued.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:        If there are any remaining IOC's queued before this
- *                      call returns, the channel event object will be left
- *                      in a signalled state.
- *      If the return status is anything other than DSP_EPOINTER or DSP_SOK,
- *      then pIOC->pBuf will be set to NULL, pIOC->cBytes will be 0, and
- *      pIOC->status will be undefined.
- */
-	extern DSP_STATUS CHNL_GetIOCompletion(struct CHNL_OBJECT *hChnl,
-					       u32 dwTimeOut,
-					       OUT struct CHNL_IOC *pIOC);
-
-/*
- *  ======== CHNL_GetId ========
- *  Purpose:
- *      Retrieve the channel logical ID of this channel.
- *  Parameters:
- *      hChnl:          Handle to a valid channel object.
- *      pdwID:          Location to store logical ID.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pdwID is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetId(struct CHNL_OBJECT *hChnl,
-				     OUT u32 *pdwID);
-
-/*
- *  ======== CHNL_GetMgr ========
- *  Purpose:
- *      Retrieve a channel manager handle, required for opening new channels
- *      and closing old ones on a given board.
- *  Parameters:
- *      hDevNode:       A valid system specific DEVNODE handle.
- *      phChnlMgr:      Location to store the channel manager handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hDevNode is invalid.
- *      CHNL_E_NOMGR:   No channel manager exists for this board.
- *  Requires:
- *      CHNL_Init() called.
- *      phChnlMgr != NULL.
- *  Ensures:
- *      DSP_SOK: The DSP board represented by hDevNode was in the RUNNING state
- *            before this function returned.
- *      else: *phChnlMgr == NULL.
- */
-	extern DSP_STATUS CHNL_GetMgr(struct CFG_DEVNODE *hDevNode,
-				      OUT struct CHNL_MGR **phChnlMgr);
-
-/*
- *  ======== CHNL_GetMode ========
- *  Purpose:
- *      Retrieve the mode flags of this channel.
- *  Parameters:
- *      hChnl:              Handle to a valid channel object.
- *      pMode:              Location to store mode flags.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       pMode is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetMode(struct CHNL_OBJECT *hChnl,
-				       OUT CHNL_MODE * pMode);
-
-/*
- *  ======== CHNL_GetPosition ========
- *  Purpose:
- *      Retrieve the total number of bytes transferred on this channel.
- *  Parameters:
- *      hChnl:              Handle to a valid channel object.
- *      pcPosition:         Location to store number of bytes.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       pcPosition is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetPosition(struct CHNL_OBJECT *hChnl,
-					   OUT u32 *pcPosition);
-
-/*
- *  ======== CHNL_GetProcessHandle ========
- *  Purpose:
- *      Retrieve the handle of the process owning this channel.
- *  Parameters:
- *      hChnl:              Channel handle.
- *      phProcess:          Location to store the process handle.  A NULL value
- *                          indicates the channel is either closed or is not
- *                          owned by any particular process.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       phProcess is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetProcessHandle(struct CHNL_OBJECT *hChnl,
-						OUT HANDLE *phProcess);
-
-/*
- *  ======== CHNL_Init ========
- *  Purpose:
- *      Initialize the CHNL module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occurred.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CHNL functions.
- */
-	extern bool CHNL_Init();
-
-/*
- *  ======== CHNL_Open ========
- *  Purpose:
- *      Open a new half-duplex channel to the DSP board.
- *  Parameters:
- *      phChnl:         Location to store a channel object handle.
- *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
- *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
- *                      direction of data transfer.
- *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
- *                      select a free channel id (default);
- *                      otherwise this field specifies the id of the channel.
- *      pAttrs:         Channel attributes.  Attribute fields are as follows:
- *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
- *                       be pending at any given time. All request packets are
- *                       preallocated when the channel is opened.
- *      pAttrs->hEvent: This field allows the user to supply an auto reset
- *                      event object for channel I/O completion notifications.
- *                      It is the responsibility of the user to destroy this
- *                      object AFTER closing the channel.
- *                      This channel event object can be retrieved using
- *                      CHNL_GetEventHandle().
- *      pAttrs->hReserved: The kernel mode handle of this event object.
- *
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            hChnlMgr is invalid.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      DSP_EINVALIDARG:        Invalid number of IOReqs.
- *      CHNL_E_BADMODE:         Invalid mode argument.
- *      CHNL_E_OUTOFSTREAMS:    No free channels available.
- *      CHNL_E_BADCHANID:       Channel ID is out of range.
- *      CHNL_E_CHANBUSY:        Channel is in use.
- *  Requires:
- *      CHNL_Init() called.
- *      phChnl != NULL.
- *      pAttrs != NULL.
- *      pAttrs->hEvent is a valid event handle.
- *  Ensures:
- *      DSP_SOK:        *phChnl is a valid channel.
- *      else:           *phChnl is set to NULL if (phChnl != NULL);
- */
-	extern DSP_STATUS CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-				    struct CHNL_MGR *hChnlMgr, CHNL_MODE uMode,
-				    u32 uChnlId,
-				    CONST IN struct CHNL_ATTRS *pAttrs);
-
-#endif				/* CHNL_ */
--- a/arch/arm/plat-omap/include/bridge/chnlpriv.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/chnlpriv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== chnlpriv.h ========
- *  Description:
- *      Private channel header shared between DSPSYS, WCD and WMD modules.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 05-Jan-2002 ag  Added cChannels(total # of chnls) to CHNL_MGRINFO struct.
- *!                 Added private CHNL_[PCPY][ZCPY][DDMA].
- *! 17-Nov-2000 jeh Removed IRQ, shared memory from CHNL_MGRATTRS, since these
- *!                 now belong to IO_ATTRS.
- *! 21-Jan-2000 ag: Code review comments added.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 11-Dec-1999 ag: Added CHNL_MAXLOCKPAGES for CHNL_PrepareBuffer().
- *! 04-Dec-1999 ag: Added CHNL_MAXEVTNAMELEN for i/o compl named event support.
- *! 01-Nov-1999 ag: CHNL_MAXCHANNELS set to 16 for 16-bit DSPs.
- *! 27-Oct-1997 cr: Expanded CHNL_MAXIRQ from 0x0f to 0xff.
- *! 16-Jan-1997 gp: Moved symbols into here from chnldefs.h.
- *! 03-Jan-1997 gp: Added CHNL_MAXIRQ define.
- *! 09-Dec-1996 gp: Removed CHNL_STATEIDLE.
- *! 15-Jul-1996 gp: Created.
- */
-
-#ifndef CHNLPRIV_
-#define CHNLPRIV_
-
-#include <chnldefs.h>
-#include <devdefs.h>
-#include <sync.h>
-
-/* CHNL Object validation signatures: */
-#define CHNL_MGRSIGNATURE   0x52474D43	/* "CMGR" (in reverse). */
-#define CHNL_SIGNATURE      0x4C4E4843	/* "CHNL" (in reverse). */
-
-/* Channel manager limits: */
-#define CHNL_MAXCHANNELS    32	/* Max channels available per transport */
-
-
-/*
- *  Trans port channel Id definitions:(must match dsp-side).
- *
- *  For CHNL_MAXCHANNELS = 16:
- *
- *  ChnlIds:
- *      0-15  (PCPY) - transport 0)
- *      16-31 (DDMA) - transport 1)
- *      32-47 (ZCPY) - transport 2)
- */
-#define CHNL_PCPY       0	/* Proc-copy transport 0 */
-
-#define CHNL_MAXIRQ     0xff	/* Arbitrarily large number. */
-
-/* The following modes are private: */
-#define CHNL_MODEUSEREVENT  0x1000	/* User provided the channel event. */
-#define CHNL_MODEMASK       0x1001
-
-/* Higher level channel states: */
-#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O.    */
-#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled.        */
-#define CHNL_STATEEOS       0x0002	/* End Of Stream reached.    */
-
-/* Determine if user supplied an event for this channel:  */
-#define CHNL_IsUserEvent(mode)  (mode & CHNL_MODEUSEREVENT)
-
-/* Macros for checking mode: */
-#define CHNL_IsInput(mode)      (mode & CHNL_MODEFROMDSP)
-#define CHNL_IsOutput(mode)     (!CHNL_IsInput(mode))
-
-/* Types of channel class libraries: */
-#define CHNL_TYPESM         1	/* Shared memory driver. */
-#define CHNL_TYPEBM         2	/* Bus Mastering driver. */
-
-/* Max string length of channel I/O completion event name - change if needed */
-#define CHNL_MAXEVTNAMELEN  32
-
-/* Max memory pages lockable in CHNL_PrepareBuffer() - change if needed */
-#define CHNL_MAXLOCKPAGES   64
-
-/* Channel info.  */
-	 struct CHNL_INFO {
-		struct CHNL_MGR *hChnlMgr;	/* Owning channel manager.   */
-		u32 dwID;	/* Channel ID.                            */
-		HANDLE hEvent;	/* Channel I/O completion event.          */
-		/*Abstraction of I/O completion event.*/
-		struct SYNC_OBJECT *hSyncEvent;
-		u32 dwMode;	/* Channel mode.                          */
-		u32 dwState;	/* Current channel state.                 */
-		u32 cPosition;	/* Total bytes transferred.        */
-		u32 cIOCs;	/* Number of IOCs in queue.               */
-		u32 cIOReqs;	/* Number of IO Requests in queue.        */
-		HANDLE hProcess;	/* Process owning this channel.     */
-		/*
-		 * Name of channel I/O completion event. Not required in Linux
-		 */
-		char szEventName[CHNL_MAXEVTNAMELEN + 1];
-	} ;
-
-/* Channel manager info: */
-	struct CHNL_MGRINFO {
-		u32 dwType;	/* Type of channel class library.         */
-		/* Channel handle, given the channel id. */
-		struct CHNL_OBJECT *hChnl;
-		u32 cOpenChannels;	/* Number of open channels.     */
-		u32 cChannels;	/* total # of chnls supported */
-	} ;
-
-/* Channel Manager Attrs: */
-	struct CHNL_MGRATTRS {
-		/* Max number of channels this manager can use. */
-		u32 cChannels;
-		u32 uWordSize;	/* DSP Word size.                       */
-	} ;
-
-#endif				/* CHNLPRIV_ */
--- a/arch/arm/plat-omap/include/bridge/_chnl_sm.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/_chnl_sm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== _chnl_sm.h ========
- *  Description:
- *      Private header file defining channel manager and channel objects for
- *      a shared memory channel driver.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *      Shared between the modules implementing the shared memory channel class
- *      library.
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc  Removed legacy PERF code.
- *! 12-Jan-2002 ag  Removed unused gppReqIO & ddmaChnlId DDMA fields.
- *!                 Added zero-copy chnl descriptor array: zchnldesc.
- *! 21-Dec-2001 ag  Moved descPaGpp to private chnl obj from chnl descriptor.
- *! 20-May-2001 ag/jeh Removed fShmSyms field from CHNL_MGR.
- *! 04-Feb-2001 ag  DSP-DMA support added.
- *! 26-Oct-2000 jeh Added arg and resvd to SHM control structure. Added dwArg
- *!                 to CHNL_IRP.
- *! 16-Oct-2000 jeh Removed #ifdef DEBUG from around channel object's cIOCs
- *!                 field, added cIOReqs.
- *! 20-Jan-2000 ag: Incorporated code review comments.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 03-Nov-1999 ag: Added szEventName[] to CHNL object for name event support.
- *! 02-Nov-1999 ag: _SHM_BEG & _END Syms from COFF now used for IO and SM CLASS.
- *! 27-Oct-1999 jeh Define SHM structure to work for 16-bit targets.
- *! 25-May-1999 jg: Added target side symbol names for share memory buffer
- *! 03-Jan-1997 gp: Added fSharedIRQ field.
- *! 22-Oct-1996 gp: Made dwProcessID a handle.
- *! 09-Sep-1996 gp: Added dwProcessID field to CHNL_OBJECT.
- *! 13-Aug-1996 gp: Created.
- */
-
-#ifndef _CHNL_SM_
-#define _CHNL_SM_
-
-#include <wcd.h>
-#include <wmd.h>
-#include <dpc.h>
-
-#include <list.h>
-#include <ntfy.h>
-
-/*
- *  These target side symbols define the beginning and ending addresses
- *  of shared memory buffer. They are defined in the *cfg.cmd file by
- *  cdb code.
- */
-#define CHNL_SHARED_BUFFER_BASE_SYM "_SHM_BEG"
-#define CHNL_SHARED_BUFFER_LIMIT_SYM "_SHM_END"
-#define BRIDGEINIT_BIOSGPTIMER "_BRIDGEINIT_BIOSGPTIMER"
-#define BRIDGEINIT_LOADMON_GPTIMER "_BRIDGEINIT_LOADMON_GPTIMER"
-
-#ifndef _CHNL_WORDSIZE
-#define _CHNL_WORDSIZE 4	/* default _CHNL_WORDSIZE is 2 bytes/word */
-#endif
-
-#ifdef CONFIG_ARCH_OMAP3430
-
-#define MAXOPPS 16
-
-struct oppTableEntry {
-    u32 voltage;
-    u32 frequency;
-    u32 minFreq;
-    u32 maxFreq;
-} ;
-
-struct oppStruct {
-    u32 currOppPt;
-    u32 numOppPts;
-    struct oppTableEntry oppPoint[MAXOPPS];
-} ;
-
-/* Request to MPU */
-struct oppRqstStruct {
-    u32 rqstDspFreq;
-    u32 rqstOppPt;
-};
-
-/* Info to MPU */
-struct loadMonStruct {
-    u32 currDspLoad;
-    u32 currDspFreq;
-    u32 predDspLoad;
-    u32 predDspFreq;
-};
-
-#endif
-
-	enum SHM_DESCTYPE {
-		SHM_CURROPP = 0,
-		SHM_OPPINFO = 1,
-		SHM_GETOPP = 2,		/* Get DSP requested OPP info */
-	} ;
-
-/* Structure in shared between DSP and PC for communication.*/
-	struct SHM {
-		u32 dspFreeMask;	/* Written by DSP, read by PC. */
-		u32 hostFreeMask;	/* Written by PC, read by DSP */
-
-		u32 inputFull;	/* Input channel has unread data. */
-		u32 inputId;	/* Channel for which input is available. */
-		u32 inputSize;	/* Size of data block (in DSP words). */
-
-		u32 outputFull;	/* Output channel has unread data. */
-		u32 outputId;	/* Channel for which output is available. */
-		u32 outputSize;	/* Size of data block (in DSP words). */
-
-		u32 arg;	/* Arg for Issue/Reclaim (23 bits for 55x). */
-		u32 resvd;	/* Keep structure size even for 32-bit DSPs */
-
-#ifdef CONFIG_ARCH_OMAP3430
-		/* Operating Point structure */
-		struct oppStruct  oppTableStruct;
-		/* Operating Point Request structure */
-		struct oppRqstStruct oppRequest;
-		/* load monitor information structure*/
-		struct loadMonStruct loadMonInfo;
-		char dummy[184];             /* padding to 256 byte boundary */
-		u32 shm_dbg_var[64];         /* shared memory debug variables */
-#endif
-	} ;
-
-	/* Channel Manager: only one created per board: */
-	struct CHNL_MGR {
-		u32 dwSignature;	/* Used for object validation */
-		/* Function interface to WMD */
-		struct WMD_DRV_INTERFACE *pIntfFxns;
-		struct IO_MGR *hIOMgr;	/* IO manager */
-		/* Device this board represents */
-		struct DEV_OBJECT *hDevObject;
-
-		/* These fields initialized in WMD_CHNL_Create():    */
-		u32 dwOutputMask; /* Host output channels w/ full buffers */
-		u32 dwLastOutput;	/* Last output channel fired from DPC */
-		/* Critical section object handle */
-		struct SYNC_CSOBJECT *hCSObj;
-		u32 uWordSize;	/* Size in bytes of DSP word */
-		u32 cChannels;	/* Total number of channels */
-		u32 cOpenChannels;	/* Total number of open channels */
-		struct CHNL_OBJECT **apChannel;	/* Array of channels */
-		u32 dwType;	/* Type of channel class library */
-		/* If no SHM syms, return for CHNL_Open */
-		DSP_STATUS chnlOpenStatus;
-	} ;
-
-/*
- *  Channel: up to CHNL_MAXCHANNELS per board or if DSP-DMA supported then
- *     up to CHNL_MAXCHANNELS + CHNL_MAXDDMACHNLS per board.
- */
-	struct CHNL_OBJECT {
-		u32 dwSignature;	/* Used for object validation */
-		/* Pointer back to channel manager */
-		struct CHNL_MGR *pChnlMgr;
-		u32 uId;	/* Channel id */
-		u32 dwState;	/* Current channel state */
-		u32 uMode;	/* Chnl mode and attributes */
-		/* Chnl I/O completion event (user mode) */
-		HANDLE hUserEvent;
-		/* Abstract syncronization object */
-		struct SYNC_OBJECT *hSyncEvent;
-		/* Name of Sync event */
-		char szEventName[SYNC_MAXNAMELENGTH + 1];
-               u32 hProcess;   /* Process which created this channel */
-		u32 pCBArg;	/* Argument to use with callback */
-		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
-		s32 cIOCs;	/* Number of IOC's in queue */
-		s32 cIOReqs;	/* Number of IORequests in queue */
-		s32 cChirps;	/* Initial number of free Irps */
-		/* List of IOC's from driver */
-		struct LST_LIST *pIOCompletions;
-		struct LST_LIST *pFreeList;	/* List of free Irps */
-		struct NTFY_OBJECT *hNtfy;
-		u32 cBytesMoved;	/* Total number of bytes transfered */
-
-		/* For DSP-DMA */
-
-		/* Type of chnl transport:CHNL_[PCPY][DDMA] */
-		u32 uChnlType;
-	} ;
-
-/* I/O Request/completion packet: */
-	struct CHNL_IRP {
-		struct LST_ELEM link;	/* Link to next CHIRP in queue. */
-		/* Buffer to be filled/emptied. (User)   */
-		u8 *pHostUserBuf;
-		/* Buffer to be filled/emptied. (System) */
-		u8 *pHostSysBuf;
-		u32 dwArg;	/* Issue/Reclaim argument.               */
-		u32 uDspAddr;	/* Transfer address on DSP side.         */
-		u32 cBytes;	/* Bytes transferred.                    */
-		u32 cBufSize;	/* Actual buffer size when allocated.    */
-		u32 status;	/* Status of IO completion.              */
-	} ;
-
-#endif				/* _CHNL_SM_ */
--- a/arch/arm/plat-omap/include/bridge/chnl_sm.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * dspbridge/inc/chnl_sm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== chnl_sm.h ========
- *  Description:
- *      Prototypes for channel lower edge functions for a WinBRIDGE mini driver
- *      implementing data transfer via shared memory.
- *
- *  Public Functions:
- *      CHNLSM_DisableInterrupt;
- *      CHNLSM_DPC;
- *      CHNLSM_EnableInterrupt;
- *      CHNLSM_InterruptDSP;
- *      CHNLSM_ISR;
- *      CHNLSM_Read;
- *      CHNLSM_UpdateSHMLength;
- *      CHNLSM_Write;
- *
- *  Notes:
- *      These lower edge functions must be implemented by the WMD writer.
- *      Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
- *      be defined to link.
- *
- *! Revision History:
- *! ================
- *! 06-Jan-2002 ag: Added CHNLSM_InterruptDSP2 to set Mailbox value.
- *! 05-Nov-2001 kc: Updated CHNLSM_ISR to read value returned by interrupt.
- *! 21-Jan-2000 ag: Updated comments per code review.
- *! 18-Dec-1997 gp: Added CDECL.
- *! 16-Jun-1997 gp: Added function UpdateSHMLength().
- *! 13-Nov-1996 gp: Renamed CHNL_ to CHNLSM_.
- *! 10-Jul-1996 gp: Created.
- */
-
-#ifndef CHNLSM_
-#define CHNLSM_
-
-#include <wmd.h>
-
-/*
- *  ======== CHNLSM_DisableInterrupt ========
- *  Purpose:
- *      Disable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT*
-							hDevContext);
-
-/*
- *  ======== CHNLSM_DPC ========
- *  Purpose:
- *      This mini-driver's deferred processing routine.  Finishes processing
- *      deferred by the WMD's ISR.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *      Must not block.
- *      Must not acquire resources.
- *      All data objects touched must be locked in memory.
- *  Ensures:
- */
-       extern void CHNLSM_DPC(struct WMD_DEV_CONTEXT *hDevContext);
-
-/*
- *  ======== CHNLSM_EnableInterrupt ========
- *  Purpose:
- *      Enable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT*
-						       hDevContext);
-
-/*
- *  ======== CHNLSM_InterruptDSP ========
- *  Purpose:
- *      Send an interrupt to the DSP processor(s).
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *      DSP_SOK:        Interrupt sent;
- *      else:           Unable to send interrupt.
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_InterruptDSP(struct WMD_DEV_CONTEXT*
-						    hDevContext);
-
-/*
- *  ======== CHNLSM_InterruptDSP2 ========
- *  Purpose:
- *      Set interrupt value & send an interrupt to the DSP processor(s).
- *      This is typicaly used when mailbox interrupt mechanisms allow data
- *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      wMbVal:         Value associated with interrupt(e.g. mailbox value).
- *  Returns:
- *      DSP_SOK:        Interrupt sent;
- *      else:           Unable to send interrupt.
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT*
-						     hDevContext, u16 wMbVal);
-
-/*
- *  ======== CHNLSM_ISR ========
- *  Purpose:
- *      Mini-driver's ISR, called by WCD when the board interrupts the host.
- *  Parameters:
- *      hDevContext:    Handle to the mini-driver defined device info.
- *      pfSchedDPC:     Set to TRUE to schedule a deferred procedure call
- *                      to advance the channel protocol.  The channel class
- *                      library will call the WMD's CHNLSM_DPC routine during
- *                      its own DPC, before dispatching I/O.
- *                      The channel class library should ignore *pfSchedDPC when
- *                      CHNLSM_ISR returns FALSE.
- *      pwMBRegVal:     Value of mailbox register.
- *  Returns:
- *      TRUE if this interrupt is was generated by the DSP board.
- *      FALSE otherwise.
- *  Requires:
- *      Interrupts to the host processor are disabled on entry.
- *      Must only call functions which are in page locked memory.
- *      Must only call asynchronous OS services.
- *      The EOI for this interrupt has already been sent to the PIC.
- *  Ensures:
- *      If the interrupt is *not* shared, this routine must return TRUE.
- */
-       extern bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *hDevContext,
-				     OUT bool *pfSchedDPC,
-				     OUT u16 *pwIntrVal);
-
-/*
- *  ======== CHNLSM_Read ========
- *  Purpose:
- *      Read data from DSP board memory into a Host buffer.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Destination).
- *      dwDSPAddr:      Address on DSP board (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_Read(struct WMD_DEV_CONTEXT *hDevContext,
-					    OUT u8 *pHostBuf,
-					    u32 dwDSPAddr, u32 ulNumBytes);
-
-/*
- *  ======== CHNLSM_UpdateSHMLength ========
- *  Purpose:
- *      Allow the minidriver a chance to override the SHM length as reported
- *      to the mini driver (chnl_sm.lib) by Windows Plug and Play.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pSHMLength:     Pointer to size of SHM window (in DSP words).
- *  Returns:
- *      TRUE if pSHMLength updated; FALSE otherwise.
- *  Requires:
- *      pSHMLength != NULL.
- *  Ensures:
- *      No more than sizeof(u32) bytes written to *pSHMLength
- */
-	extern bool CHNLSM_UpdateSHMLength(struct WMD_DEV_CONTEXT *hDevContext,
-					   IN OUT u32 *pSHMLength);
-
-/*
- *  ======== CHNLSM_Write ========
- *  Purpose:
- *      Write data from a Host buffer to DSP board memory.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Source).
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      ulNumBytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_Write(struct WMD_DEV_CONTEXT *hDevContext,
-					    IN u8 *pHostBuf,
-					    u32 dwDSPAddr, u32 ulNumBytes);
-
-#endif				/* CHNLSM_ */
--- a/arch/arm/plat-omap/include/bridge/clk.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/clk.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== clk.h ========
- *  Purpose: Provides Clock functions.
- *
- *! Revision History:
- *! ================
- *! 08-May-2007 rg: Moved all clock functions from sync module.
- */
-
-#ifndef _CLK_H
-#define _CLK_H
-
-	/* Generic TIMER object: */
-	struct TIMER_OBJECT;
-	enum SERVICES_ClkId {
-		SERVICESCLK_iva2_ck = 0,
-		SERVICESCLK_mailbox_ick,
-		SERVICESCLK_gpt5_fck,
-		SERVICESCLK_gpt5_ick,
-		SERVICESCLK_gpt6_fck,
-		SERVICESCLK_gpt6_ick,
-		SERVICESCLK_gpt7_fck,
-		SERVICESCLK_gpt7_ick,
-		SERVICESCLK_gpt8_fck,
-		SERVICESCLK_gpt8_ick,
-		SERVICESCLK_wdt3_fck,
-		SERVICESCLK_wdt3_ick,
-		SERVICESCLK_mcbsp1_fck,
-		SERVICESCLK_mcbsp1_ick,
-		SERVICESCLK_mcbsp2_fck,
-		SERVICESCLK_mcbsp2_ick,
-		SERVICESCLK_mcbsp3_fck,
-		SERVICESCLK_mcbsp3_ick,
-		SERVICESCLK_mcbsp4_fck,
-		SERVICESCLK_mcbsp4_ick,
-		SERVICESCLK_mcbsp5_fck,
-		SERVICESCLK_mcbsp5_ick,
-		SERVICESCLK_ssi_fck,
-		SERVICESCLK_ssi_ick,
-		SERVICESCLK_sys_32k_ck,
-		SERVICESCLK_sys_ck,
-		SERVICESCLK_NOT_DEFINED
-	} ;
-
-/*
- *  ======== CLK_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CLK initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void CLK_Exit();
-
-/*
- *  ======== CLK_Init ========
- *  Purpose:
- *      Initializes private state of CLK module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      CLK initialized.
- */
-	extern bool CLK_Init();
-
-
-/*
- *  ======== CLK_Enable ========
- *  Purpose:
- *      Enables the clock requested.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:	Success.
- *	DSP_EFAIL:	Error occured while enabling the clock.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id);
-
-/*
- *  ======== CLK_Disable ========
- *  Purpose:
- *      Disables the clock requested.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while disabling the clock.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id);
-
-/*
- *  ======== CLK_GetRate ========
- *  Purpose:
- *      Get the clock rate of requested clock.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while Getting the clock rate.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id,
-				     u32 *speedMhz);
-/*
- *  ======== CLK_Set_32KHz ========
- *  Purpose:
- *      Set the requested clock to 32KHz.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while setting the clock parent to 32KHz.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id);
-	extern void SSI_Clk_Prepare(bool FLAG);
-
-/*
- *  ======== CLK_Get_RefCnt ========
- *  Purpose:
- *      get the reference count for the clock.
- *  Parameters:
- *  Returns:
- *      s32:        Reference Count for the clock.
- *      DSP_EFAIL:  Error occured while getting the reference count of a clock.
- *  Requires:
- *  Ensures:
- */
-	extern s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id);
-
-#endif				/* _SYNC_H */
--- a/arch/arm/plat-omap/include/bridge/cmmdefs.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/cmmdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== cmmdefs.h ========
- *  Purpose:
- *      Global MEM constants and types.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-2001 ag  CMM_KERNMAPTYPE added for dsp<->device process addr map'n.
- *!                 This allows addr conversion from drvr process <-> DSP addr.
- *! 29-Aug-2001 ag  Added CMM_ALLSEGMENTS.
- *! 08-Dec-2000 ag  Added bus address conversion type CMM_POMAPEMIF2DSPBUS.
- *! 05-Dec-2000 ag  Added default CMM_DEFLTCONVFACTOR & CMM_DEFLTDSPADDROFFSET.
- *! 29-Oct-2000 ag  Added converstion factor for GPP DSP Pa translation.
- *! 15-Oct-2000 ag  Added address translator attributes and defaults.
- *! 12-Jul-2000 ag  Created.
- */
-
-#ifndef CMMDEFS_
-#define CMMDEFS_
-
-#include <list.h>
-
-/* Cmm attributes used in CMM_Create() */
-	struct CMM_MGRATTRS {
-		/* Minimum SM allocation; default 32 bytes.  */
-		u32 ulMinBlockSize;
-	} ;
-
-/* Attributes for CMM_AllocBuf() & CMM_AllocDesc() */
-	struct CMM_ATTRS {
-		u32 ulSegId;	/*  1,2... are SM segments. 0 is not. */
-		u32 ulAlignment;	/*  0,1,2,4....ulMinBlockSize */
-	} ;
-
-/*
- *  DSPPa to GPPPa Conversion Factor.
- *
- *  For typical platforms:
- *      converted Address = PaDSP + ( cFactor * addressToConvert).
- */
-	enum CMM_CNVTTYPE {
-		CMM_SUBFROMDSPPA = -1,
-		/* PreOMAP is special case: not simple offset */
-		CMM_POMAPEMIF2DSPBUS = 0,
-		CMM_ADDTODSPPA = 1
-	} ;
-
-#define CMM_DEFLTDSPADDROFFSET  0
-#define CMM_DEFLTCONVFACTOR     CMM_POMAPEMIF2DSPBUS /* PreOMAP DSPBUS<->EMIF */
-#define CMM_ALLSEGMENTS         0xFFFFFF	/* All SegIds */
-#define CMM_MAXGPPSEGS          1	/* Maximum # of SM segs */
-
-/*
- *  SMSEGs are SM segments the DSP allocates from.
- *
- *  This info is used by the GPP to xlate DSP allocated PAs.
- */
-
-	struct CMM_SEGINFO {
-		u32 dwSegBasePa;	/* Start Phys address of SM segment */
-		/* Total size in bytes of segment: DSP+GPP */
-		u32 ulTotalSegSize;
-		u32 dwGPPBasePA;	/* Start Phys addr of Gpp SM seg */
-		u32 ulGPPSize;	/* Size of Gpp SM seg in bytes */
-		u32 dwDSPBaseVA;	/* DSP virt base byte address */
-		u32 ulDSPSize;	/* DSP seg size in bytes */
-		/* # of current GPP allocations from this segment */
-		u32 ulInUseCnt;
-		u32 dwSegBaseVa;	/* Start Virt address of SM seg */
-
-	} ;
-
-/* CMM useful information */
-	struct CMM_INFO {
-		/* # of SM segments registered with this Cmm. */
-		u32 ulNumGPPSMSegs;
-		/* Total # of allocations outstanding for CMM */
-		u32 ulTotalInUseCnt;
-		/* Min SM block size allocation from CMM_Create() */
-		u32 ulMinBlockSize;
-		/* Info per registered SM segment. */
-		struct CMM_SEGINFO segInfo[CMM_MAXGPPSEGS];
-	} ;
-
-/* XlatorCreate attributes */
-	struct CMM_XLATORATTRS {
-		u32 ulSegId;	/* segment Id used for SM allocations */
-		u32 dwDSPBufs;	/* # of DSP-side bufs */
-		u32 dwDSPBufSize;	/* size of DSP-side bufs in GPP bytes */
-		/* Vm base address alloc'd in client process context */
-		void *pVmBase;
-		/* dwVmSize must be >= (dwMaxNumBufs * dwMaxSize) */
-		u32 dwVmSize;
-	} ;
-
-/*
- * Cmm translation types. Use to map SM addresses to process context.
- */
-	enum CMM_XLATETYPE {
-		CMM_VA2PA = 0,	/* Virtual to GPP physical address xlation */
-		CMM_PA2VA = 1,	/* GPP Physical to virtual  */
-		CMM_VA2DSPPA = 2,	/* Va to DSP Pa  */
-		CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
-		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
-	} ;
-
-/*
- *  Used to "map" between device process virt addr and dsp addr.
- */
-	enum CMM_KERNMAPTYPE {
-		CMM_KERNVA2DSP = 0, /* Device process context to dsp address. */
-		CMM_DSP2KERNVA = 1, /* Dsp address to device process context. */
-	} ;
-
-	struct CMM_OBJECT;
-	struct CMM_XLATOROBJECT;
-
-#endif				/* CMMDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/cmm.h
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/cmm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== cmm.h ========
- *  Purpose:
- *      The Communication Memory Management(CMM) module provides shared memory
- *      management services for DSP/BIOS Bridge data streaming and messaging.
- *      Multiple shared memory segments can be registered with CMM. Memory is
- *      coelesced back to the appropriate pool when a buffer is freed.
- *
- *      The CMM_Xlator[xxx] functions are used for node messaging and data
- *      streaming address translation to perform zero-copy inter-processor
- *      data transfer(GPP<->DSP). A "translator" object is created for a node or
- *      stream object that contains per thread virtual address information. This
- *      translator info is used at runtime to perform SM address translation
- *      to/from the DSP address space.
- *
- *
- *  Public Functions:
- *      CMM_CallocBuf
- *      CMM_Create
- *      CMM_Destroy
- *      CMM_Exit
- *      CMM_FreeBuf
- *      CMM_GetHandle
- *      CMM_GetInfo
- *      CMM_Init
- *      CMM_RegisterGPPSMSeg
- *      CMM_UnRegisterGPPSMSeg
- *      CMM_XlatorAllocBuf       (Note #1 below)
- *      CMM_XlatorCreate           "
- *      CMM_XlatorDelete           "
- *      CMM_XlatorFreeBuf          "
- *      CMM_XlatorTranslate        "
- *
- *
- *  Notes:
- *      #1: Used by Node and Stream modules for SM address translation.
- *
- *! Revision History:
- *! ================
- *! 30-Jan-2002 ag  Removed unused CMM_Alloc[Free]Desc & CMM_XlatorRegisterPa.
- *!                 Renamed CMM_AllocBuf() to CMM_CallocBuf().
- *! 29-Aug-2001 ag: Added dsp virt base and size to CMM_RegisterGPPSMSeg().
- *! 12-Aug-2001 ag: Added CMM_UnRegisterGPP[DSP}SMSeg[s]().
- *! 05-Dec-2000 ag: Added param to CMM_XlatorDelete() to force buf cleanup.
- *! 30-Oct-2000 ag: Added conversion factor to CMM_RegisterDSP[GPP]SMSeg().
- *! 12-Oct-2000 ag: Added CMM_Xlator[xxx] functions.
- *! 10-Aug-2000 ag: Created.
- *!
- */
-
-#ifndef CMM_
-#define CMM_
-
-#include <devdefs.h>
-
-#include <cmmdefs.h>
-#include <host_os.h>
-
-/*
- *  ======== CMM_CallocBuf ========
- *  Purpose:
- *      Allocate memory buffers that can be used for data streaming or
- *      messaging.
- *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
- *      uSize:     Number of bytes to allocate.
- *      pAttr:     Attributes of memory to allocate.
- *      ppBufVA:   Address of where to place VA.
- *  Returns:
- *      Pointer to a zero'd block of SM memory;
- *      NULL if memory couldn't be allocated,
- *      or if cBytes == 0,
- *  Requires:
- *      Valid hCmmMgr.
- *      CMM initialized.
- *  Ensures:
- *      The returned pointer, if not NULL, points to a valid memory block of
- *      the size requested.
- *
- */
-	extern void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr,
-				   u32 uSize, struct CMM_ATTRS *pAttrs,
-				   OUT void **ppBufVA);
-
-/*
- *  ======== CMM_Create ========
- *  Purpose:
- *      Create a communication memory manager object.
- *  Parameters:
- *      phCmmMgr:   Location to store a communication manager handle on output.
- *      hDevObject: Handle to a device object.
- *      pMgrAttrs:  Comm mem manager attributes.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      Failed to initialize critical sect sync object.
- *
- *  Requires:
- *      CMM_Init() called.
- *      phCmmMgr != NULL.
- *      pMgrAttrs->ulMinBlockSize >= 4 bytes.
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct CMM_MGRATTRS *pMgrAttrs);
-
-/*
- *  ======== CMM_Destroy ========
- *  Purpose:
- *      Destroy the communication memory manager object.
- *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
- *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
- *                 If FALSE, and outstanding allocations will return DSP_EFAIL
- *                 status.
- *  Returns:
- *      DSP_SOK:        CMM object & resources deleted.
- *      DSP_EFAIL:      Unable to free CMM object due to outstanding allocation.
- *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
- *  Requires:
- *      CMM is initialized.
- *      hCmmMgr != NULL.
- *  Ensures:
- *      Memory resources used by Cmm Mgr are freed.
- */
-	extern DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce);
-
-/*
- *  ======== CMM_Exit ========
- *  Purpose:
- *     Discontinue usage of module. Cleanup CMM module if CMM cRef reaches zero.
- *  Parameters:
- *     n/a
- *  Returns:
- *     n/a
- *  Requires:
- *     CMM is initialized.
- *  Ensures:
- */
-	extern void CMM_Exit();
-
-/*
- *  ======== CMM_FreeBuf ========
- *  Purpose:
- *      Free the given buffer.
- *  Parameters:
- *      hCmmMgr:    Cmm Mgr handle.
- *      pBuf:       Pointer to memory allocated by CMM_CallocBuf().
- *      ulSegId:    SM segment Id used in CMM_Calloc() attrs.
- *                  Set to 0 to use default segment.
- *  Returns:
- *      DSP_SOK
- *      DSP_EFAIL
- *  Requires:
- *      CMM initialized.
- *      pBufPA != NULL
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr,
-				      void *pBufPA, u32 ulSegId);
-
-/*
- *  ======== CMM_GetHandle ========
- *  Purpose:
- *      Return the handle to the cmm mgr for the given device obj.
- *  Parameters:
- *      hProcessor:   Handle to a Processor.
- *      phCmmMgr:     Location to store the shared memory mgr handle on output.
- *
- *  Returns:
- *      DSP_SOK:        Cmm Mgr opaque handle returned.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      phCmmMgr != NULL
- *      hDevObject != NULL
- *  Ensures:
- */
-	extern DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
-					OUT struct CMM_OBJECT **phCmmMgr);
-
-/*
- *  ======== CMM_GetInfo ========
- *  Purpose:
- *      Return the current SM and VM utilization information.
- *  Parameters:
- *      hCmmMgr:     Handle to a Cmm Mgr.
- *      pCmmInfo:    Location to store the Cmm information on output.
- *
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *      DSP_EINVALIDARG Invalid input argument.
- *  Requires:
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
-				      OUT struct CMM_INFO *pCmmInfo);
-
-/*
- *  ======== CMM_Init ========
- *  Purpose:
- *      Initializes private state of CMM module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      CMM initialized.
- */
-	extern bool CMM_Init();
-
-/*
- *  ======== CMM_RegisterGPPSMSeg ========
- *  Purpose:
- *      Register a block of SM with the CMM.
- *  Parameters:
- *      hCmmMgr:         Handle to a Cmm Mgr.
- *      lpGPPBasePA:     GPP Base Physical address.
- *      ulSize:          Size in GPP bytes.
- *      dwDSPAddrOffset  GPP PA to DSP PA Offset.
- *      cFactor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
- *      dwDSPBase:       DSP virtual base byte address.
- *      ulDSPSize:       Size of DSP segment in bytes.
- *      pulSegId:        Address to store segment Id.
- *
- *  Returns:
- *      DSP_SOK:         Success.
- *      DSP_EHANDLE:     Invalid hCmmMgr handle.
- *      DSP_EINVALIDARG: Invalid input argument.
- *      DSP_EFAIL:       Unable to register.
- *      - On success *pulSegId is a valid SM segment ID.
- *  Requires:
- *      ulSize > 0
- *      pulSegId != NULL
- *      dwGPPBasePA != 0
- *      cFactor = CMM_ADDTODSPPA || cFactor = CMM_SUBFROMDSPPA
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-					       unsigned int dwGPPBasePA,
-					       u32 ulSize,
-					       u32 dwDSPAddrOffset,
-					       enum CMM_CNVTTYPE cFactor,
-					       unsigned int dwDSPBase,
-					       u32 ulDSPSize,
-					       u32 *pulSegId,
-					       u32 dwGPPBaseBA);
-
-/*
- *  ======== CMM_UnRegisterGPPSMSeg ========
- *  Purpose:
- *      Unregister the given memory segment that was previously registered
- *      by CMM_RegisterGPPSMSeg.
- *  Parameters:
- *      hCmmMgr:    Handle to a Cmm Mgr.
- *      ulSegId     Segment identifier returned by CMM_RegisterGPPSMSeg.
- *  Returns:
- *       DSP_SOK:         Success.
- *       DSP_EHANDLE:     Invalid handle.
- *       DSP_EINVALIDARG: Invalid ulSegId.
- *       DSP_EFAIL:       Unable to unregister for unknown reason.
- *  Requires:
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-						 u32 ulSegId);
-
-/*
- *  ======== CMM_XlatorAllocBuf ========
- *  Purpose:
- *      Allocate the specified SM buffer and create a local memory descriptor.
- *      Place on the descriptor on the translator's HaQ (Host Alloc'd Queue).
- *  Parameters:
- *      hXlator:    Handle to a Xlator object.
- *      pVaBuf:     Virtual address ptr(client context)
- *      uPaSize:    Size of SM memory to allocate.
- *  Returns:
- *      Ptr to valid physical address(Pa) of uPaSize bytes, NULL if failed.
- *  Requires:
- *      pVaBuf != 0.
- *      uPaSize != 0.
- *  Ensures:
- *
- */
-	extern void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator,
-					void *pVaBuf, u32 uPaSize);
-
-/*
- *  ======== CMM_XlatorCreate ========
- *  Purpose:
- *     Create a translator(xlator) object used for process specific Va<->Pa
- *     address translation. Node messaging and streams use this to perform
- *     inter-processor(GPP<->DSP) zero-copy data transfer.
- *  Parameters:
- *     phXlator:       Address to place handle to a new Xlator handle.
- *     hCmmMgr:        Handle to Cmm Mgr associated with this translator.
- *     pXlatorAttrs:   Translator attributes used for the client NODE or STREAM.
- *  Returns:
- *     DSP_SOK:            Success.
- *     DSP_EINVALIDARG:    Bad input Attrs.
- *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
- *  Requires:
- *     phXlator != NULL
- *     hCmmMgr != NULL
- *     pXlatorAttrs != NULL
- *  Ensures:
- *
- */
-      extern DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
-					 struct CMM_OBJECT *hCmmMgr,
-					 struct CMM_XLATORATTRS *pXlatorAttrs);
-
-/*
- *  ======== CMM_XlatorDelete ========
- *  Purpose:
- *      Delete translator resources
- *  Parameters:
- *      hXlator:    handle to translator.
- *      bForce:     bForce = TRUE will free XLators SM buffers/dscriptrs.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Bad translator handle.
- *      DSP_EFAIL:      Unable to free translator resources.
- *  Requires:
- *      cRefs > 0
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator,
-					   bool bForce);
-
-/*
- *  ======== CMM_XlatorFreeBuf ========
- *  Purpose:
- *      Free SM buffer and descriptor.
- *      Does not free client process VM.
- *  Parameters:
- *      hXlator:    handle to translator.
- *      pBufVa      Virtual address of PA to free.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Bad translator handle.
- *  Requires:
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator,
-					    void *pBufVa);
-
-/*
- *  ======== CMM_XlatorInfo ========
- *  Purpose:
- *      Set/Get process specific "translator" address info.
- *      This is used to perform fast virtaul address translation
- *      for shared memory buffers between the GPP and DSP.
- *  Parameters:
- *     hXlator:     handle to translator.
- *     pAddr:       Virtual base address of segment.
- *     ulSize:      Size in bytes.
- *     uSegId:      Segment identifier of SM segment(s)
- *     bSetInfo     Set xlator fields if TRUE, else return base addr
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Bad translator handle.
- *  Requires:
- *      (cRefs > 0)
- *      (pAddr != NULL)
- *      (ulSize > 0)
- *  Ensures:
- *
- */
-	extern DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator,
-					 IN OUT u8 **pAddr,
-					 u32 ulSize, u32 uSegId,
-					 bool bSetInfo);
-
-/*
- *  ======== CMM_XlatorTranslate ========
- *  Purpose:
- *      Perform address translation VA<->PA for the specified stream or
- *      message shared memory buffer.
- *  Parameters:
- *     hXlator: handle to translator.
- *     pAddr    address of buffer to translate.
- *     xType    Type of address xlation. CMM_PA2VA or CMM_VA2PA.
- *  Returns:
- *     Valid address on success, else NULL.
- *  Requires:
- *      cRefs > 0
- *      pAddr != NULL
- *      xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA)
- *  Ensures:
- *
- */
-	extern void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator,
-					 void *pAddr, enum CMM_XLATETYPE xType);
-
-#endif				/* CMM_ */
--- a/arch/arm/plat-omap/include/bridge/cod.h
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/cod.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== cod.h ========
- *  Description:
- *      Code management module for DSPs. This module provides an interface
- *      interface for loading both static and dynamic code objects onto DSP
- *      systems.
- *
- *  Public Functions:
- *      COD_Close
- *      COD_Create
- *      COD_Delete
- *      COD_Exit
- *      COD_GetBaseLib
- *      COD_GetBaseName
- *      COD_GetLoader
- *      COD_GetSection
- *      COD_GetSymValue
- *      COD_Init
- *      COD_LoadBase
- *      COD_Open
- *      COD_OpenBase
- *      COD_ReadSection
- *      COD_UnloadSection
- *
- *  Note:
- *      Currently, only static loading is supported.
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map: Changed DBL to DBLL
- *! 07-Aug-2002 jeh: Added COD_GetBaseName().
- *! 17-Jul-2002 jeh: Added COD_Open(), COD_Close().
- *! 15-Mar-2002 jeh: Added DBL_Flags param to COD_OpenBase().
- *! 19-Oct-2001 jeh: Added COD_GetBaseLib, COD_GetLoader, (left in
- *!                  COD_LoadSection(), COD_UnloadSection(), since they
- *!                  may be needed for BridgeLite).
- *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
- *! 11-Jan-2001 jeh: Added COD_OpenBase.
- *! 29-Sep-2000 kc:  Added size param to COD_ReadSection for input buffer
- *!                  validation.
- *! 02-Aug-2000 kc:  Added COD_ReadSection.
- *! 04-Sep-1997 gp:  Added CDECL identifier to COD_WRITEFXN (for NT)..
- *! 18-Aug-1997 cr:  Added explicit CDECL identifier.
- *! 28-Oct-1996 gp:  Added COD_GetSection.
- *! 30-Jul-1996 gp:  Added envp[] argument to COD_LoadBase().
- *! 12-Jun-1996 gp:  Moved OUT param first in _Create().  Updated _Create()
- *!                  call to take a ZLFileName.  Moved COD_ processor types
- *!                  to CFG.
- *! 29-May-1996 gp:  Changed WCD_STATUS to DSP_STATUS.  Removed include's.
- *! 07-May-1996 mg:  Created.
- *
- */
-
-#ifndef COD_
-#define COD_
-
-#include <dblldefs.h>
-
-#define COD_MAXPATHLENGTH       255
-#define COD_TRACEBEG            "SYS_PUTCBEG"
-#define COD_TRACEEND            "SYS_PUTCEND"
-#define COD_TRACESECT           "trace"
-#define COD_TRACEBEGOLD         "PUTCBEG"
-#define COD_TRACEENDOLD         "PUTCEND"
-
-#define COD_NOLOAD              DBLL_NOLOAD
-#define COD_SYMB                DBLL_SYMB
-
-/* Flags passed to COD_Open */
-	typedef DBLL_Flags COD_FLAGS;
-
-/* COD code manager handle */
-	struct COD_MANAGER;
-
-/* COD library handle */
-	struct COD_LIBRARYOBJ;
-
-/* COD attributes */
-	 struct COD_ATTRS {
-		u32 ulReserved;
-	} ;
-
-/*
- *  Function prototypes for writing memory to a DSP system, allocating
- *  and freeing DSP memory.
- */
-       typedef u32(*COD_WRITEFXN) (void *pPrivRef, u32 ulDspAddr,
-					     void *pBuf, u32 ulNumBytes,
-					     u32 nMemSpace);
-
-
-/*
- *  ======== COD_Close ========
- *  Purpose:
- *      Close a library opened with COD_Open().
- *  Parameters:
- *      lib             - Library handle returned by COD_Open().
- *  Returns:
- *      None.
- *  Requires:
- *      COD module initialized.
- *      valid lib.
- *  Ensures:
- *
- */
-       extern void COD_Close(struct COD_LIBRARYOBJ *lib);
-
-/*
- *  ======== COD_Create ========
- *  Purpose:
- *      Create an object to manage code on a DSP system. This object can be
- *      used to load an initial program image with arguments that can later
- *      be expanded with dynamically loaded object files.
- *      Symbol table information is managed by this object and can be retrieved
- *      using the COD_GetSymValue() function.
- *  Parameters:
- *      phManager:      created manager object
- *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
- *      attrs:          attributes to be used by this object. A NULL value
- *                      will cause default attrs to be used.
- *  Returns:
- *      DSP_SOK:                Success.
- *      COD_E_NOZLFUNCTIONS:    Could not initialize ZL functions.
- *      COD_E_ZLCREATEFAILED:   ZL_Create failed.
- *      DSP_ENOTIMPL:           attrs was not NULL.  We don't yet support
- *                              non default values of attrs.
- *  Requires:
- *      COD module initialized.
- *      pstrZLFile != NULL
- *  Ensures:
- */
-       extern DSP_STATUS COD_Create(OUT struct COD_MANAGER **phManager,
-				    char *pstrZLFile,
-				    IN OPTIONAL CONST struct COD_ATTRS *attrs);
-
-/*
- *  ======== COD_Delete ========
- *  Purpose:
- *      Delete a code manager object.
- *  Parameters:
- *      hManager:   handle of manager to be deleted
- *  Returns:
- *      None.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *  Ensures:
- */
-       extern void COD_Delete(struct COD_MANAGER *hManager);
-
-/*
- *  ======== COD_Exit ========
- *  Purpose:
- *      Discontinue usage of the COD module.
- *  Parameters:
- *      None.
- *  Returns:
- *      None.
- *  Requires:
- *      COD initialized.
- *  Ensures:
- *      Resources acquired in COD_Init() are freed.
- */
-       extern void COD_Exit();
-
-/*
- *  ======== COD_GetBaseLib ========
- *  Purpose:
- *      Get handle to the base image DBL library.
- *  Parameters:
- *      hManager:   handle of manager to be deleted
- *      plib:       location to store library handle on output.
- *  Returns:
- *      DSP_SOK:    Success.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      plib != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
-					       struct DBLL_LibraryObj **plib);
-
-/*
- *  ======== COD_GetBaseName ========
- *  Purpose:
- *      Get the name of the base image DBL library.
- *  Parameters:
- *      hManager:   handle of manager to be deleted
- *      pszName:    location to store library name on output.
- *      uSize:       size of name buffer.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Buffer too small.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pszName != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager,
-						char *pszName, u32 uSize);
-
-/*
- *  ======== COD_GetEntry ========
- *  Purpose:
- *      Retrieve the entry point of a loaded DSP program image
- *  Parameters:
- *      hManager:   handle of manager to be deleted
- *      pulEntry:   pointer to location for entry point
- *  Returns:
- *      DSP_SOK:       Success.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pulEntry != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager,
-					     u32 *pulEntry);
-
-/*
- *  ======== COD_GetLoader ========
- *  Purpose:
- *      Get handle to the DBL loader.
- *  Parameters:
- *      hManager:   handle of manager to be deleted
- *      phLoader:   location to store loader handle on output.
- *  Returns:
- *      DSP_SOK:    Success.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      phLoader != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-					      struct DBLL_TarObj **phLoader);
-
-/*
- *  ======== COD_GetSection ========
- *  Purpose:
- *      Retrieve the starting address and length of a section in the COFF file
- *      given the section name.
- *  Parameters:
- *      lib         Library handle returned from COD_Open().
- *      pstrSect:   name of the section, with or without leading "."
- *      puAddr:     Location to store address.
- *      puLen:      Location to store length.
- *  Returns:
- *      DSP_SOK:                Success
- *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
- *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pstrSect != NULL;
- *      puAddr != NULL;
- *      puLen != NULL;
- *  Ensures:
- *      DSP_SOK:  *puAddr and *puLen contain the address and length of the
- *                 section.
- *      else:  *puAddr == 0 and *puLen == 0;
- *
- */
-       extern DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib,
-					       IN char *pstrSect,
-					       OUT u32 *puAddr,
-					       OUT u32 *puLen);
-
-/*
- *  ======== COD_GetSymValue ========
- *  Purpose:
- *      Retrieve the value for the specified symbol. The symbol is first
- *      searched for literally and then, if not found, searched for as a
- *      C symbol.
- *  Parameters:
- *      lib:        library handle returned from COD_Open().
- *      pstrSymbol: name of the symbol
- *      value:      value of the symbol
- *  Returns:
- *      DSP_SOK:                Success.
- *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
- *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
- *  Requires:
- *      COD module initialized.
- *      Valid hManager.
- *      pstrSym != NULL.
- *      pulValue != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hManager,
-						IN char *pstrSym,
-						OUT u32 *pulValue);
-
-/*
- *  ======== COD_Init ========
- *  Purpose:
- *      Initialize the COD module's private state.
- *  Parameters:
- *      None.
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public COD functions.
- */
-       extern bool COD_Init();
-
-/*
- *  ======== COD_LoadBase ========
- *  Purpose:
- *      Load the initial program image, optionally with command-line arguments,
- *      on the DSP system managed by the supplied handle. The program to be
- *      loaded must be the first element of the args array and must be a fully
- *      qualified pathname.
- *  Parameters:
- *      hMgr:       manager to load the code with
- *      nArgc:      number of arguments in the args array
- *      args:       array of strings for arguments to DSP program
- *      writeFxn:   board-specific function to write data to DSP system
- *      pArb:       arbitrary pointer to be passed as first arg to writeFxn
- *      envp:       array of environment strings for DSP exec.
- *  Returns:
- *      DSP_SOK:                   Success.
- *      COD_E_OPENFAILED:       Failed to open target code.
- *      COD_E_LOADFAILED:       Failed to load code onto target.
- *  Requires:
- *      COD module initialized.
- *      hMgr is valid.
- *      nArgc > 0.
- *      aArgs != NULL.
- *      aArgs[0] != NULL.
- *      pfnWrite != NULL.
- *  Ensures:
- */
-       extern DSP_STATUS COD_LoadBase(struct COD_MANAGER *hManager,
-					     u32 nArgc, char *aArgs[],
-					     COD_WRITEFXN pfnWrite, void *pArb,
-					     char *envp[]);
-
-
-/*
- *  ======== COD_Open ========
- *  Purpose:
- *      Open a library for reading sections. Does not load or set the base.
- *  Parameters:
- *      hMgr:           manager to load the code with
- *      pszCoffPath:    Coff file to open.
- *      flags:          COD_NOLOAD (don't load symbols) or COD_SYMB (load
- *                      symbols).
- *      pLib:           Handle returned that can be used in calls to COD_Close
- *                      and COD_GetSection.
- *  Returns:
- *      S_OK:                   Success.
- *      COD_E_OPENFAILED:       Failed to open target code.
- *  Requires:
- *      COD module initialized.
- *      hMgr is valid.
- *      flags == COD_NOLOAD || flags == COD_SYMB.
- *      pszCoffPath != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS COD_Open(struct COD_MANAGER *hMgr,
-				   IN char *pszCoffPath,
-				   COD_FLAGS flags,
-				   OUT struct COD_LIBRARYOBJ **pLib);
-
-/*
- *  ======== COD_OpenBase ========
- *  Purpose:
- *      Open base image for reading sections. Does not load the base.
- *  Parameters:
- *      hMgr:           manager to load the code with
- *      pszCoffPath:    Coff file to open.
- *      flags:          Specifies whether to load symbols.
- *  Returns:
- *      DSP_SOK:            Success.
- *      COD_E_OPENFAILED:   Failed to open target code.
- *  Requires:
- *      COD module initialized.
- *      hMgr is valid.
- *      pszCoffPath != NULL.
- *  Ensures:
- */
-extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-				       DBLL_Flags flags);
-
-/*
- *  ======== COD_ReadSection ========
- *  Purpose:
- *      Retrieve the content of a code section given the section name.
- *  Parameters:
- *      hManager    - manager in which to search for the symbol
- *      pstrSect    - name of the section, with or without leading "."
- *      pstrContent - buffer to store content of the section.
- *  Returns:
- *      DSP_SOK: on success, error code on failure
- *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
- *      COD_E_READFAILED: Failed to read content of code section.
- *  Requires:
- *      COD module initialized.
- *      valid hManager.
- *      pstrSect != NULL;
- *      pstrContent != NULL;
- *  Ensures:
- *      DSP_SOK:  *pstrContent stores the content of the named section.
- */
-       extern DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib,
-						IN char *pstrSect,
-						OUT char *pstrContent,
-						IN u32 cContentSize);
-
-
-
-#endif				/* COD_ */
--- a/arch/arm/plat-omap/include/bridge/csl.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/csl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== csl.h ========
- *  Purpose:
- *      Platform independent C Standard library functions.
- *
- *  Public Functions:
- *      CSL_AnsiToWchar
- *      CSL_ByteSwap
- *      CSL_Exit
- *      CSL_Init
- *      CSL_NumToAscii
- *      CSL_Strtok
- *      CSL_Strtokr
- *      CSL_WcharToAnsi
- *
- *! Revision History:
- *! ================
- *! 07-Aug-2002 jeh: Added CSL_Strtokr().
- *! 21-Sep-2001 jeh: Added CSL_Strncmp.
- *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
- *! 19-Nov-2000 kc:  Added CSL_ByteSwap().
- *! 09-Nov-2000 kc:  Added CSL_Strncat.
- *! 29-Oct-1999 kc:  Added CSL_Wstrlen().
- *! 20-Sep-1999 ag:  Added CSL_Wchar2Ansi().
- *! 19-Jan-1998 cr:  Code review cleanup (mostly documentation fixes).
- *! 29-Dec-1997 cr:  Changed CSL_lowercase to CSL_Uppercase, added
- *!                  CSL_AnsiToWchar.
- *! 30-Sep-1997 cr:  Added explicit cdecl descriptors to fxn definitions.
- *! 25-Jun-1997 cr:  Added CSL_strcmp.
- *! 12-Jun-1996 gp:  Created.
- */
-
-#ifndef CSL_
-#define CSL_
-
-#include <host_os.h>
-
-/*
- *  ======== CSL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CSL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CSL initialized.
- *  Ensures:
- *      Resources acquired in CSL_Init() are freed.
- */
-	extern void CSL_Exit();
-
-/*
- *  ======== CSL_Init ========
- *  Purpose:
- *      Initialize the CSL module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CSL functions.
- */
-	extern bool CSL_Init();
-
-/*
- *  ======== CSL_NumToAscii ========
- *  Purpose:
- *      Convert a 1 or 2 digit number to a 2 digit string.
- *  Parameters:
- *      pstrNumber: Buffer to store converted string.
- *      dwNum:      Number to convert.
- *  Returns:
- *  Requires:
- *      pstrNumber must be able to hold at least three characters.
- *  Ensures:
- *      pstrNumber will be null terminated.
- */
-	extern void CSL_NumToAscii(OUT char *pstrNumber, IN u32 dwNum);
-
-
-/*
- *  ======== CSL_Strtok ========
- *  Purpose:
- *      Tokenize a NULL terminated string
- *  Parameters:
- *      ptstrSrc:       pointer to string.
- *      szSeparators:   pointer to a string of seperators
- *  Returns:
- *      char *
- *  Requires:
- *      CSL initialized.
- *      ptstrSrc is a valid string pointer.
- *      szSeparators is a valid string pointer.
- *  Ensures:
- */
-	extern char *CSL_Strtok(IN char *ptstrSrc,
-				IN CONST char *szSeparators);
-
-/*
- *  ======== CSL_Strtokr ========
- *  Purpose:
- *      Re-entrant version of strtok.
- *  Parameters:
- *      pstrSrc:        Pointer to string. May be NULL on subsequent calls.
- *      szSeparators:   Pointer to a string of seperators
- *      ppstrCur:       Location to store start of string for next call to
- *                      to CSL_Strtokr.
- *  Returns:
- *      char * (the token)
- *  Requires:
- *      CSL initialized.
- *      szSeparators != NULL
- *      ppstrCur != NULL
- *  Ensures:
- */
-	extern char *CSL_Strtokr(IN char *pstrSrc,
-				 IN CONST char *szSeparators,
-				 OUT char **ppstrCur);
-
-#endif				/* CSL_ */
--- a/arch/arm/plat-omap/include/bridge/dbc.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbc.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbc.h ========
- *  Purpose:
- *      "Design by Contract" programming macros.
- *
- *  Public Functions:
- *      DBC_Assert
- *      DBC_Require
- *      DBC_Ensure
- *
- *  Notes:
- *      Requires that the GT->ERROR function has been defaulted to a valid
- *      error handler for the given execution environment.
- *
- *      Does not require that GT_init() be called.
- *
- *! Revision History:
- *! ================
- *! 11-Aug-2000 ag: Removed include <std.h>
- *! 22-Apr-1996 gp: Created.
- */
-
-#ifndef DBC_
-#define DBC_
-
-#ifndef GT_TRACE
-#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
-#endif
-
-/* Assertion Macros: */
-#if GT_TRACE
-
-#include <gt.h>
-
-#define DBC_Assert(exp) \
-    if (!(exp)) \
-	printk("%s, line %d: Assertion (" #exp ") failed.\n", \
-	__FILE__, __LINE__)
-#define DBC_Require DBC_Assert	/* Function Precondition.  */
-#define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
-
-#else
-
-#define DBC_Assert(exp)
-#define DBC_Require(exp)
-#define DBC_Ensure(exp)
-
-#endif				/* DEBUG */
-
-#endif				/* DBC_ */
--- a/arch/arm/plat-omap/include/bridge/dbdcddef.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbdcddef.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbdcddef.h ========
- *  Description:
- *      DCD (DSP/BIOS Bridge Configuration Database) constants and types.
- *
- *! Revision History:
- *! ================
- *! 03-Dec-2003 map Moved and renamed DCD_OBJTYPE to DSP_DCDOBJTYPE in dbdefs.h
- *! 05-Dec-2002 map Added DCD_CREATELIBTYPE, DCD_EXECUTELIBTYPE,
- *                        DCD_DELETELIBTYPE
- *! 24-Feb-2003 kc  Updated REG entry names to DspBridge.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *! 05-Aug-2002 jeh Added DCD_REGISTERFXN.
- *! 19-Apr-2002 jeh Added DCD_LIBRARYTYPE to DCD_OBJTYPE, dynamic load
- *!                 properties to DCD_NODEPROPS.
- *! 29-Jul-2001 ag  Added extended procObj.
- *! 13-Feb-2001 kc: Named changed from dcdbsdef.h dbdcddef.h.
- *! 12-Dec-2000 jeh Added DAIS iAlg name to DCD_NODEPROPS.
- *! 30-Oct-2000 kc: Added #defines for DCD_AutoRegister function.
- *! 05-Sep-2000 jeh Added DCD_NODEPROPS.
- *! 12-Aug-2000 kc: Incoroporated the use of types defined in <dspdefs.h>.
- *! 29-Jul-2000 kc: Created.
- */
-
-#ifndef DBDCDDEF_
-#define DBDCDDEF_
-
-#include <dbdefs.h>
-#include <mgrpriv.h>		/* for MGR_PROCESSOREXTINFO */
-
-/*
- *  The following defines are critical elements for the DCD module:
- *
- * - DCD_REGKEY enables DCD functions to locate registered DCD objects.
- * - DCD_REGISTER_SECTION identifies the COFF section where the UUID of
- *   registered DCD objects are stored.
- */
-#define DCD_REGKEY              "Software\\TexasInstruments\\DspBridge\\DCD"
-#define DCD_REGISTER_SECTION    ".dcd_register"
-
-/* DCD Manager Object */
-	struct DCD_MANAGER;
-
-/* DCD Node Properties */
-	struct DCD_NODEPROPS {
-		struct DSP_NDBPROPS ndbProps;
-		u32 uMsgSegid;
-		u32 uMsgNotifyType;
-		char *pstrCreatePhaseFxn;
-		char *pstrDeletePhaseFxn;
-		char *pstrExecutePhaseFxn;
-		char *pstrIAlgName;
-
-		/* Dynamic load properties */
-		u16 usLoadType;	/* Static, dynamic, overlay */
-		u32 ulDataMemSegMask;	/* Data memory requirements */
-		u32 ulCodeMemSegMask;	/* Code memory requirements */
-	} ;
-
-/* DCD Generic Object Type */
-	struct DCD_GENERICOBJ {
-		union dcdObjUnion {
-			struct DCD_NODEPROPS nodeObj;	/* node object. */
-			/* processor object. */
-			struct DSP_PROCESSORINFO procObj;
-			/* extended proc object (private) */
-			struct MGR_PROCESSOREXTINFO extProcObj;
-		} objData;
-	} ;
-
-/* DCD Internal Callback Type */
-       typedef DSP_STATUS(*DCD_REGISTERFXN) (IN struct DSP_UUID *pUuid,
-						IN enum DSP_DCDOBJTYPE objType,
-						IN void *handle);
-
-#endif				/* DBDCDDEF_ */
-
--- a/arch/arm/plat-omap/include/bridge/dbdcd.h
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbdcd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbdcd.h ========
- *  Description:
- *      Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
- *
- *! Revision History
- *! ================
- *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
- *! 24-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
- *!                 DCD implementation.
- *! 05-Aug-2002 jeh Added DCD_GetObjects().
- *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
- *! 22-Apr-2002 jeh Added DCD_GetLibraryName().
- *! 03-Apr-2001 sg  Changed error names to have DCD_E* format.
- *! 13-Feb-2001 kc  Name changed from dcdbs.h to dbdcd.h.
- *! 12-Dec-2000 kc  Added DCD_AutoUnregister.
- *! 09-Nov-2000 kc  Updated usage of DCD_EnumerateObject.
- *! 30-Oct-2000 kc  Added DCD_AutoRegister. Updated error DCD error codes.
- *! 29-Sep-2000 kc  Incorporated code review comments. See
- *!                 /src/reviews/dcd_review.txt.
- *! 26-Jul-2000 kc  Created.
- *!
- */
-
-#ifndef DBDCD_
-#define DBDCD_
-
-#include <dbdcddef.h>
-#include <host_os.h>
-#include <nldrdefs.h>
-
-/*
- *  ======== DCD_AutoRegister ========
- *  Purpose:
- *      This function automatically registers DCD objects specified in a
- *      special COFF section called ".dcd_register"
- *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
- *      pszCoffPath:            Pointer to name of COFF file containing DCD
- *                              objects to be registered.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
- *      DSP_EDCDREADSECT:       Unable to read object code section.
- *      DSP_EDCDLOADBASE:       Unable to load code base.
- *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
- *  Requires:
- *      DCD initialized.
- *  Ensures:
- *  Note:
- *      Due to the DCD database construction, it is essential for a DCD-enabled
- *      COFF file to contain the right COFF sections, especially
- *      ".dcd_register", which is used for auto registration.
- */
-	extern DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-					   IN char *pszCoffPath);
-
-/*
- *  ======== DCD_AutoUnregister ========
- *  Purpose:
- *      This function automatically unregisters DCD objects specified in a
- *      special COFF section called ".dcd_register"
- *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
- *      pszCoffPath:            Pointer to name of COFF file containing
- *                              DCD objects to be unregistered.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
- *      DSP_EDCDREADSECT:       Unable to read object code section.
- *      DSP_EDCDLOADBASE:       Unable to load code base.
- *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
- *  Requires:
- *      DCD initialized.
- *  Ensures:
- *  Note:
- *      Due to the DCD database construction, it is essential for a DCD-enabled
- *      COFF file to contain the right COFF sections, especially
- *      ".dcd_register", which is used for auto unregistration.
- */
-	extern DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-					     IN char *pszCoffPath);
-
-/*
- *  ======== DCD_CreateManager ========
- *  Purpose:
- *      This function creates a DCD module manager.
- *  Parameters:
- *      pszZlDllName:   Pointer to a DLL name string.
- *      phDcdMgr:       A pointer to a DCD manager handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Unable to allocate memory for DCD manager handle.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      DCD initialized.
- *      pszZlDllName is non-NULL.
- *      phDcdMgr is non-NULL.
- *  Ensures:
- *      A DCD manager handle is created.
- */
-	extern DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-					    OUT struct DCD_MANAGER **phDcdMgr);
-
-/*
- *  ======== DCD_DestroyManager ========
- *  Purpose:
- *      This function destroys a DCD module manager.
- *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid DCD manager handle.
- *  Requires:
- *      DCD initialized.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr);
-
-/*
- *  ======== DCD_EnumerateObject ========
- *  Purpose:
- *      This function enumerates currently visible DSP/BIOS Bridge objects
- *      and returns the UUID and type of each enumerated object.
- *  Parameters:
- *      cIndex:             The object enumeration index.
- *      objType:            Type of object to enumerate.
- *      pUuid:              Pointer to a DSP_UUID object.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EFAIL:          Unable to enumerate through the DCD database.
- *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
- *  Requires:
- *      DCD initialized.
- *      pUuid is a valid pointer.
- *  Ensures:
- *  Details:
- *      This function can be used in conjunction with DCD_GetObjectDef to
- *      retrieve object properties.
- */
-	extern DSP_STATUS DCD_EnumerateObject(IN s32 cIndex,
-					      IN enum DSP_DCDOBJTYPE objType,
-					      OUT struct DSP_UUID *pUuid);
-
-/*
- *  ======== DCD_Exit ========
- *  Purpose:
- *      This function cleans up the DCD module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DCD initialized.
- *  Ensures:
- */
-	extern void DCD_Exit();
-
-/*
- *  ======== DCD_GetDepLibs ========
- *  Purpose:
- *      Given the uuid of a library and size of array of uuids, this function
- *      fills the array with the uuids of all dependent libraries of the input
- *      library.
- *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid: Pointer to a DSP_UUID for a library.
- *      numLibs: Size of uuid array (number of library uuids).
- *      pDepLibUuids: Array of dependent library uuids to be filled in.
- *      pPersistentDepLibs: Array indicating if corresponding lib is persistent.
- *      phase: phase to obtain correct input library
- *  Returns:
- *      DSP_SOK: Success.
- *      DSP_EMEMORY: Memory allocation failure.
- *      DSP_EDCDREADSECT: Failure to read section containing library info.
- *      DSP_EFAIL: General failure.
- *  Requires:
- *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
- *      pDepLibUuids != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					 IN struct DSP_UUID *pUuid,
-					 u16 numLibs,
-					 OUT struct DSP_UUID *pDepLibUuids,
-					 OUT bool *pPersistentDepLibs,
-					 IN enum NLDR_PHASE phase);
-
-/*
- *  ======== DCD_GetNumDepLibs ========
- *  Purpose:
- *      Given the uuid of a library, determine its number of dependent
- *      libraries.
- *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID for a library.
- *      pNumLibs:       Size of uuid array (number of library uuids).
- *      pNumPersLibs:   number of persistent dependent library.
- *      phase:          Phase to obtain correct input library
- *  Returns:
- *      DSP_SOK: Success.
- *      DSP_EMEMORY: Memory allocation failure.
- *      DSP_EDCDREADSECT: Failure to read section containing library info.
- *      DSP_EFAIL: General failure.
- *  Requires:
- *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
- *      pNumLibs != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					    IN struct DSP_UUID *pUuid,
-					    OUT u16 *pNumLibs,
-					    OUT u16 *pNumPersLibs,
-					    IN enum NLDR_PHASE phase);
-
-/*
- *  ======== DCD_GetLibraryName ========
- *  Purpose:
- *      This function returns the name of a (dynamic) library for a given
- *      UUID.
- *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID that represents a unique DSP/BIOS
- *                      Bridge object.
- *      pstrLibName: Buffer to hold library name.
- *      pdwSize: Contains buffer size. Set to string size on output.
- *      phase:          Which phase to load
- *      fPhaseSplit:    Are phases in multiple libraries
- *  Returns:
- *      DSP_SOK: Success.
- *      DSP_EFAIL: General failure.
- *  Requires:
- *      DCD initialized.
- *      Valid hDcdMgr.
- *      pstrLibName != NULL.
- *      pUuid != NULL
- *      pdwSize != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-					     IN struct DSP_UUID *pUuid,
-					     IN OUT char *pstrLibName,
-					     IN OUT u32 *pdwSize,
-					     IN enum NLDR_PHASE phase,
-					     OUT bool *fPhaseSplit);
-
-/*
- *  ======== DCD_GetObjectDef ========
- *  Purpose:
- *      This function returns the properties/attributes of a DSP/BIOS Bridge
- *      object.
- *  Parameters:
- *      hDcdMgr:            A DCD manager handle.
- *      pUuid:              Pointer to a DSP_UUID that represents a unique
- *                          DSP/BIOS Bridge object.
- *      objType:            The type of DSP/BIOS Bridge object to be
- *                          referenced (node, processor, etc).
- *      pObjDef:            Pointer to an object definition structure. A
- *                          union of various possible DCD object types.
- *  Returns:
- *      DSP_SOK: Success.
- *      DSP_EDCDPARSESECT:  Unable to parse content of object code section.
- *      DSP_EDCDREADSECT:   Unable to read object code section.
- *      DSP_EDCDGETSECT:    Unable to access object code section.
- *      DSP_EDCDLOADBASE:   Unable to load code base.
- *      DSP_EFAIL:          General failure.
- *      DSP_EHANDLE:        Invalid DCD_HMANAGER handle.
- *  Requires:
- *      DCD initialized.
- *      pObjUuid is non-NULL.
- *      pObjDef is non-NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-					   IN struct DSP_UUID *pObjUuid,
-					   IN enum DSP_DCDOBJTYPE objType,
-					   OUT struct DCD_GENERICOBJ *pObjDef);
-
-/*
- *  ======== DCD_GetObjects ========
- *  Purpose:
- *      This function finds all DCD objects specified in a special
- *      COFF section called ".dcd_register", and for each object,
- *      call a "register" function.  The "register" function may perform
- *      various actions, such as 1) register nodes in the node database, 2)
- *      unregister nodes from the node database, and 3) add overlay nodes.
- *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
- *      pszCoffPath:            Pointer to name of COFF file containing DCD
- *                              objects.
- *      registerFxn:            Callback fxn to be applied on each located
- *                              DCD object.
- *      handle:                 Handle to pass to callback.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EDCDNOAUTOREGISTER: Unable to find .dcd_register section.
- *      DSP_EDCDREADSECT:       Unable to read object code section.
- *      DSP_EDCDLOADBASE:       Unable to load code base.
- *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
- *  Requires:
- *      DCD initialized.
- *  Ensures:
- *  Note:
- *      Due to the DCD database construction, it is essential for a DCD-enabled
- *      COFF file to contain the right COFF sections, especially
- *      ".dcd_register", which is used for auto registration.
- */
-	extern DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr,
-					 IN char *pszCoffPath,
-					 DCD_REGISTERFXN registerFxn,
-					 void *handle);
-
-/*
- *  ======== DCD_Init ========
- *  Purpose:
- *      This function initializes DCD.
- *  Parameters:
- *  Returns:
- *      FALSE:  Initialization failed.
- *      TRUE:   Initialization succeeded.
- *  Requires:
- *  Ensures:
- *      DCD initialized.
- */
-	extern bool DCD_Init();
-
-/*
- *  ======== DCD_RegisterObject ========
- *  Purpose:
- *      This function registers a DSP/BIOS Bridge object in the DCD database.
- *  Parameters:
- *      pUuid:          Pointer to a DSP_UUID that identifies a DSP/BIOS
- *                      Bridge object.
- *      objType:        Type of object.
- *      pszPathName:    Path to the object's COFF file.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to register object.
- *  Requires:
- *      DCD initialized.
- *      pUuid and szPathName are non-NULL values.
- *      objType is a valid type value.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-					     IN enum DSP_DCDOBJTYPE objType,
-					     IN char *pszPathName);
-
-/*
- *  ======== DCD_UnregisterObject ========
- *  Purpose:
- *      This function de-registers a valid DSP/BIOS Bridge object from the DCD
- *      database.
- *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID that identifies a DSP/BIOS Bridge
- *                  object.
- *      objType:    Type of object.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Unable to de-register the specified object.
- *  Requires:
- *      DCD initialized.
- *      pUuid is a non-NULL value.
- *      objType is a valid type value.
- *  Ensures:
- */
-	extern DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
-					       IN enum DSP_DCDOBJTYPE objType);
-
-#endif				/* _DBDCD_H */
--- a/arch/arm/plat-omap/include/bridge/dbdefs.h
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbdefs.h ========
- *  Description:
- *      Global definitions and constants for DSP/BIOS Bridge.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added MAPATTR & ELEM_SIZE for Dynamic Memory Mapping feature
- *! 09-Feb-2004 vp  Added processor ID numbers for DSP and IVA
- *! 06-Feb-2003 kc  Removed DSP_POSTMESSAGE. Updated IsValid*Event macros.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *!                 Removed unused DSP_ENUMLASTNODE define.
- *! 13-Feb-2002 jeh Added uSysStackSize to DSP_NDBPROPS.
- *! 23-Jan-2002 ag  Added #define DSP_SHMSEG0.
- *! 12-Dec-2001 ag  Added DSP_ESTRMMODE error code.
- *! 04-Dec-2001 jeh Added DSP_ENOTCONNECTED error code.
- *! 10-Dec-2001 kc: Modified macros and definitions to disable DSP_POSTMESSAGE.
- *! 01-Nov-2001 jeh Added DSP_EOVERLAYMEMORY.
- *! 18-Oct-2001 ag  Added DSP_STRMMODE type.
- *!                 Added DSP_ENOTSHAREDMEM.
- *! 21-Sep-2001 ag  Added additional error codes.
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 11-May-2001 jeh Changed DSP_NODE_MIN_PRIORITY from 0 to 1. Removed hNode
- *!                 from DSP_NODEINFO.
- *! 02-Apr-2001 sg  Added missing error codes, rearranged codes, switched to
- *!             hex offsets, renamed some codes to match API spec.
- *! 16-Jan-2001 jeh Added DSP_ESYMBOL, DSP_EUUID.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 05-Dec-2000 ag: Added DSP_RMSxxx user available message command codes.
- *! 09-Nov-2000 rr: Added DSP_PROCEESORRESTART define; Removed DSP_PBUFFER.
- *!                 Added DSP_DCD_ENOAUTOREGISTER, DSP_EUSER1-16, DSP_ESTRMFUL
- *!                 Removed DSP_EDONE. Macros's modified.
- *! 23-Oct-2000 jeh Replaced DSP_STREAMSTATECHANGE with DSP_STREAMDONE.
- *! 09-Oct-2000 jeh Updated to version 0.9 DSP Bridge API spec.
- *! 29-Sep-2000 kc  Added error codes for DCD and REG to simplify use of
- *!                 these codes within the RM module.
- *! 27-Sep-2000 jeh Added segid, alignment, uNumBufs to DSP_STREAMATTRIN.
- *! 29-Aug-2000 jeh Added DSP_NODETYPE enum, changed DSP_EALREADYATTACHED to
- *!                 DSP_EALREADYCONNECTED. Changed scStreamConnection[1]
- *!                 to scStreamConnection[16] in DSP_NODEINFO structure.
- *!                 Added DSP_NOTIFICATION, DSP_STRMATTR. PSTRING changed
- *!                 back to TCHAR * and moved to dbtype.h.
- *! 11-Aug-2000 rr: Macros to check valid events and notify masks added.
- *! 09-Aug-2000 rr: Changed PSTRING to *s8
- *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
- *! 20-Jul-2000 rr: Updated to version 0.8
- *! 17-Jul-2000 rr: New PROC states added to the DSP_PROCSTATE.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
-#ifndef DBDEFS_
-#define DBDEFS_
-
-#include <linux/types.h>
-
-#include <dbtype.h>		/* GPP side type definitions           */
-#include <std.h>		/* DSP/BIOS type definitions           */
-#include <rms_sh.h>		/* Types shared between GPP and DSP    */
-
-#define PG_SIZE_4K 4096
-#define PG_MASK(pg_size) (~((pg_size)-1))
-#define PG_ALIGN_LOW(addr, pg_size) ((addr) & PG_MASK(pg_size))
-#define PG_ALIGN_HIGH(addr, pg_size) (((addr)+(pg_size)-1) & PG_MASK(pg_size))
-
-/* API return value and calling convention */
-#define DBAPI                       DSP_STATUS
-
-/* Infinite time value for the uTimeout parameter to DSPStream_Select() */
-#define DSP_FOREVER                 (-1)
-
-/* Maximum length of node name, used in DSP_NDBPROPS */
-#define DSP_MAXNAMELEN              32
-
-/* uNotifyType values for the RegisterNotify() functions. */
-#define DSP_SIGNALEVENT             0x00000001
-
-/* Types of events for processors */
-#define DSP_PROCESSORSTATECHANGE    0x00000001
-#define DSP_PROCESSORATTACH         0x00000002
-#define DSP_PROCESSORDETACH         0x00000004
-#define DSP_PROCESSORRESTART        0x00000008
-
-/* DSP exception events (DSP/BIOS and DSP MMU fault) */
-#define DSP_MMUFAULT                0x00000010
-#define DSP_SYSERROR                0x00000020
-#define DSP_EXCEPTIONABORT          0x00000300
-
-/* IVA exception events (IVA MMU fault) */
-#define IVA_MMUFAULT                0x00000040
-/* Types of events for nodes */
-#define DSP_NODESTATECHANGE         0x00000100
-#define DSP_NODEMESSAGEREADY        0x00000200
-
-/* Types of events for streams */
-#define DSP_STREAMDONE              0x00001000
-#define DSP_STREAMIOCOMPLETION      0x00002000
-
-/* Handle definition representing the GPP node in DSPNode_Connect() calls */
-#define DSP_HGPPNODE                0xFFFFFFFF
-
-/* Node directions used in DSPNode_Connect() */
-#define DSP_TONODE                  1
-#define DSP_FROMNODE                2
-
-/* Define Node Minimum and Maximum Priorities */
-#define DSP_NODE_MIN_PRIORITY       1
-#define DSP_NODE_MAX_PRIORITY       15
-
-/* Pre-Defined Message Command Codes available to user: */
-#define DSP_RMSUSERCODESTART RMS_USER	/* Start of RMS user cmd codes */
-/* end of user codes */
-#define DSP_RMSUSERCODEEND (RMS_USER + RMS_MAXUSERCODES);
-#define DSP_RMSBUFDESC RMS_BUFDESC	/* MSG contains SM buffer description */
-
-/* Shared memory identifier for MEM segment named "SHMSEG0" */
-#define DSP_SHMSEG0     (u32)(-1)
-
-/* Processor ID numbers */
-#define DSP_UNIT    0
-#define IVA_UNIT    1
-
-#define DSPWORD       unsigned char
-#define DSPWORDSIZE     sizeof(DSPWORD)
-
-/* Success & Failure macros  */
-#define DSP_SUCCEEDED(Status)      likely((s32)(Status) >= 0)
-#define DSP_FAILED(Status)         unlikely((s32)(Status) < 0)
-
-/* Power control enumerations */
-#define PROC_PWRCONTROL             0x8070
-
-#define PROC_PWRMGT_ENABLE          (PROC_PWRCONTROL + 0x3)
-#define PROC_PWRMGT_DISABLE         (PROC_PWRCONTROL + 0x4)
-
-/* Bridge Code Version */
-#define BRIDGE_VERSION_CODE         333
-
-#define    MAX_PROFILES     16
-
-/* Types defined for 'Bridge API */
-	typedef u32 DSP_STATUS;	/* API return code type         */
-
-	typedef HANDLE DSP_HNODE;	/* Handle to a DSP Node object  */
-	typedef HANDLE DSP_HPROCESSOR;	/* Handle to a Processor object */
-	typedef HANDLE DSP_HSTREAM;	/* Handle to a Stream object    */
-
-	typedef u32 DSP_PROCFAMILY;	/* Processor family             */
-	typedef u32 DSP_PROCTYPE;	/* Processor type (w/in family) */
-	typedef u32 DSP_RTOSTYPE;	/* Type of DSP RTOS             */
-
-/* Handy Macros */
-#define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
-				    DSP_PROCESSORATTACH | \
-				    DSP_PROCESSORDETACH | \
-				    DSP_PROCESSORRESTART | \
-				    DSP_NODESTATECHANGE | \
-				    DSP_STREAMDONE | \
-				    DSP_STREAMIOCOMPLETION | \
-				    DSP_MMUFAULT | \
-				    DSP_SYSERROR)) && \
-				!((x) & ~(DSP_PROCESSORSTATECHANGE | \
-				    DSP_PROCESSORATTACH | \
-				    DSP_PROCESSORDETACH | \
-				    DSP_PROCESSORRESTART | \
-				    DSP_NODESTATECHANGE | \
-				    DSP_STREAMDONE | \
-				    DSP_STREAMIOCOMPLETION | \
-				    DSP_MMUFAULT | \
-				    DSP_SYSERROR))))
-
-#define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY)) && \
-				!((x) & ~(DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY))))
-
-#define IsValidStrmEvent(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
-				DSP_STREAMIOCOMPLETION)) && \
-				!((x) & ~(DSP_STREAMDONE | \
-				DSP_STREAMIOCOMPLETION))))
-
-#define IsValidNotifyMask(x)   ((x) & DSP_SIGNALEVENT)
-
-/* The Node UUID structure */
-	struct DSP_UUID {
-		u32 ulData1;
-		u16 usData2;
-		u16 usData3;
-		u8 ucData4;
-		u8 ucData5;
-		u8 ucData6[6];
-	};
-
-/* DCD types */
-	enum DSP_DCDOBJTYPE {
-		DSP_DCDNODETYPE,
-		DSP_DCDPROCESSORTYPE,
-		DSP_DCDLIBRARYTYPE,
-		DSP_DCDCREATELIBTYPE,
-		DSP_DCDEXECUTELIBTYPE,
-		DSP_DCDDELETELIBTYPE
-	} ;
-
-/* Processor states */
-	enum DSP_PROCSTATE {
-		PROC_STOPPED,
-		PROC_LOADED,
-		PROC_RUNNING,
-		PROC_ERROR
-	} ;
-
-/* Node types */
-	enum DSP_NODETYPE {
-		NODE_DEVICE,
-		NODE_TASK,
-		NODE_DAISSOCKET,
-		NODE_MESSAGE
-	} ;
-
-/* Node states */
-	enum DSP_NODESTATE {
-		NODE_ALLOCATED,
-		NODE_CREATED,
-		NODE_RUNNING,
-		NODE_PAUSED,
-		NODE_DONE
-	} ;
-
-/* Stream states */
-	enum DSP_STREAMSTATE {
-		STREAM_IDLE,
-		STREAM_READY,
-		STREAM_PENDING,
-		STREAM_DONE
-	} ;
-
-/* Stream connect types */
-	enum DSP_CONNECTTYPE {
-		CONNECTTYPE_NODEOUTPUT,
-		CONNECTTYPE_GPPOUTPUT,
-		CONNECTTYPE_NODEINPUT,
-		CONNECTTYPE_GPPINPUT
-	} ;
-
-/* Stream mode types */
-	enum DSP_STRMMODE {
-		STRMMODE_PROCCOPY, /* Processor(s) copy stream data payloads */
-		STRMMODE_ZEROCOPY, /* Strm buffer ptrs swapped no data copied */
-		STRMMODE_LDMA,	/* Local DMA : OMAP's System-DMA device */
-		STRMMODE_RDMA	/* Remote DMA: OMAP's DSP-DMA device */
-	} ;
-
-/* Resource Types */
-	enum DSP_RESOURCEINFOTYPE {
-		DSP_RESOURCE_DYNDARAM = 0,
-		DSP_RESOURCE_DYNSARAM,
-		DSP_RESOURCE_DYNEXTERNAL,
-		DSP_RESOURCE_DYNSRAM,
-		DSP_RESOURCE_PROCLOAD
-	} ;
-
-/* Memory Segment Types */
-	enum DSP_MEMTYPE {
-		DSP_DYNDARAM = 0,
-		DSP_DYNSARAM,
-		DSP_DYNEXTERNAL,
-		DSP_DYNSRAM
-	} ;
-
-/* Memory Flush Types */
-       enum DSP_FLUSHTYPE {
-		PROC_INVALIDATE_MEM = 0,
-		PROC_WRITEBACK_MEM,
-		PROC_WRITEBACK_INVALIDATE_MEM,
-	} ;
-
-/* Memory Segment Status Values */
-	struct DSP_MEMSTAT {
-		u32 ulSize;
-		u32 ulTotalFreeSize;
-		u32 ulLenMaxFreeBlock;
-		u32 ulNumFreeBlocks;
-		u32 ulNumAllocBlocks;
-	} ;
-
-/* Processor Load information Values */
-	 struct DSP_PROCLOADSTAT {
-		u32 uCurrLoad;
-		u32 uPredictedLoad;
-		u32 uCurrDspFreq;
-		u32 uPredictedFreq;
-	} ;
-
-/* Attributes for STRM connections between nodes */
-	struct DSP_STRMATTR {
-		u32 uSegid;	/* Memory segment on DSP to allocate buffers */
-		u32 uBufsize;	/* Buffer size (DSP words) */
-		u32 uNumBufs;	/* Number of buffers */
-		u32 uAlignment;	/* Buffer alignment */
-		u32 uTimeout;	/* Timeout for blocking STRM calls */
-		enum DSP_STRMMODE lMode;	/* mode of stream when opened */
-		/* DMA chnl id if DSP_STRMMODE is LDMA or RDMA */
-		u32 uDMAChnlId;
-		u32 uDMAPriority;  /* DMA channel priority 0=lowest, >0=high */
-	} ;
-
-/* The DSP_CBDATA structure */
-	struct DSP_CBDATA {
-		u32 cbData;
-		u8 cData[1];
-	} ;
-
-/* The DSP_MSG structure */
-	struct DSP_MSG {
-		u32 dwCmd;
-		u32 dwArg1;
-		u32 dwArg2;
-	} ;
-
-/* The DSP_RESOURCEREQMTS structure for node's resource requirements  */
-	struct DSP_RESOURCEREQMTS {
-		u32 cbStruct;
-		u32 uStaticDataSize;
-		u32 uGlobalDataSize;
-		u32 uProgramMemSize;
-		u32 uWCExecutionTime;
-		u32 uWCPeriod;
-		u32 uWCDeadline;
-		u32 uAvgExectionTime;
-		u32 uMinimumPeriod;
-	} ;
-
-/*
- * The DSP_STREAMCONNECT structure describes a stream connection
- * between two nodes, or between a node and the GPP
- */
-	struct DSP_STREAMCONNECT {
-		u32 cbStruct;
-		enum DSP_CONNECTTYPE lType;
-		u32 uThisNodeStreamIndex;
-		DSP_HNODE hConnectedNode;
-		struct DSP_UUID uiConnectedNodeID;
-		u32 uConnectedNodeStreamIndex;
-	} ;
-
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
-	struct DSP_NODEPROFS {
-		u32 ulHeapSize;
-	} ;
-#endif
-
-/* The DSP_NDBPROPS structure reports the attributes of a node */
-	struct DSP_NDBPROPS {
-		u32 cbStruct;
-		struct DSP_UUID uiNodeID;
-		char acName[DSP_MAXNAMELEN];
-		enum DSP_NODETYPE uNodeType;
-		u32 bCacheOnGPP;
-		struct DSP_RESOURCEREQMTS dspResourceReqmts;
-		s32 iPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uMessageDepth;
-		u32 uNumInputStreams;
-		u32 uNumOutputStreams;
-		u32 uTimeout;
-		u32 uCountProfiles;	/* Number of supported profiles */
-		/* Array of profiles */
-		struct DSP_NODEPROFS aProfiles[MAX_PROFILES];
-		u32 uStackSegName; /* Stack Segment Name */
-	} ;
-
-	/* The DSP_NODEATTRIN structure describes the attributes of a
-	 * node client */
-	struct DSP_NODEATTRIN {
-		u32 cbStruct;
-		s32 iPriority;
-		u32 uTimeout;
-		u32    uProfileID;
-		/* Reserved, for Bridge Internal use only */
-		u32    uHeapSize;
-		void *pGPPVirtAddr; /* Reserved, for Bridge Internal use only */
-	} ;
-
-	/* The DSP_NODEINFO structure is used to retrieve information
-	 * about a node */
-	struct DSP_NODEINFO {
-		u32 cbStruct;
-		struct DSP_NDBPROPS nbNodeDatabaseProps;
-		u32 uExecutionPriority;
-		enum DSP_NODESTATE nsExecutionState;
-		DSP_HNODE hDeviceOwner;
-		u32 uNumberStreams;
-		struct DSP_STREAMCONNECT scStreamConnection[16];
-		u32 uNodeEnv;
-	} ;
-
-	/* The DSP_NODEATTR structure describes the attributes of a node */
-	struct DSP_NODEATTR {
-		u32 cbStruct;
-		struct DSP_NODEATTRIN inNodeAttrIn;
-		u32 uInputs;
-		u32 uOutputs;
-		struct DSP_NODEINFO iNodeInfo;
-	} ;
-
-/*
- *  Notification type: either the name of an opened event, or an event or
- *  window handle.
- */
-	struct DSP_NOTIFICATION {
-		char *psName;
-		HANDLE handle;
-	} ;
-
-/* The DSP_PROCESSORATTRIN structure describes the attributes of a processor */
-	struct DSP_PROCESSORATTRIN{
-		u32 cbStruct;
-		u32 uTimeout;
-	} ;
-
-	enum chipTypes {
-		DSPTYPE_55 = 6,
-		IVA_ARM7 = 0x97,
-		DSPTYPE_64 = 0x99
-	};
-
-/*
- * The DSP_PROCESSORINFO structure describes basic capabilities of a
- * DSP processor
- */
-	struct DSP_PROCESSORINFO {
-		u32 cbStruct;
-		DSP_PROCFAMILY uProcessorFamily;
-		DSP_PROCTYPE uProcessorType;
-		u32 uClockRate;
-		u32 ulInternalMemSize;
-		u32 ulExternalMemSize;
-		u32 uProcessorID;
-		DSP_RTOSTYPE tyRunningRTOS;
-		s32 nNodeMinPriority;
-		s32 nNodeMaxPriority;
-	} ;
-
-/* Error information of last DSP exception signalled to the GPP */
-	struct DSP_ERRORINFO {
-		u32 dwErrMask;
-		u32 dwVal1;
-		u32 dwVal2;
-		u32 dwVal3;
-	} ;
-
-/* The DSP_PROCESSORSTATE structure describes the state of a DSP processor */
-	struct DSP_PROCESSORSTATE {
-		u32 cbStruct;
-		enum DSP_PROCSTATE iState;
-		struct DSP_ERRORINFO errInfo;
-	} ;
-
-/*
- * The DSP_RESOURCEINFO structure is used to retrieve information about a
- * processor's resources
- */
-	struct DSP_RESOURCEINFO {
-		u32 cbStruct;
-		enum DSP_RESOURCEINFOTYPE uResourceType;
-		union {
-			u32 ulResource;
-			struct DSP_MEMSTAT memStat;
-			struct DSP_PROCLOADSTAT procLoadStat;
-		} result;
-	} ;
-
-/*
- * The DSP_STREAMATTRIN structure describes the attributes of a stream,
- * including segment and alignment of data buffers allocated with
- * DSPStream_AllocateBuffers(), if applicable
- */
-	struct DSP_STREAMATTRIN {
-		u32 cbStruct;
-		u32 uTimeout;
-		u32 uSegment;
-		u32 uAlignment;
-		u32 uNumBufs;
-		enum DSP_STRMMODE lMode;
-		u32 uDMAChnlId;
-		u32 uDMAPriority;
-	} ;
-
-/* The DSP_BUFFERATTR structure describes the attributes of a data buffer */
-	struct DSP_BUFFERATTR {
-		u32 cbStruct;
-		u32 uSegment;
-		u32 uAlignment;
-	} ;
-
-/*
- *  The DSP_STREAMINFO structure is used to retrieve information
- *  about a stream.
- */
-	struct DSP_STREAMINFO {
-		u32 cbStruct;
-		u32 uNumberBufsAllowed;
-		u32 uNumberBufsInStream;
-		u32 ulNumberBytes;
-		HANDLE hSyncObjectHandle;
-		enum DSP_STREAMSTATE ssStreamState;
-	} ;
-
-/* DMM MAP attributes
-It is a bit mask with each bit value indicating a specific attribute
-bit 0 - GPP address type (user virtual=0, physical=1)
-bit 1 - MMU Endianism (Big Endian=1, Little Endian=0)
-bit 2 - MMU mixed page attribute (Mixed/ CPUES=1, TLBES =0)
-bit 3 - MMU element size = 8bit (valid only for non mixed page entries)
-bit 4 - MMU element size = 16bit (valid only for non mixed page entries)
-bit 5 - MMU element size = 32bit (valid only for non mixed page entries)
-bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
-*/
-
-/* Types of mapping attributes */
-
-/* MPU address is virtual and needs to be translated to physical addr */
-#define DSP_MAPVIRTUALADDR          0x00000000
-#define DSP_MAPPHYSICALADDR         0x00000001
-
-/* Mapped data is big endian */
-#define DSP_MAPBIGENDIAN            0x00000002
-#define DSP_MAPLITTLEENDIAN         0x00000000
-
-/* Element size is based on DSP r/w access size */
-#define DSP_MAPMIXEDELEMSIZE        0x00000004
-
-/*
- * Element size for MMU mapping (8, 16, 32, or 64 bit)
- * Ignored if DSP_MAPMIXEDELEMSIZE enabled
- */
-#define DSP_MAPELEMSIZE8            0x00000008
-#define DSP_MAPELEMSIZE16           0x00000010
-#define DSP_MAPELEMSIZE32           0x00000020
-#define DSP_MAPELEMSIZE64           0x00000040
-
-#define DSP_MAPVMALLOCADDR         0x00000080
-
-#define GEM_CACHE_LINE_SIZE     128
-#define GEM_L1P_PREFETCH_SIZE   128
-
-#endif				/* DBDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/dbg.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbg.h ========
- *  Purpose:
- *      Provide debugging services for 'Bridge Mini Drivers.
- *
- *  Public Functions:
- *      DBG_Exit
- *      DBG_Init
- *      DBG_Printf
- *      DBG_Trace
- *
- *  Notes:
- *      WMD's must not call DBG_Init or DBG_Exit.
- *
- *! Revision History:
- *! ================
- *! 03-Feb-2000 rr: DBG Levels redefined.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Oct-1997 cr: Added DBG_Printf service.
- *! 29-May-1996 gp: Removed WCD_ prefix.
- *! 15-May-1996 gp: Created.
- */
-
-#ifndef DBG_
-#define DBG_
-#include <host_os.h>
-#include <linux/types.h>
-
-/* Levels of trace debug messages: */
-#define DBG_ENTER   (u8)(0x01)	/* Function entry point. */
-#define DBG_LEVEL1  (u8)(0x02)	/* Display debugging state/varibles */
-#define DBG_LEVEL2  (u8)(0x04)	/* Display debugging state/varibles */
-#define DBG_LEVEL3  (u8)(0x08)	/* Display debugging state/varibles */
-#define DBG_LEVEL4  (u8)(0x10)	/* Display debugging state/varibles */
-#define DBG_LEVEL5  (u8)(0x20)	/* Module Init, Exit */
-#define DBG_LEVEL6  (u8)(0x40)	/* Warn SERVICES Failures */
-#define DBG_LEVEL7  (u8)(0x80)	/* Warn Critical Errors */
-
-#if ((defined DEBUG) || (defined DDSP_DEBUG_PRODUCT)) && GT_TRACE
-
-/*
- *  ======== DBG_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DBG initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void DBG_Exit();
-
-/*
- *  ======== DBG_Init ========
- *  Purpose:
- *      Initializes private state of DBG module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- */
-	extern bool DBG_Init();
-
-/*
- *  ======== DBG_Trace ========
- *  Purpose:
- *      Output a trace message to the debugger, if the given trace level
- *      is unmasked.
- *  Parameters:
- *      bLevel:         Trace level.
- *      pstrFormat:     sprintf-style format string.
- *      ...:            Arguments for format string.
- *  Returns:
- *      DSP_SOK:        Success, or trace level masked.
- *      DSP_EFAIL:      On Error.
- *  Requires:
- *      DBG initialized.
- *  Ensures:
- *      Debug message is printed to debugger output window, if trace level
- *      is unmasked.
- */
-	extern DSP_STATUS DBG_Trace(IN u8 bLevel, IN char *pstrFormat, ...);
-#else
-
-#define DBG_Exit()
-#define DBG_Init() true
-#define DBG_Trace(bLevel, pstrFormat, args...)
-
-#endif	     /* ((defined DEBUG) || (defined DDSP_DEBUG_PRODUCT)) && GT_TRACE */
-
-#endif				/* DBG_ */
--- a/arch/arm/plat-omap/include/bridge/dbldefs.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbldefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbldefs.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
-#ifndef DBLDEFS_
-#define DBLDEFS_
-
-/*
- *  Bit masks for DBL_Flags.
- */
-#define DBL_NOLOAD   0x0	/* Don't load symbols, code, or data */
-#define DBL_SYMB     0x1	/* load symbols */
-#define DBL_CODE     0x2	/* load code */
-#define DBL_DATA     0x4	/* load data */
-#define DBL_DYNAMIC  0x8	/* dynamic load */
-#define DBL_BSS      0x20	/* Unitialized section */
-
-#define DBL_MAXPATHLENGTH       255
-
-
-
-/*
- *  ======== DBL_Flags ========
- *  Specifies whether to load code, data, or symbols
- */
-typedef s32 DBL_Flags;
-
-/*
- *  ======== DBL_SectInfo ========
- *  For collecting info on overlay sections
- */
-struct DBL_SectInfo {
-	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
-	u32 size;		/* size of section (target MAUs) */
-	DBL_Flags type;		/* Code, data, or BSS */
-} ;
-
-/*
- *  ======== DBL_Symbol ========
- *  (Needed for dynamic load library)
- */
-struct DBL_Symbol {
-	u32 value;
-};
-
-/*
- *  ======== DBL_AllocFxn ========
- *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
- *  "size" bytes of memory from segment "space" and return the address in
- *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
- *  success, or an error code on failure.
- */
-typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			u32 *dspAddr, s32 segId, s32 req, bool reserved);
-
-
-
-/*
- *  ======== DBL_FreeFxn ========
- *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
- *  bytes of memory from segment "space"
- */
-typedef bool(*DBL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			    bool reserved);
-
-/*
- *  ======== DBL_LogWriteFxn ========
- *  Function to call when writing data from a section, to log the info.
- *  Can be NULL if no logging is required.
- */
-typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
-				      u32 addr, u32 nBytes);
-
-
-/*
- *  ======== DBL_SymLookup ========
- *  Symbol lookup function - Find the symbol name and return its value.
- *
- *  Parameters:
- *      handle          - Opaque handle
- *      pArg            - Opaque argument.
- *      name            - Name of symbol to lookup.
- *      sym             - Location to store address of symbol structure.
- *
- *  Returns:
- *      TRUE:           Success (symbol was found).
- *      FALSE:          Failed to find symbol.
- */
-typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			      const char *name, struct DBL_Symbol **sym);
-
-
-/*
- *  ======== DBL_WriteFxn ========
- *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
- *  starting at address "dspAddr" from the buffer "buf".  The buffer is
- *  formatted as an array of words appropriate for the DSP.
- */
-typedef s32(*DBL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			    u32 n, s32 mtype);
-
-/*
- *  ======== DBL_Attrs ========
- */
-struct DBL_Attrs {
-	DBL_AllocFxn alloc;
-	DBL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
-
-	DBL_LogWriteFxn logWrite;
-	void *logWriteHandle;
-
-	/* Symbol matching function and handle to pass to it */
-	DBL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
-
-	/*
-	 *  These file manipulation functions should be compatible with the
-	 *  "C" run time library functions of the same name.
-	 */
-	s32(*fread) (void *, size_t, size_t, void *);
-	s32(*fseek) (void *, long, int);
-	s32(*ftell) (void *);
-	s32(*fclose) (void *);
-	void *(*fopen) (const char *, const char *);
-} ;
-
-#endif				/* DBLDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/dbl.h
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbl.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Pass DBL_Symbol pointer to DBL_getAddr, DBL_getCAddr
- *!                     to accomodate dynamic loader library.
- *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
- *! 24-Sep-2001 jeh     Code review changes.
- *! 07-Sep-2001 jeh     Added DBL_LoadSect(), DBL_UnloadSect().
- *! 05-Jun-2001 jeh     Created based on zl.h.
- */
-
-#ifndef DBL_
-#define DBL_
-
-#include <dbdefs.h>
-#include <dbldefs.h>
-
-/*
- *  ======== DBL_close ========
- *  Close library opened with DBL_open.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_close(struct DBL_LibraryObj *lib);
-
-/*
- *  ======== DBL_create ========
- *  Create a target object by specifying the alloc, free, and write
- *  functions for the target.
- *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
- *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
- */
-	extern DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget,
-				     struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_delete ========
- *  Delete target object and free resources for any loaded libraries.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *  Ensures:
- */
-	extern void DBL_delete(struct DBL_TargetObj *target);
-
-/*
- *  ======== DBL_exit ========
- *  Discontinue use of DBL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      cRefs > 0.
- *  Ensures:
- *      cRefs >= 0.
- */
-	extern void DBL_exit(void);
-
-/*
- *  ======== DBL_getAddr ========
- *  Get address of name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
-				struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getAttrs ========
- *  Retrieve the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *      pAttrs          - Location to store attributes on output.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_getAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_getCAddr ========
- *  Get address of "C" name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
-				 struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getEntry ========
- *  Get program entry point.
- *
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      pEntry          - Location to store entry address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry);
-
-/*
- *  ======== DBL_getSect ========
- *  Get address and size of a named section.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name,
-				      u32 *pAddr, u32 *pSize);
-
-/*
- *  ======== DBL_init ========
- *  Initialize DBL module.
- *  Parameters:
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      cRefs >= 0.
- *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
- */
-	extern bool DBL_init(void);
-
-/*
- *  ======== DBL_load ========
- *  Add symbols/code/data defined in file to that already present on
- *  the target.
- *
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      flags           - Specifies whether loading code, data, and/or symbols.
- *      attrs           - May contain write, alloc, and free functions.
- *      pulEntry        - Location to store program entry on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFREAD:     File read failed.
- *      DSP_EFWRITE:    Write to target failed.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
-				   struct DBL_Attrs *attrs, u32 *pEntry);
-
-/*
- *  ======== DBL_loadSect ========
- *  Load a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains write function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *      DSP_EFWRITE:    Write function failed.
- *  Requires:
- *      Valid lib.
- *      sectName != NULL.
- *      attrs != NULL.
- *      attrs->write != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib,
-				       char *sectName,
-				       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_open ========
- *  DBL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBL_load()/DBL_unload().
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      file            - Name of file to open.
- *      flags           - Specifies whether to load symbols now.
- *      pLib            - Location to store library handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
- *      DSP_EFOPEN:         File open failure.
- *      DSP_EFREAD:         File read failure.
- *      DSP_ECORRUPTFILE:   Unable to determine target type.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      file != NULL.
- *      pLib != NULL.
- *      struct DBL_Attrs fopen function non-NULL.
- *  Ensures:
- *      Success:        Valid *pLib.
- *      Failure:        *pLib == NULL.
- */
-	extern DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file,
-				   DBL_Flags flags,
-				   struct DBL_LibraryObj **pLib);
-
-/*
- *  ======== DBL_readSect ========
- *  Read COFF section into a character buffer.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
- *      size            - Buffer size
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section does not exists.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pBuf != NULL.
- *      size != 0.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name,
-				       char *pBuf, u32 size);
-
-/*
- *  ======== DBL_setAttrs ========
- *  Set the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      pAttrs          - New attributes.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_setAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_unload ========
- *  Remove the symbols/code/data corresponding to the library lib.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_unload(struct DBL_LibraryObj *lib,
-			       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_unloadSect ========
- *  Unload a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      sectName != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib,
-					 char *sectName,
-					 struct DBL_Attrs *attrs);
-
-#endif				/* DBL_ */
--- a/arch/arm/plat-omap/include/bridge/dblldefs.h
+++ /dev/null
@@ -1,509 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dblldefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dblldefs.h ========
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map	    Consolidated DBL into DBLL name
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
-#ifndef DBLLDEFS_
-#define DBLLDEFS_
-
-/*
- *  Bit masks for DBL_Flags.
- */
-#define DBLL_NOLOAD   0x0	/* Don't load symbols, code, or data */
-#define DBLL_SYMB     0x1	/* load symbols */
-#define DBLL_CODE     0x2	/* load code */
-#define DBLL_DATA     0x4	/* load data */
-#define DBLL_DYNAMIC  0x8	/* dynamic load */
-#define DBLL_BSS      0x20	/* Unitialized section */
-
-#define DBLL_MAXPATHLENGTH       255
-
-
-/*
- *  ======== DBLL_Target ========
- *
- */
-struct DBLL_TarObj;
-
-/*
- *  ======== DBLL_Flags ========
- *  Specifies whether to load code, data, or symbols
- */
-typedef s32 DBLL_Flags;
-
-/*
- *  ======== DBLL_Library ========
- *
- */
-struct DBLL_LibraryObj;
-
-/*
- *  ======== DBLL_SectInfo ========
- *  For collecting info on overlay sections
- */
-struct DBLL_SectInfo {
-	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
-	u32 size;		/* size of section (target MAUs) */
-	DBLL_Flags type;	/* Code, data, or BSS */
-} ;
-
-/*
- *  ======== DBLL_Symbol ========
- *  (Needed for dynamic load library)
- */
-struct DBLL_Symbol {
-	u32 value;
-};
-
-/*
- *  ======== DBLL_AllocFxn ========
- *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
- *  "size" bytes of memory from segment "space" and return the address in
- *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
- *  success, or an error code on failure.
- */
-typedef s32(*DBLL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			     u32 *dspAddr, s32 segId, s32 req,
-			     bool reserved);
-
-/*
- *  ======== DBLL_CloseFxn ========
- */
-typedef s32(*DBLL_FCloseFxn) (void *);
-
-/*
- *  ======== DBLL_FreeFxn ========
- *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
- *  bytes of memory from segment "space"
- */
-typedef bool(*DBLL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			     bool reserved);
-
-/*
- *  ======== DBLL_FOpenFxn ========
- */
-typedef void *(*DBLL_FOpenFxn) (const char *, const char *);
-
-/*
- *  ======== DBLL_LogWriteFxn ========
- *  Function to call when writing data from a section, to log the info.
- *  Can be NULL if no logging is required.
- */
-typedef DSP_STATUS(*DBLL_LogWriteFxn)(void *handle, struct DBLL_SectInfo *sect,
-				       u32 addr, u32 nBytes);
-
-/*
- *  ======== DBLL_ReadFxn ========
- */
-typedef s32(*DBLL_ReadFxn) (void *, size_t, size_t, void *);
-
-/*
- *  ======== DBLL_SeekFxn ========
- */
-typedef s32(*DBLL_SeekFxn) (void *, long, int);
-
-/*
- *  ======== DBLL_SymLookup ========
- *  Symbol lookup function - Find the symbol name and return its value.
- *
- *  Parameters:
- *      handle          - Opaque handle
- *      pArg            - Opaque argument.
- *      name            - Name of symbol to lookup.
- *      sym             - Location to store address of symbol structure.
- *
- *  Returns:
- *      TRUE:           Success (symbol was found).
- *      FALSE:          Failed to find symbol.
- */
-typedef bool(*DBLL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			       const char *name, struct DBLL_Symbol **sym);
-
-/*
- *  ======== DBLL_TellFxn ========
- */
-typedef s32(*DBLL_TellFxn) (void *);
-
-/*
- *  ======== DBLL_WriteFxn ========
- *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
- *  starting at address "dspAddr" from the buffer "buf".  The buffer is
- *  formatted as an array of words appropriate for the DSP.
- */
-typedef s32(*DBLL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			     u32 n, s32 mtype);
-
-/*
- *  ======== DBLL_Attrs ========
- */
-struct DBLL_Attrs {
-	DBLL_AllocFxn alloc;
-	DBLL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBLL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
-	bool baseImage;
-	DBLL_LogWriteFxn logWrite;
-	void *logWriteHandle;
-
-	/* Symbol matching function and handle to pass to it */
-	DBLL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
-
-	/*
-	 *  These file manipulation functions should be compatible with the
-	 *  "C" run time library functions of the same name.
-	 */
-	 s32(*fread) (void *, size_t, size_t, void *);
-	 s32(*fseek) (void *, long, int);
-	 s32(*ftell) (void *);
-	 s32(*fclose) (void *);
-	void *(*fopen) (const char *, const char *);
-} ;
-
-/*
- *  ======== DBLL_close ========
- *  Close library opened with DBLL_open.
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-typedef void(*DBLL_CloseFxn) (struct DBLL_LibraryObj *library);
-
-/*
- *  ======== DBLL_create ========
- *  Create a target object, specifying the alloc, free, and write functions.
- *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
- *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
- */
-typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
-				    struct DBLL_Attrs *attrs);
-
-/*
- *  ======== DBLL_delete ========
- *  Delete target object and free resources for any loaded libraries.
- *  Parameters:
- *      target          - Handle returned from DBLL_Create().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *  Ensures:
- */
-typedef void(*DBLL_DeleteFxn) (struct DBLL_TarObj *target);
-
-/*
- *  ======== DBLL_exit ========
- *  Discontinue use of DBL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      cRefs > 0.
- *  Ensures:
- *      cRefs >= 0.
- */
-typedef void(*DBLL_ExitFxn) (void);
-
-/*
- *  ======== DBLL_getAddr ========
- *  Get address of name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid library.
- *      name != NULL.
- *      ppSym != NULL.
- *  Ensures:
- */
-typedef bool(*DBLL_GetAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				struct DBLL_Symbol **ppSym);
-
-/*
- *  ======== DBLL_getAttrs ========
- *  Retrieve the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBLL_Create().
- *      pAttrs          - Location to store attributes on output.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
-				 struct DBLL_Attrs *attrs);
-
-/*
- *  ======== DBLL_getCAddr ========
- *  Get address of "C" name on the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      name != NULL.
- *      ppSym != NULL.
- *  Ensures:
- */
-typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
-
-/*
- *  ======== DBLL_getSect ========
- *  Get address and size of a named section.
- *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
- *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBLL_GetSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				      u32 *addr, u32 *size);
-
-/*
- *  ======== DBLL_init ========
- *  Initialize DBL module.
- *  Parameters:
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      cRefs >= 0.
- *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
- */
-typedef bool(*DBLL_InitFxn) (void);
-
-/*
- *  ======== DBLL_load ========
- *  Load library onto the target.
- *
- *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
- *      flags           - Load code, data and/or symbols.
- *      attrs           - May contain alloc, free, and write function.
- *      pulEntry        - Location to store program entry on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFREAD:     File read failed.
- *      DSP_EFWRITE:    Write to target failed.
- *      DSP_EDYNLOAD:   Failure in dynamic loader library.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
-				   DBLL_Flags flags,
-				   struct DBLL_Attrs *attrs, u32 *entry);
-
-/*
- *  ======== DBLL_loadSect ========
- *  Load a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains write function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *      DSP_EFWRITE:    Write function failed.
- *      DSP_ENOTIMPL:   Function not implemented.
- *  Requires:
- *      Valid lib.
- *      sectName != NULL.
- *      attrs != NULL.
- *      attrs->write != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
-				       char *pszSectName,
-				       struct DBLL_Attrs *attrs);
-
-/*
- *  ======== DBLL_open ========
- *  DBLL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBLL_load()/DBLL_unload().
- *  Parameters:
- *      target          - Handle returned from DBLL_create().
- *      file            - Name of file to open.
- *      flags           - If flags & DBLL_SYMB, load symbols.
- *      pLib            - Location to store library handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
- *      DSP_EFOPEN:         File open failure.
- *      DSP_EFREAD:         File read failure.
- *      DSP_ECORRUPTFILE:   Unable to determine target type.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      file != NULL.
- *      pLib != NULL.
- *      DBLL_Attrs fopen function non-NULL.
- *  Ensures:
- *      Success:        Valid *pLib.
- *      Failure:        *pLib == NULL.
- */
-typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
-				   DBLL_Flags flags,
-				   struct DBLL_LibraryObj **pLib);
-
-/*
- *  ======== DBLL_readSect ========
- *  Read COFF section into a character buffer.
- *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
- *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
- *      size            - Buffer size
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section does not exists.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pBuf != NULL.
- *      size != 0.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBLL_ReadSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				       char *content, u32 uContentSize);
-
-/*
- *  ======== DBLL_setAttrs ========
- *  Set the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBLL_create().
- *      pAttrs          - New attributes.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
-				struct DBLL_Attrs *attrs);
-
-/*
- *  ======== DBLL_unload ========
- *  Unload library loaded with DBLL_load().
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
-			       struct DBLL_Attrs *attrs);
-
-/*
- *  ======== DBLL_unloadSect ========
- *  Unload a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBLL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section not found.
- *      DSP_ENOTIMPL
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      sectName != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*DBLL_UnloadSectFxn) (struct DBLL_LibraryObj *lib,
-					 char *pszSectName,
-					 struct DBLL_Attrs *attrs);
-
-struct DBLL_Fxns {
-	DBLL_CloseFxn closeFxn;
-	DBLL_CreateFxn createFxn;
-	DBLL_DeleteFxn deleteFxn;
-	DBLL_ExitFxn exitFxn;
-	DBLL_GetAttrsFxn getAttrsFxn;
-	DBLL_GetAddrFxn getAddrFxn;
-	DBLL_GetCAddrFxn getCAddrFxn;
-	DBLL_GetSectFxn getSectFxn;
-	DBLL_InitFxn initFxn;
-	DBLL_LoadFxn loadFxn;
-	DBLL_LoadSectFxn loadSectFxn;
-	DBLL_OpenFxn openFxn;
-	DBLL_ReadSectFxn readSectFxn;
-	DBLL_SetAttrsFxn setAttrsFxn;
-	DBLL_UnloadFxn unloadFxn;
-	DBLL_UnloadSectFxn unloadSectFxn;
-} ;
-
-#endif				/* DBLDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/dbll.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbll.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbll.h ========
- *  DSP/BIOS Bridge Dynamic load library module interface. Function header
- *  comments are in the file dblldefs.h.
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function comments (now in dblldefs.h).
- *! 17-Apr-2002 jeh     Created based on zl.h.
- */
-
-#ifndef DBLL_
-#define DBLL_
-
-#include <dbdefs.h>
-#include <dblldefs.h>
-
-	extern void DBLL_close(struct DBLL_LibraryObj *lib);
-	extern DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget,
-				      struct DBLL_Attrs *pAttrs);
-	extern void DBLL_delete(struct DBLL_TarObj *target);
-	extern void DBLL_exit(void);
-	extern bool DBLL_getAddr(struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
-	extern void DBLL_getAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern bool DBLL_getCAddr(struct DBLL_LibraryObj *lib, char *name,
-				  struct DBLL_Symbol **ppSym);
-	extern DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name,
-				       u32 *pAddr, u32 *pSize);
-	extern bool DBLL_init(void);
-	extern DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib,
-				    DBLL_Flags flags,
-				    struct DBLL_Attrs *attrs, u32 *pEntry);
-	extern DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *lib,
-					char *sectName,
-					struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file,
-				    DBLL_Flags flags,
-				    struct DBLL_LibraryObj **pLib);
-	extern DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib,
-					char *name,
-					char *pBuf, u32 size);
-	extern void DBLL_setAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern void DBLL_unload(struct DBLL_LibraryObj *lib,
-				struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib,
-					  char *sectName,
-					  struct DBLL_Attrs *attrs);
-
-#endif				/* DBLL_ */
-
--- a/arch/arm/plat-omap/include/bridge/dbof.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbof.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbof.h ========
- *  Description:
- *      Defines and typedefs for DSP/BIOS Bridge Object File Format (DBOF).
- *
- *! Revision History
- *! ================
- *! 12-Jul-2002 jeh     Added defines for DBOF_SectHdr page.
- *! 12-Oct-2001 jeh     Converted to std.h format.
- *! 07-Sep-2001 jeh     Added overlay support.
- *! 06-Jul-2001 jeh     Created.
- */
-
-#ifndef DBOF_
-#define DBOF_
-
-/* Enough to hold DCD section names: 32 digit ID + underscores */
-#define DBOF_DCDSECTNAMELEN     40
-
-/* Values for DBOF_SectHdr page field. */
-#define         DBOF_PROGRAM    0
-#define         DBOF_DATA       1
-#define         DBOF_CINIT      2
-
-/*
- *  ======== DBOF_FileHdr ========
- */
-	struct DBOF_FileHdr {
-		u32 magic;	/* COFF magic number */
-		u32 entry;	/* Program entry point */
-		u16 numSymbols;	/* Number of bridge symbols */
-		u16 numDCDSects;	/* Number of DCD sections */
-		u16 numSects;	/* Number of sections to load */
-		u16 numOvlySects;	/* Number of overlay sections */
-		u32 symOffset;	/* Offset in file to symbols */
-		u32 dcdSectOffset;	/* Offset to DCD sections */
-		u32 loadSectOffset;	/* Offset to loadable sections */
-		u32 ovlySectOffset;	/* Offset to overlay data */
-		u16 version;	/* DBOF version number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_DCDSectHdr ========
- */
-	struct DBOF_DCDSectHdr {
-		u32 size;	/* Sect size (target MAUs) */
-		char name[DBOF_DCDSECTNAMELEN];	/* DCD section name */
-	} ;
-
-/*
- *  ======== DBOF_OvlySectHdr ========
- */
-	struct DBOF_OvlySectHdr {
-		u16 nameLen;	/* Length of section name */
-		u16 numCreateSects;	/* # of sects loaded for create phase */
-		u16 numDeleteSects;	/* # of sects loaded for delete phase */
-		u16 numExecuteSects; /* # of sects loaded for execute phase */
-
-		/*
-		 *  Number of sections where load/unload phase is not specified.
-		 *  These sections will be loaded when create phase sects are
-		 *  loaded, and unloaded when the delete phase is unloaded.
-		 */
-		u16 numOtherSects;
-		u16 resvd;	/* Reserved for future use */
-	};
-
-/*
- *  ======== DBOF_OvlySectData ========
- */
-	struct DBOF_OvlySectData {
-		u32 loadAddr;	/* Section load address */
-		u32 runAddr;	/* Section run address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Memory page number */
-		u16 resvd;	/* Reserved */
-	} ;
-
-/*
- *  ======== DBOF_SectHdr ========
- */
-	struct DBOF_SectHdr {
-		u32 addr;	/* Section address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Page number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_SymbolHdr ========
- */
-	struct DBOF_SymbolHdr {
-		u32 value;	/* Symbol value */
-		u16 nameLen;	/* Length of symbol name */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-#endif				/* DBOF_ */
-
--- a/arch/arm/plat-omap/include/bridge/dbreg.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbreg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbreg.h ========
- *  Purpose:
- *      Registry keys for use in Linux.  This is the clearinghouse for
- *      registry definitions, hopefully eliminating overlapping between
- *      modules.
- *
- *! Revision History:
- *! ================
- *! 10-Apr-2003 vp:  Added macro for subkey TCWORDSWAP.
- *! 21-Mar-2003 sb:  Added macro for subkey SHMSize
- *! 27-Aug-2001 jeh  Added WSXREG_LOADERFILENAME.
- *! 13-Feb-2001 kc:  DSP/BIOS Bridge name updates.
- *! 29-Nov-2000 rr:  Added WSXREG_DSPTYPE_55 as 6.
- *! 06-Sep-2000 jeh: Added WSXREG_CHNLOFFSET, WSXREG_NUMCHNLS,
- *!                  WSXREG_CHNLBUFSIZE.
- *! 26-Aug-2000 rr:  MEMBASE expanded to 9 entries.
- *! 26-Jul-2000 rr:  Added WSXREG_DCDNAME for the DCD Dll name. It will
- *!                  live under WSXREG_WINSPOXCONFIG.
- *! 17-Jul-2000 rr:  REG_MGR_OBJECT and REG_DRV_OBJECT defined. They
- *!                  are stored in the Registrty under WSXREG_WINSPOXCONFIG
- *!                  when they are created in DSP_Init. WSXREG_DEVOBJECT
- *!                  and WSXREG_MGROBJECT defined.
- *! 11-Dec-1999 ag:  Renamed Isa to IsaBus due to conflict with ceddk.h.
- *! 12-Nov-1999 rr:  New Registry Defnitions.
- *! 15-Oct-1999 rr:  New entry for DevObject created. WSXREG_DEVOBJECT
- *!                  under WSXREG_DDSPDRIVERPATH
- *! 10-Nov-1997 cr:  Added WSXREG_INFPATH, WSXREG_WINDEVICEPATH,
- *!                  WSXREG_WINCURVERSION
- *! 21-Oct-1997 cr:  Added WSXREG_BUSTYPE.
- *! 08-Sep-1997 cr:  Added WSXREG_SERVICES, WSXREG_SERVICENAME and
- *!                  WSXREG_CLASSINDEX.
- *! 30-Aug-1997 cr:  Added WSXREG_SOFTWAREPATHNT & WSXREG_WBCLASSGUID.
- *! 24-Mar-1997 gp:  Added MAXCHIPINFOSUBKEY def.
- *! 18-Feb-1997 cr:  Changed Version1.1 -> Version1.0
- *! 12-Feb-1997 cr:  Changed WinSPOX -> WinBRIDGE.
- *! 11-Dec-1996 gp:  Added Perf key name in WinSPOX Config.
- *! 22-Jul-1996 gp:  Added Trace key name.
- *! 30-May-1996 cr:  Created.
- */
-
-#ifndef DBREG_
-#define DBREG_ 1	/* Defined as "1" so InstallShield programs compile. */
-
-#define REG_MGR_OBJECT      1
-#define REG_DRV_OBJECT      2
-/* general registry definitions */
-#define MAXREGPATHLENGTH    255	/* Max registry path length. Also the
-				   max registry value length. */
-#define DSPTYPE_55          6	/* This is the DSP Chip type for 55 */
-#define DSPTYPE_64          0x99
-#define IVA_ARM7            0x97    /* This is the DSP Chip type for IVA/ARM7 */
-
-#define DSPPROCTYPE_C55		5510
-#define DSPPROCTYPE_C64		6410
-#define IVAPROCTYPE_ARM7	470
-/* registry */
-#define DEVNODESTRING    "DevNode"	/* u32 devnode */
-#define CONFIG           "Software\\TexasInstruments\\DirectDSP\\Config"
-#define DRVOBJECT        "DrvObject"
-#define MGROBJECT        "MgrObject"
-#define CLASS            "Device"	/*  device class */
-#define TRACE            "Trace"	/* GT Trace settings.  */
-#define PERFR            "Perf"	/* Enable perf bool.  */
-#define ROOT             "Root"	/*  root dir */
-
-/* MiniDriver related definitions */
-/* The following definitions are under "Drivers\\DirectDSP\\Device\\XXX "
- * Where XXX is the device or board name */
-
-#define WMDFILENAME      "MiniDriver"	/* WMD entry name */
-#define CHIPTYPE         "ChipType"	/* Chip type */
-#define CHIPNUM          "NumChips"	/* Number of chips */
-#define NUMPROCS         "NumOfProcessors"	/* Number of processors */
-#define DEFEXEC          "DefaultExecutable"	/* Default executable */
-#define AUTOSTART        "AutoStart"	/* Statically load flag */
-#define IVAAUTOSTART     "IvaAutoStart"	/* Statically load flag */
-#define BOARDNAME        "BoardName"	/* Name of the Board */
-#define UNITNUMBER       "UnitNumber"	/* Unit # of the Board */
-#define BUSTYPE          "BusType"	/* Bus type board is on */
-#define BUSNUMBER        "BusNumber"	/* Bus number board is on */
-#define CURRENTCONFIG    "CurrentConfig"	/* Current resources */
-#define PCIVENDEVID      "VendorDeviceId"	/* The board's id */
-#define INFPATH          "InfPath"	/* wmd's inf filename */
-#define DEVOBJECT        "DevObject"
-#define ZLFILENAME       "ZLFileName"	/* Name of ZL file */
-#define WORDSIZE         "WordSize"	/* NumBytes in DSP Word */
-#define SHMSIZE          "SHMSize"	/* Size of SHM reservd on MPU */
-#define IVAEXTMEMSIZE    "IVAEXTMEMSize"	/* IVA External Memeory size  */
-#define TCWORDSWAP       "TCWordSwap"	/* Traffic Contoller Word Swap */
-#define DSPRESOURCES     "DspTMSResources"	/* C55 DSP resurces on OMAP */
-#define IVA1RESOURCES    "ARM7IvaResources"	/* ARM7 IVA resurces on OMAP */
-#define PHYSMEMPOOLBASE  "PhysicalMemBase"   /* Physical mem passed to driver */
-#define PHYSMEMPOOLSIZE  "PhysicalMemSize"   /* Physical mem passed to driver */
-
-#endif				/* DBREG_ */
--- a/arch/arm/plat-omap/include/bridge/dbtype.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dbtype.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbtype.h ========
- *  Description:
- *      This header defines data types for DSP/BIOS Bridge APIs and device
- *      driver modules. It also defines the Hungarian
- *      prefix to use for each base type.
- *
- *
- *! Revision History:
- *! =================
- *! 23-Nov-2002 gp: Purpose -> Description in file header.
- *! 13-Feb-2001 kc: Name changed from ddsptype.h dbtype.h.
- *! 09-Oct-2000 jeh Added CHARACTER.
- *! 11-Aug-2000 ag: Added 'typedef void void'.
- *! 08-Apr-2000 ww: Cloned.
- */
-
-#ifndef DBTYPE_
-#define DBTYPE_
-
-/*============================================================================*/
-/*  Argument specification syntax                                             */
-/*============================================================================*/
-
-#ifndef IN
-#define IN			/* Following parameter is for input. */
-#endif
-
-#ifndef OUT
-#define OUT			/* Following parameter is for output. */
-#endif
-
-#ifndef OPTIONAL
-#define OPTIONAL	  /* Function may optionally use previous parameter. */
-#endif
-
-#ifndef CONST
-#define CONST   const
-#endif
-
-/*============================================================================*/
-/*  Boolean constants                                                         */
-/*============================================================================*/
-
-#ifndef FALSE
-#define FALSE   0
-#endif
-#ifndef TRUE
-#define TRUE    1
-#endif
-
-/*============================================================================*/
-/*  NULL    (Definition is language specific)                                 */
-/*============================================================================*/
-
-#ifndef NULL
-#define NULL    ((void *)0)	/* Null pointer. */
-#endif
-
-/*============================================================================*/
-/*  NULL character   (normally used for string termination)                   */
-/*============================================================================*/
-
-#ifndef NULL_CHAR
-#define NULL_CHAR    '\0'	/* Null character. */
-#endif
-
-/*============================================================================*/
-/*  Basic Type definitions (with Prefixes for Hungarian notation)             */
-/*============================================================================*/
-
-#ifndef OMAPBRIDGE_TYPES
-#define OMAPBRIDGE_TYPES
-typedef volatile unsigned short REG_UWORD16;
-#endif
-
-typedef void *HANDLE;		/* h    */
-
-#define TEXT(x) x
-
-#define DLLIMPORT
-#define DLLEXPORT
-
-/* Define DSPAPIDLL correctly in dspapi.h */
-#define _DSPSYSDLL32_
-
-#endif				/* DBTYPE_ */
--- a/arch/arm/plat-omap/include/bridge/_dcd.h
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/_dcd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== _dcd.h ========
- *  Description:
- *      Includes the wrapper functions called directly by the
- *      DeviceIOControl interface.
- *
- *  Public Functions:
- *      WCD_CallDevIOCtl
- *      WCD_Init
- *      WCD_InitComplete2
- *      WCD_Exit
- *      <MOD>WRAP_*
- *
- *  Notes:
- *      Compiled with CDECL calling convention.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 30-Jan-2002 ag  Renamed CMMWRAP_AllocBuf to CMMWRAP_CallocBuf.
- *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data to acquire PERF stats.
- *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
- *!                 NODEWRAP_GetMessageStream.
- *! 10-Oct-2000 ag: Added user CMM wrappers.
- *! 04-Aug-2000 rr: MEMWRAP and UTIL_Wrap added.
- *! 27-Jul-2000 rr: NODEWRAP, STRMWRAP added.
- *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
- *! 03-Dec-1999 rr: WCD_InitComplete2 enabled for BRD_AutoStart.
- *! 09-Nov-1999 kc: Added MEMRY.
- *! 02-Nov-1999 ag: Added CHNL.
- *! 08-Oct-1999 rr: Utilwrap_Testdll fxn added
- *! 24-Sep-1999 rr: header changed from _wcd.h to _dcd.h
- *! 09-Sep-1997 gp: Created.
- */
-
-#ifndef _WCD_
-#define _WCD_
-
-#include <wcdioctl.h>
-
-/*
- *  ======== WCD_CallDevIOCtl ========
- *  Purpose:
- *      Call the (wrapper) function for the corresponding WCD IOCTL.
- *  Parameters:
- *      cmd:        IOCTL id, base 0.
- *      args:       Argument structure.
- *      pResult:
- *  Returns:
- *      DSP_SOK if command called; DSP_EINVALIDARG if command not in IOCTL
- *      table.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
-					   union Trapped_Args *args,
-					   u32 *pResult);
-
-/*
- *  ======== WCD_Init ========
- *  Purpose:
- *      Initialize WCD modules, and export WCD services to WMD's.
- *      This procedure is called when the class driver is loaded.
- *  Parameters:
- *  Returns:
- *      TRUE if success; FALSE otherwise.
- *  Requires:
- *  Ensures:
- */
-	extern bool WCD_Init();
-
-/*
- *  ======== WCD_InitComplete2 ========
- *  Purpose:
- *      Perform any required WCD, and WMD initialization which
- *      cannot not be performed in WCD_Init() or DEV_StartDevice() due
- *      to the fact that some services are not yet
- *      completely initialized.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:        Allow this device to load
- *      DSP_EFAIL:      Failure.
- *  Requires:
- *      WCD initialized.
- *  Ensures:
- */
-	extern DSP_STATUS WCD_InitComplete2();
-
-/*
- *  ======== WCD_Exit ========
- *  Purpose:
- *      Exit all modules initialized in WCD_Init().
- *      This procedure is called when the class driver is unloaded.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      WCD_Init() was previously called.
- *  Ensures:
- *      Resources acquired in WCD_Init() are freed.
- */
-	extern void WCD_Exit();
-
-/* MGR wrapper functions */
-	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args);
-	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args);
-	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args);
-	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args);
-	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args);
-
-#ifndef RES_CLEANUP_DISABLE
-	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args);
-#endif
-
-
-/* CPRC (Processor) wrapper Functions */
-	extern u32 PROCWRAP_Attach(union Trapped_Args *args);
-	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args);
-	extern u32 PROCWRAP_Detach(union Trapped_Args *args);
-	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args);
-	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args);
-	extern u32 PROCWRAP_GetState(union Trapped_Args *args);
-	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args);
-	extern u32 PROCWRAP_Load(union Trapped_Args *args);
-	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 PROCWRAP_Start(union Trapped_Args *args);
-	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_Map(union Trapped_Args *args);
-	extern u32 PROCWRAP_UnMap(union Trapped_Args *args);
-	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_Stop(union Trapped_Args *args);
-	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args);
-
-/* NODE wrapper functions */
-	extern u32 NODEWRAP_Allocate(union Trapped_Args *args);
-	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args);
-	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args);
-	extern u32 NODEWRAP_Connect(union Trapped_Args *args);
-	extern u32 NODEWRAP_Create(union Trapped_Args *args);
-	extern u32 NODEWRAP_Delete(union Trapped_Args *args);
-	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args);
-	extern u32 NODEWRAP_Pause(union Trapped_Args *args);
-	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args);
-	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 NODEWRAP_Run(union Trapped_Args *args);
-	extern u32 NODEWRAP_Terminate(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args);
-
-/* STRM wrapper functions */
-	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args);
-	extern u32 STRMWRAP_Close(union Trapped_Args *args);
-	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args);
-	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args);
-	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args);
-	extern u32 STRMWRAP_Idle(union Trapped_Args *args);
-	extern u32 STRMWRAP_Issue(union Trapped_Args *args);
-	extern u32 STRMWRAP_Open(union Trapped_Args *args);
-	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args);
-	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 STRMWRAP_Select(union Trapped_Args *args);
-
-	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args);
-	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args);
-	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args);
-	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args);
-
-#endif				/* _WCD_ */
--- a/arch/arm/plat-omap/include/bridge/dehdefs.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dehdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dehdefs.h ========
- *  Purpose:
- *      Definition for mini-driver module DEH.
- *
- *! Revision History:
- *! ================
- *! 17-Dec-2001 ag: added #include <mbx_sh.h> for shared mailbox codes.
- *! 10-Dec-2001 kc: added DEH error base value and error max value.
- *! 11-Sep-2001 kc: created.
- */
-
-#ifndef DEHDEFS_
-#define DEHDEFS_
-
-#include <mbx_sh.h>		/* shared mailbox codes */
-
-/* DEH object manager */
-	struct DEH_MGR;
-
-/* Magic code used to determine if DSP signaled exception. */
-#define DEH_BASE        MBX_DEH_BASE
-#define DEH_USERS_BASE  MBX_DEH_USERS_BASE
-#define DEH_LIMIT       MBX_DEH_LIMIT
-
-#endif				/* _DEHDEFS_H */
--- a/arch/arm/plat-omap/include/bridge/devdefs.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/devdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== devdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and dev.h. Required
- *      to break circular dependency between WMD and DEV include files.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-1996 gp: Renamed from dev1.h.
- *! 30-May-1996 gp: Broke out from dev.h
- */
-
-#ifndef DEVDEFS_
-#define DEVDEFS_
-
-/* WCD Device Object */
-	struct DEV_OBJECT;
-
-#endif				/* DEVDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/dev.h
+++ /dev/null
@@ -1,785 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dev.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dev.h ========
- *  Description:
- *      'Bridge Mini-driver device operations.
- *
- *  Public Functions:
- *      DEV_BrdWriteFxn
- *      DEV_CreateDevice
- *      DEV_Create2
- *      DEV_Destroy2
- *      DEV_DestroyDevice
- *      DEV_GetChnlMgr
- *      DEV_GetCmmMgr
- *      DEV_GetCodMgr
- *      DEV_GetDehMgr
- *      DEV_GetDevNode
- *      DEV_GetDSPWordSize
- *      DEV_GetFirst
- *      DEV_GetIntfFxns
- *      DEV_GetIOMgr
- *      DEV_GetMsgMgr
- *      DEV_GetNext
- *      DEV_GetNodeManager
- *      DEV_GetSymbol
- *      DEV_GetWMDContext
- *      DEV_Exit
- *      DEV_Init
- *      DEV_InsertProcObject
- *      DEV_IsLocked
- *      DEV_NotifyClient
- *      DEV_RegisterNotify
- *      DEV_ReleaseCodMgr
- *      DEV_RemoveDevice
- *      DEV_RemoveProcObject
- *      DEV_SetChnlMgr
- *      DEV_SetMsgMgr
- *      DEV_SetLockOwner
- *      DEV_StartDevice
- *
- *! Revision History:
- *! ================
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature - Dev_GetDmmMgr
- *! 09-Feb-2004 vp  Added functions required for IVA
- *! 25-Feb-2003 swa PMGR Code Review changes incorporated
- *! 05-Nov-2001 kc: Added DEV_GetDehMgr.
- *! 05-Dec-2000 jeh Added DEV_SetMsgMgr.
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 17-Nov-2000 jeh Added DEV_GetMsgMgr.
- *! 05-Oct-2000 rr: DEV_Create2 & DEV_Destroy2 Added.
- *! 02-Oct-2000 rr: Added DEV_GetNodeManager.
- *! 11-Aug-2000 ag: Added DEV_GetCmmMgr() for shared memory management.
- *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
- *! 06-Jun-2000 jeh Added DEV_GetSymbol().
- *! 05-Nov-1999 kc: Updated function prototypes.
- *! 08-Oct-1997 cr: Added explicit CDECL function identifiers.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 22-Oct-1996 gp: Added DEV_CleanupProcessState().
- *! 29-May-1996 gp: Changed DEV_HDEVNODE --> CFG_HDEVNODE.
- *! 18-May-1996 gp: Created.
- */
-
-#ifndef DEV_
-#define DEV_
-
-/*  ----------------------------------- Module Dependent Headers */
-#include <chnldefs.h>
-#include <cmm.h>
-#include <cod.h>
-#include <dehdefs.h>
-#include <nodedefs.h>
-#include <dispdefs.h>
-#include <wmd.h>
-#include <dmm.h>
-#include <host_os.h>
-
-/*  ----------------------------------- This */
-#include <devdefs.h>
-
-
-/*
- *  ======== DEV_BrdWriteFxn ========
- *  Purpose:
- *      Exported function to be used as the COD write function.  This function
- *      is passed a handle to a DEV_hObject by ZL in pArb, then calls the
- *      device's WMD_BRD_Write() function.
- *  Parameters:
- *      pArb:           Handle to a Device Object.
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP to which to transfer.
- *  Returns:
- *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via
- *      pArb is invalid.
- *  Requires:
- *      DEV Initialized.
- *      pHostBuf != NULL
- *  Ensures:
- */
-       extern u32 DEV_BrdWriteFxn(void *pArb,
-					   u32 ulDspAddr,
-					   void *pHostBuf,
-					   u32 ulNumBytes, u32 nMemSpace);
-
-/*
- *  ======== DEV_CreateDevice ========
- *  Purpose:
- *      Called by the operating system to load the 'Bridge Mini Driver for a
- *      'Bridge device.
- *  Parameters:
- *      phDevObject:    Ptr to location to receive the device object handle.
- *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
- *                      path is not provided, the file is loaded through
- *                      'Bridge's module search path.
- *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
- *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
- *  Returns:
- *      DSP_SOK:            Module is loaded, device object has been created
- *      DSP_EMEMORY:        Insufficient memory to create needed resources.
- *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
- *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
- *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
- *      LDR_E_NOMEMORY:         PELDR is out of resources.
- *      DSP_EFAIL:              Unable to find WMD entry point function.
- *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
- *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
- *  Requires:
- *      DEV Initialized.
- *      phDevObject != NULL.
- *      pstrWMDFileName != NULL.
- *      pHostConfig != NULL.
- *      pDspConfig != NULL.
- *  Ensures:
- *      DSP_SOK:  *phDevObject will contain handle to the new device object.
- *      Otherwise, does not create the device object, ensures the WMD module is
- *      unloaded, and sets *phDevObject to NULL.
- */
-       extern DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT
-						 **phDevObject,
-						 IN CONST char *pstrWMDFileName,
-						 IN CONST struct CFG_HOSTRES
-						 *pHostConfig,
-						 IN CONST struct CFG_DSPRES
-						 *pDspConfig,
-						 struct CFG_DEVNODE *hDevNode);
-
-/*
- *  ======== DEV_CreateIVADevice ========
- *  Purpose:
- *      Called by the operating system to load the 'Bridge Mini Driver for IVA.
- *  Parameters:
- *      phDevObject:    Ptr to location to receive the device object handle.
- *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
- *                      path is not provided, the file is loaded through
- *                      'Bridge's module search path.
- *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
- *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
- *  Returns:
- *      DSP_SOK:            Module is loaded, device object has been created
- *      DSP_EMEMORY:        Insufficient memory to create needed resources.
- *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
- *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
- *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
- *      LDR_E_NOMEMORY:         PELDR is out of resources.
- *      DSP_EFAIL:              Unable to find WMD entry point function.
- *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
- *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
- *  Requires:
- *      DEV Initialized.
- *      phDevObject != NULL.
- *      pstrWMDFileName != NULL.
- *      pHostConfig != NULL.
- *      pDspConfig != NULL.
- *  Ensures:
- *      DSP_SOK:  *phDevObject will contain handle to the new device object.
- *      Otherwise, does not create the device object, ensures the WMD module is
- *      unloaded, and sets *phDevObject to NULL.
- */
-       extern DSP_STATUS DEV_CreateIVADevice(OUT struct DEV_OBJECT
-				**phDevObject,
-				IN CONST char *pstrWMDFileName,
-				IN CONST struct CFG_HOSTRES *pHostConfig,
-				IN CONST struct CFG_DSPRES *pDspConfig,
-				struct CFG_DEVNODE *hDevNode);
-
-/*
- *  ======== DEV_Create2 ========
- *  Purpose:
- *      After successful loading of the image from WCD_InitComplete2
- *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
- *      the Node Manager and updates the DEV Object.
- *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *  Returns:
- *      DSP_SOK:    Successful Creation of Node Manager
- *      DSP_EFAIL:  Some Error Occurred.
- *  Requires:
- *      DEV Initialized
- *      Valid hDevObject
- *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr != NULL
- *      else    hDevObject->hNodeMgr == NULL
- */
-       extern DSP_STATUS DEV_Create2(IN struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== DEV_Destroy2 ========
- *  Purpose:
- *      Destroys the Node manager for this device.
- *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *  Returns:
- *      DSP_SOK:    Successful Creation of Node Manager
- *      DSP_EFAIL:  Some Error Occurred.
- *  Requires:
- *      DEV Initialized
- *      Valid hDevObject
- *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr == NULL
- *      else    DSP_EFAIL.
- */
-       extern DSP_STATUS DEV_Destroy2(IN struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== DEV_DestroyDevice ========
- *  Purpose:
- *      Destroys the channel manager for this device, if any, calls
- *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *      DSP_EFAIL:      The WMD failed it's WMD_DEV_Destroy() function.
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- */
-       extern DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT
-						  *hDevObject);
-
-/*
- *  ======== DEV_GetChnlMgr ========
- *  Purpose:
- *      Retrieve the handle to the channel manager created for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *phMgr:         Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phMgr != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
- *                      or NULL.
- *      else:           *phMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       OUT struct CHNL_MGR **phMgr);
-
-/*
- *  ======== DEV_GetCmmMgr ========
- *  Purpose:
- *      Retrieve the handle to the shared memory manager created for this
- *      device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *phMgr:         Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phMgr != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
- *                      or NULL.
- *      else:           *phMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct CMM_OBJECT **phMgr);
-
-/*
- *  ======== DEV_GetDmmMgr ========
- *  Purpose:
- *      Retrieve the handle to the dynamic memory manager created for this
- *      device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *phMgr:         Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phMgr != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
- *                      or NULL.
- *      else:           *phMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DMM_OBJECT **phMgr);
-
-/*
- *  ======== DEV_GetCodMgr ========
- *  Purpose:
- *      Retrieve the COD manager create for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *phCodMgr:      Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phCodMgr != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phCodMgr contains a handle to a COD manager object.
- *      else:           *phCodMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct COD_MANAGER **phCodMgr);
-
-/*
- *  ======== DEV_GetDehMgr ========
- *  Purpose:
- *      Retrieve the DEH manager created for this device.
- *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *      *phDehMgr:  Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EHANDLE:   Invalid hDevObject.
- *  Requires:
- *      phDehMgr != NULL.
- *      DEH Initialized.
- *  Ensures:
- *      DSP_SOK:    *phDehMgr contains a handle to a DEH manager object.
- *      else:       *phDehMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DEH_MGR **phDehMgr);
-
-/*
- *  ======== DEV_GetDevNode ========
- *  Purpose:
- *      Retrieve the platform specific device ID for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      phDevNode:      Ptr to location to get the device node handle.
- *  Returns:
- *      DSP_SOK:        In Win95, returns a DEVNODE in *hDevNode; In NT, ???
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phDevNode != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phDevNode contains a platform specific device ID;
- *      else:           *phDevNode is NULL.
- */
-       extern DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
-					OUT struct CFG_DEVNODE **phDevNode);
-
-/*
- *  ======== DEV_GetDevType ========
- *  Purpose:
- *      Retrieve the platform specific device ID for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      phDevNode:      Ptr to location to get the device node handle.
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phDevNode != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phDevNode contains a platform specific device ID;
- *      else:           *phDevNode is NULL.
- */
-       extern DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject,
-					       u32 *devType);
-
-/*
- *  ======== DEV_GetFirst ========
- *  Purpose:
- *      Retrieve the first Device Object handle from an internal linked list of
- *      of DEV_OBJECTs maintained by DEV.
- *  Parameters:
- *  Returns:
- *      NULL if there are no device objects stored; else
- *      a valid DEV_HOBJECT.
- *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
- *  Ensures:
- *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
- *      the list.
- */
-       extern struct DEV_OBJECT *DEV_GetFirst();
-
-/*
- *  ======== DEV_GetIntfFxns ========
- *  Purpose:
- *      Retrieve the WMD interface function structure for the loaded WMD.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *ppIntfFxns:    Ptr to location to store fxn interface.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      ppIntfFxns != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *ppIntfFxns contains a pointer to the WMD interface;
- *      else:           *ppIntfFxns is NULL.
- */
-       extern DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DRV_INTERFACE **ppIntfFxns);
-
-/*
- *  ======== DEV_GetIOMgr ========
- *  Purpose:
- *      Retrieve the handle to the IO manager created for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      *phMgr:         Ptr to location to store handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phMgr != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phMgr contains a handle to an IO manager object.
- *      else:           *phMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct IO_MGR **phMgr);
-
-/*
- *  ======== DEV_GetNext ========
- *  Purpose:
- *      Retrieve the next Device Object handle from an internal linked list of
- *      of DEV_OBJECTs maintained by DEV, after having previously called
- *      DEV_GetFirst() and zero or more DEV_GetNext
- *  Parameters:
- *      hDevObject: Handle to the device object returned from a previous
- *                  call to DEV_GetFirst() or DEV_GetNext().
- *  Returns:
- *      NULL if there are no further device objects on the list or hDevObject
- *      was invalid;
- *      else the next valid DEV_HOBJECT in the list.
- *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
- *  Ensures:
- *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
- *      the list.
- */
-       extern struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT
-						    *hDevObject);
-
-/*
- *  ========= DEV_GetMsgMgr ========
- *  Purpose:
- *      Retrieve the MSG Manager Handle from the DevObject.
- *  Parameters:
- *      hDevObject: Handle to the Dev Object
- *      phMsgMgr:   Location where MSG Manager handle will be returned.
- *  Returns:
- *  Requires:
- *      DEV Initialized.
- *      Valid hDevObject.
- *      phNodeMgr != NULL.
- *  Ensures:
- */
-       extern void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
-					OUT struct MSG_MGR **phMsgMgr);
-
-/*
- *  ========= DEV_GetNodeManager ========
- *  Purpose:
- *      Retrieve the Node Manager Handle from the DevObject. It is an
- *      accessor function
- *  Parameters:
- *      hDevObject:     Handle to the Dev Object
- *      phNodeMgr:      Location where Handle to the Node Manager will be
- *                      returned..
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EHANDLE:    Invalid Dev Object handle.
- *  Requires:
- *      DEV Initialized.
- *      phNodeMgr is not null
- *  Ensures:
- *      DSP_SOK:        *phNodeMgr contains a handle to a Node manager object.
- *      else:           *phNodeMgr is NULL.
- */
-       extern DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT
-					*hDevObject,
-					OUT struct NODE_MGR **phNodeMgr);
-
-/*
- *  ======== DEV_GetSymbol ========
- *  Purpose:
- *      Get the value of a symbol in the currently loaded program.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      pstrSym:        Name of symbol to look up.
- *      pulValue:       Ptr to symbol value.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
- *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
- *  Requires:
- *      pstrSym != NULL.
- *      pulValue != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *pulValue contains the symbol value;
- */
-       extern DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
-					      IN CONST char *pstrSym,
-					      OUT u32 *pulValue);
-
-/*
- *  ======== DEV_GetWMDContext ========
- *  Purpose:
- *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
- *  Parameters:
- *      hDevObject:     Handle to device object created with DEV_CreateDevice()
- *      *phWmdContext:  Ptr to location to store context handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      phWmdContext != NULL.
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK:        *phWmdContext contains context handle;
- *      else:           *phWmdContext is NULL;
- */
-       extern DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DEV_CONTEXT **phWmdContext);
-
-/*
- *  ======== DEV_Exit ========
- *  Purpose:
- *      Decrement reference count, and free resources when reference count is
- *      0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DEV is initialized.
- *  Ensures:
- *      When reference count == 0, DEV's private resources are freed.
- */
-       extern void DEV_Exit();
-
-/*
- *  ======== DEV_Init ========
- *  Purpose:
- *      Initialize DEV's private state, keeping a reference count on each call.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      TRUE: A requirement for the other public DEV functions.
- */
-       extern bool DEV_Init();
-
-/*
- *  ======== DEV_IsLocked ========
- *  Purpose:
- *      Predicate function to determine if the device has been
- *      locked by a client for exclusive access.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *  Returns:
- *      DSP_SOK:        TRUE: device has been locked.
- *      DSP_SFALSE:     FALSE: device not locked.
- *      DSP_EHANDLE:    hDevObject was invalid.
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- */
-       extern DSP_STATUS DEV_IsLocked(IN struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== DEV_InsertProcObject ========
- *  Purpose:
- *      Inserts the Processor Object into the List of PROC Objects
- *      kept in the DEV Object
- *  Parameters:
- *      hProcObject:    Handle to the Proc Object
- *      hDevObject      Handle to the Dev Object
- *      bAttachedNew    Specifies if there are already processors attached
- *  Returns:
- *      DSP_SOK:        Successfully inserted into the list
- *  Requires:
- *      hProcObject is not NULL
- *      hDevObject is a valid handle to the DEV.
- *      DEV Initialized.
- *      List(of Proc object in Dev) Exists.
- *  Ensures:
- *      DSP_SOK & the PROC Object is inserted and the list is not empty
- *  Details:
- *      If the List of Proc Object is empty bAttachedNew is TRUE, it indicated
- *      this is the first Processor attaching.
- *      If it is False, there are already processors attached.
- */
-       extern DSP_STATUS DEV_InsertProcObject(IN struct DEV_OBJECT
-						     *hDevObject,
-						     IN u32 hProcObject,
-						     OUT bool *
-						     pbAlreadyAttached);
-
-/*
- *  ======== DEV_RemoveProcObject ========
- *  Purpose:
- *      Search for and remove a Proc object from the given list maintained
- *      by the DEV
- *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject:         Ptr to Dev Object where the list is.
- *      pbAlreadyAttached:  Ptr to return the bool
- *  Returns:
- *      DSP_SOK:            If successful.
- *      DSP_EFAIL           Failure to Remove the PROC Object from the list
- *  Requires:
- *      DevObject is Valid
- *      hProcObject != 0
- *      pDevObject->procList != NULL
- *      !LST_IsEmpty(pDevObject->procList)
- *      pbAlreadyAttached !=NULL
- *  Ensures:
- *  Details:
- *      List will be deleted when the DEV is destroyed.
- *
- */
-       extern DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT
-						     *hDevObject,
-						     u32 hProcObject);
-
-/*
- *  ======== DEV_NotifyClients ========
- *  Purpose:
- *      Notify all clients of this device of a change in device status.
- *      Clients may include multiple users of BRD, as well as CHNL.
- *      This function is asychronous, and may be called by a timer event
- *      set up by a watchdog timer.
- *  Parameters:
- *      hDevObject:  Handle to device object created with DEV_CreateDevice().
- *      ulStatus:    A status word, most likely a BRD_STATUS.
- *  Returns:
- *      DSP_SOK:     All registered clients were asynchronously notified.
- *      DSP_EINVALIDARG:   Invalid hDevObject.
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- *      DSP_SOK: Notifications are queued by the operating system to be
- *      delivered to clients.  This function does not ensure that
- *      the notifications will ever be delivered.
- */
-       extern DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
-						  u32 ulStatus);
-
-
-
-/*
- *  ======== DEV_RemoveDevice ========
- *  Purpose:
- *      Destroys the Device Object created by DEV_StartDevice.
- *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
- *  Returns:
- *      DSP_SOK:        If success;
- *      <error code>    Otherwise.
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode);
-
-/*
- *  ======== DEV_SetChnlMgr ========
- *  Purpose:
- *      Set the channel manager for this device.
- *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      hMgr:           Handle to a channel manager, or NULL.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- */
-       extern DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       struct CHNL_MGR *hMgr);
-
-/*
- *  ======== DEV_SetMsgMgr ========
- *  Purpose:
- *      Set the Message manager for this device.
- *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *      hMgr:       Handle to a message manager, or NULL.
- *  Returns:
- *  Requires:
- *      DEV Initialized.
- *  Ensures:
- */
-       extern void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject,
-					struct MSG_MGR *hMgr);
-
-/*
- *  ======== DEV_StartDevice ========
- *  Purpose:
- *      Initializes the new device with the WinBRIDGE environment.  This
- *      involves querying CM for allocated resources, querying the registry
- *      for necessary dsp resources (requested in the INF file), and using
- *      this information to create a WinBRIDGE device object.
- *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
- *  Returns:
- *      DSP_SOK:        If success;
- *      <error code>    Otherwise.
- *  Requires:
- *      DEV initialized.
- *  Ensures:
- */
-       extern DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode);
-
-#endif				/* DEV_ */
--- a/arch/arm/plat-omap/include/bridge/dispdefs.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/dispdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dispdefs.h ========
- *  Description:
- *      Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 08-Aug-2000 jeh     Added fields to DISP_ATTRS.
- *! 06-Jul-2000 jeh     Created.
- */
-
-#ifndef DISPDEFS_
-#define DISPDEFS_
-
-	struct DISP_OBJECT;
-
-/* Node Dispatcher attributes */
-	struct DISP_ATTRS {
-		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
-		/* Size of buffer for sending data to RMS */
-		u32 ulChnlBufSize;
-		DSP_PROCFAMILY procFamily;	/* eg, 5000 */
-		DSP_PROCTYPE procType;	/* eg, 5510 */
-		HANDLE hReserved1;	/* Reserved for future use. */
-		u32 hReserved2;	/* Reserved for future use. */
-	} ;
-
-#endif				/* DISPDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/disp.h
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/disp.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== disp.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge Node Dispatcher.
- *
- *  Public Functions:
- *      DISP_Create
- *      DISP_Delete
- *      DISP_Exit
- *      DISP_Init
- *      DISP_NodeChangePriority
- *      DISP_NodeCreate
- *      DISP_NodeDelete
- *      DISP_NodeRun
- *
- *! Revision History:
- *! =================
- *! 28-Jan-2003 map     Removed DISP_DoCinit().
- *! 15-May-2002 jeh     Added DISP_DoCinit().
- *! 24-Apr-2002 jeh     Added DISP_MemWrite().
- *! 07-Sep-2001 jeh     Added DISP_MemCopy().
- *! 10-May-2001 jeh     Code review cleanup.
- *! 08-Aug-2000 jeh     Removed DISP_NodeTerminate since it no longer uses RMS.
- *! 17-Jul-2000 jeh     Updates to function headers.
- *! 19-Jun-2000 jeh     Created.
- */
-
-#ifndef DISP_
-#define DISP_
-
-#include <dbdefs.h>
-#include <nodedefs.h>
-#include <nodepriv.h>
-#include <dispdefs.h>
-
-/*
- *  ======== DISP_Create ========
- *  Create a NODE Dispatcher object. This object handles the creation,
- *  deletion, and execution of nodes on the DSP target, through communication
- *  with the Resource Manager Server running on the target. Each NODE
- *  Manager object should have exactly one NODE Dispatcher.
- *
- *  Parameters:
- *      phDispObject:   Location to store node dispatcher object on output.
- *      hDevObject:     Device for this processor.
- *      pDispAttrs:     Node dispatcher attributes.
- *  Returns:
- *      DSP_SOK:                Success;
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      DSP_EFAIL:              Unable to create dispatcher.
- *  Requires:
- *      DISP_Init() called.
- *      pDispAttrs != NULL.
- *      hDevObject != NULL.
- *      phDispObject != NULL.
- *  Ensures:
- *      DSP_SOK:        IsValid(*phDispObject).
- *      error:          *phDispObject == NULL.
- */
-	extern DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct DISP_ATTRS *pDispAttrs);
-
-/*
- *  ======== DISP_Delete ========
- *  Delete the NODE Dispatcher.
- *
- *  Parameters:
- *      hDispObject:  Node Dispatcher object.
- *  Returns:
- *  Requires:
- *      DISP_Init() called.
- *      Valid hDispObject.
- *  Ensures:
- *      hDispObject is invalid.
- */
-	extern void DISP_Delete(struct DISP_OBJECT *hDispObject);
-
-/*
- *  ======== DISP_Exit ========
- *  Discontinue usage of DISP module.
- *
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DISP_Init() previously called.
- *  Ensures:
- *      Any resources acquired in DISP_Init() will be freed when last DISP
- *      client calls DISP_Exit().
- */
-	extern void DISP_Exit();
-
-/*
- *  ======== DISP_Init ========
- *  Initialize the DISP module.
- *
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	extern bool DISP_Init();
-
-/*
- *  ======== DISP_NodeChangePriority ========
- *  Change the priority of a node currently running on the target.
- *
- *  Parameters:
- *      hDispObject:            Node Dispatcher object.
- *      hNode:                  Node object representing a node currently
- *                              allocated or running on the DSP.
- *      ulFxnAddress:           Address of RMS function for changing priority.
- *      nodeEnv:                Address of node's environment structure.
- *      nPriority:              New priority level to set node's priority to.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_ETIMEOUT:           A timeout occurred before the DSP responded.
- *  Requires:
- *      DISP_Init() called.
- *      Valid hDispObject.
- *      hNode != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT
-						  *hDispObject,
-						  struct NODE_OBJECT *hNode,
-						  u32 ulFxnAddr,
-						  NODE_ENV nodeEnv,
-						  s32 nPriority);
-
-/*
- *  ======== DISP_NodeCreate ========
- *  Create a node on the DSP by remotely calling the node's create function.
- *
- *  Parameters:
- *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node handle obtained from NODE_Allocate().
- *      ulFxnAddr:      Address or RMS create node function.
- *      ulCreateFxn:    Address of node's create function.
- *      pArgs:          Arguments to pass to RMS node create function.
- *      pNodeEnv:       Location to store node environment pointer on
- *                      output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ETASK:      Unable to create the node's task or process on the DSP.
- *      DSP_ESTREAM:    Stream creation failure on the DSP.
- *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
- *      DSP_EUSER:      A user-defined failure occurred.
- *      DSP_EFAIL:      A failure occurred, unable to create node.
- *  Requires:
- *      DISP_Init() called.
- *      Valid hDispObject.
- *      pArgs != NULL.
- *      hNode != NULL.
- *      pNodeEnv != NULL.
- *      NODE_GetType(hNode) != NODE_DEVICE.
- *  Ensures:
- */
-	extern DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulCreateFxn,
-					  IN CONST struct NODE_CREATEARGS
-					  *pArgs,
-					  OUT NODE_ENV *pNodeEnv);
-
-/*
- *  ======== DISP_NodeDelete ========
- *  Delete a node on the DSP by remotely calling the node's delete function.
- *
- *  Parameters:
- *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node currently
- *                      loaded on the DSP.
- *      ulFxnAddr:      Address or RMS delete node function.
- *      ulDeleteFxn:    Address of node's delete function.
- *      nodeEnv:        Address of node's environment structure.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
- *  Requires:
- *      DISP_Init() called.
- *      Valid hDispObject.
- *      hNode != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulDeleteFxn, NODE_ENV nodeEnv);
-
-/*
- *  ======== DISP_NodeRun ========
- *  Start execution of a node's execute phase, or resume execution of a node
- *  that has been suspended (via DISP_NodePause()) on the DSP.
- *
- *  Parameters:
- *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node to be executed
- *                      on the DSP.
- *      ulFxnAddr:      Address or RMS node execute function.
- *      ulExecuteFxn:   Address of node's execute function.
- *      nodeEnv:        Address of node's environment structure.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
- *  Requires:
- *      DISP_Init() called.
- *      Valid hDispObject.
- *      hNode != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDispObject,
-				       struct NODE_OBJECT *hNode,
-				       u32 ulFxnAddr,
-				       u32 ulExecuteFxn, NODE_ENV nodeEnv);
-
-#endif				/* DISP_ */
--- a/arch/arm/plat-omap/include/bridge/dmm.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * bridge/inc/dmm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dmm.h ========
- *  Purpose:
- *      The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
- *      space that can be directly mapped to any MPU buffer or memory region
- *
- *  Public Functions:
- *
- *! Revision History:
- *! ================
- *! 20-Feb-2004 sb: Created.
- *!
- */
-
-#ifndef DMM_
-#define DMM_
-
-#include <dbdefs.h>
-
-	struct DMM_OBJECT;
-
-/* DMM attributes used in DMM_Create() */
-	struct DMM_MGRATTRS {
-		u32 reserved;
-	} ;
-
-#define DMMPOOLSIZE      0x4000000
-
-/*
- *  ======== DMM_GetHandle ========
- *  Purpose:
- *      Return the dynamic memory manager object for this device.
- *      This is typically called from the client process.
- */
-
-	extern DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
-					OUT struct DMM_OBJECT **phDmmMgr);
-
-	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					    u32 size,
-					    u32 *pRsvAddr);
-
-	extern DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					      u32 rsvAddr);
-
-	extern DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr,
-					u32 size);
-
-	extern DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr,
-					  u32 addr,
-					  u32 *pSize);
-
-	extern DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr);
-
-	extern DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr);
-
-	extern DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct DMM_MGRATTRS *pMgrAttrs);
-
-	extern bool DMM_Init();
-
-	extern void DMM_Exit();
-
-	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
-						u32 addr, u32 size);
-	extern u32 *DMM_GetPhysicalAddrTable(void);
-#endif				/* DMM_ */
--- a/arch/arm/plat-omap/include/bridge/dpc.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * bridge/inc/dpc.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dpc.h ========
- *  Purpose:
- *      Deferred Procedure Call(DPC) Services.
- *
- *  Public Functions:
- *      DPC_Cancel
- *      DPC_Create
- *      DPC_Destroy
- *      DPC_Exit
- *      DPC_Init
- *      DPC_Schedule
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr:  DPC_Destroy ensures Suceess and DPC Object is NULL.
- *! 21-Jan-2000 ag:  Updated comments per code review.
- *! 06-Jan-2000 ag:  Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 14-Jan-1998 gp:  Added DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 18-Aug-1997 cr:  Added explicit CDECL identifiers.
- *! 28-Jul-1996 gp:  Created.
- */
-
-#ifndef DPC_
-#define DPC_
-
-	struct DPC_OBJECT;
-
-/*
- *  ======== DPC_PROC ========
- *  Purpose:
- *      Deferred processing routine.  Typically scheduled from an ISR to
- *      complete I/O processing.
- *  Parameters:
- *      pRefData:   Ptr to user data: passed in via ISR_ScheduleDPC.
- *  Returns:
- *  Requires:
- *      The DPC should not block, or otherwise acquire resources.
- *      Interrupts to the processor are enabled.
- *      DPC_PROC executes in a critical section.
- *  Ensures:
- *      This DPC will not be reenterred on the same thread.
- *      However, the DPC may take hardware interrupts during execution.
- *      Interrupts to the processor are enabled.
- */
-       typedef void(*DPC_PROC) (void *pRefData);
-
-/*
- *  ======== DPC_Cancel ========
- *  Purpose:
- *      Cancel a DPC previously scheduled by DPC_Schedule.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Scheduled DPC, if any, is cancelled.
- *      DSP_SFALSE:     No DPC is currently scheduled for execution.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *  Ensures:
- *      If the DPC has already executed, is executing, or was not yet
- *      scheduled, this function will have no effect.
- */
-       extern DSP_STATUS DPC_Cancel(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Create ========
- *  Purpose:
- *      Create a DPC object, allowing a client's own DPC procedure to be
- *      scheduled for a call with client reference data.
- *  Parameters:
- *      phDPC:          Pointer to location to store DPC object.
- *      pfnDPC:         Client's DPC procedure.
- *      pRefData:       Pointer to user-defined reference data.
- *  Returns:
- *      DSP_SOK:        DPC object created.
- *      DSP_EPOINTER:   phDPC == NULL or pfnDPC == NULL.
- *      DSP_EMEMORY:    Insufficient memory.
- *  Requires:
- *      Must not be called at interrupt time.
- *  Ensures:
- *      DSP_SOK: DPC object is created;
- *      else: *phDPC is set to NULL.
- */
-       extern DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC,
-					   IN DPC_PROC pfnDPC,
-					   IN void *pRefData);
-
-/*
- *  ======== DPC_Destroy ========
- *  Purpose:
- *      Cancel the last scheduled DPC, and deallocate a DPC object previously
- *      allocated with DPC_Create().Frees the Object only if the thread and
- *      the events are terminated successfuly.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      All DPC's scheduled for the DPC object must have completed their
- *      processing.
- *  Ensures:
- *      (SUCCESS && hDPC is NULL) or DSP_EFAILED status
- */
-       extern DSP_STATUS DPC_Destroy(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Exit ========
- *  Purpose:
- *      Discontinue usage of the DPC module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DPC_Init() was previously called.
- *  Ensures:
- *      Resources acquired in DPC_Init() are freed.
- */
-       extern void DPC_Exit();
-
-/*
- *  ======== DPC_Init ========
- *  Purpose:
- *      Initialize the DPC module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public DPC functions.
- */
-       extern bool DPC_Init();
-
-/*
- *  ======== DPC_Schedule ========
- *  Purpose:
- *      Schedule a deferred procedure call to be executed at a later time.
- *      Latency and order of DPC execution is platform specific.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        An event is scheduled for deferred processing.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      See requirements for DPC_PROC.
- *  Ensures:
- *      DSP_SOK:        The DPC will not be called before this function returns.
- */
-       extern DSP_STATUS DPC_Schedule(IN struct DPC_OBJECT *hDPC);
-
-#endif				/* DPC_ */
--- a/arch/arm/plat-omap/include/bridge/drvdefs.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * bridge/inc/drvdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== drvdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and drv.h.
- *
- *! Revision History:
- *! ================
- *! 17-Jul-2000 rr: Created
- */
-
-#ifndef DRVDEFS_
-#define DRVDEFS_
-
-/* WCD Driver Object */
-	struct DRV_OBJECT;
-
-#endif				/* DRVDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/drv.h
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * bridge/inc/drv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== drv.h ========
- *  Purpose:
- *      DRV Resource allocation module. Driver Object gets Created
- *      at the time of Loading. It holds the List of Device Objects
- *      in the Syste,
- *
- *  Public Functions:
- *      DRV_Create
- *      DRV_Destroy
- *      DRV_Exit
- *      DRV_GetDevObject
- *      DRV_GetDevExtension
- *      DRV_GetFirstDevObject
- *      DRV_GetNextDevObject
- *      DRV_GetNextDevExtension
- *      DRV_Init
- *      DRV_InsertDevObject
- *      DRV_RemoveDevObject
- *      DRV_RequestResources
- *      DRV_ReleaseResources
- *
- *! Revision History
- *! ================
- *! 10-Feb-2004 vp:  Added OMAP24xx specific definitions.
- *! 14-Aug-2000 rr:  Cleaned up.
- *! 27-Jul-2000 rr:  DRV_RequestResources split into two(Request and Release)
- *!                  Device extension created to hold the DevNodeString.
- *! 17-Jul-2000 rr:  Driver Object holds the list of Device Objects.
- *!                  Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
- *!                  DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
- *! 12-Nov-1999 rr:  New Flag defines for DRV_ASSIGN and DRV_RELEASE
- *! 25-Oct-1999 rr:  Resource Structure removed.
- *! 15-Oct-1999 rr:  New Resource structure created.
- *! 05-Oct-1999 rr:  Added DRV_RequestResources
- *!                  Removed fxn'sDRV_RegisterMiniDriver(),
- *!		     DRV_UnRegisterMiniDriver()
- *!                  Removed Structures DSP_DRIVER & DRV_EXTENSION.
- *!
- *! 24-Sep-1999 rr:  Added DRV_EXTENSION and DSP_DRIVER structures.
- *!
- */
-
-#ifndef DRV_
-#define DRV_
-
-#include <devdefs.h>
-
-#include <drvdefs.h>
-
-#define DRV_ASSIGN     1
-#define DRV_RELEASE    0
-
-#ifdef CONFIG_ARCH_OMAP3430
-
-/* Provide the DSP Internal memory windows that can be accessed from L3 address
- * space */
-
-#define OMAP_GEM_BASE   0x107F8000
-#define OMAP_DSP_SIZE   0x00720000
-
-/* MEM1 is L2 RAM + L2 Cache space */
-#define OMAP_DSP_MEM1_BASE 0x5C7F8000
-#define OMAP_DSP_MEM1_SIZE 0x18000
-#define OMAP_DSP_GEM1_BASE 0x107F8000
-
-
-/* MEM2 is L1P RAM/CACHE space */
-#define OMAP_DSP_MEM2_BASE 0x5CE00000
-#define OMAP_DSP_MEM2_SIZE 0x8000
-#define OMAP_DSP_GEM2_BASE 0x10E00000
-
-/* MEM3 is L1D RAM/CACHE space */
-#define OMAP_DSP_MEM3_BASE 0x5CF04000
-#define OMAP_DSP_MEM3_SIZE 0x14000
-#define OMAP_DSP_GEM3_BASE 0x10F04000
-
-
-#define OMAP_IVA2_PRM_BASE 0x48306000
-#define OMAP_IVA2_PRM_SIZE 0x1000
-
-#define OMAP_IVA2_CM_BASE 0x48004000
-#define OMAP_IVA2_CM_SIZE 0x1000
-
-#define OMAP_PER_CM_BASE 0x48005000
-#define OMAP_PER_CM_SIZE 0x1000
-
-#define OMAP_SYSC_BASE 0x48002000
-#define OMAP_SYSC_SIZE 0x1000
-
-#define OMAP_MBOX_BASE 0x48094000
-#define OMAP_MBOX_SIZE 0x1000
-
-#define OMAP_DMMU_BASE 0x5D000000
-#define OMAP_DMMU_SIZE 0x1000
-
-#define OMAP_PRCM_VDD1_DOMAIN 1
-#define OMAP_PRCM_VDD2_DOMAIN 2
-
-#endif
-
-#ifndef RES_CLEANUP_DISABLE
-
-/* GPP PROCESS CLEANUP Data structures */
-
-/* New structure (member of process context) abstracts NODE resource info */
-struct NODE_RES_OBJECT {
-	DSP_HNODE       hNode;
-	s32            nodeAllocated; /* Node status */
-	s32            heapAllocated; /* Heap status */
-	s32            streamsAllocated; /* Streams status */
-	struct NODE_RES_OBJECT         *next;
-} ;
-
-/* New structure (member of process context) abstracts DMM resource info */
-struct DMM_RES_OBJECT {
-	s32            dmmAllocated; /* DMM status */
-	u32           ulMpuAddr;
-	u32           ulDSPAddr;
-	u32           ulDSPResAddr;
-	u32           dmmSize;
-	HANDLE          hProcessor;
-	struct DMM_RES_OBJECT  *next;
-} ;
-
-/* New structure (member of process context) abstracts DMM resource info */
-struct DSPHEAP_RES_OBJECT {
-	s32            heapAllocated; /* DMM status */
-	u32           ulMpuAddr;
-	u32           ulDSPAddr;
-	u32           ulDSPResAddr;
-	u32           heapSize;
-	HANDLE          hProcessor;
-	struct DSPHEAP_RES_OBJECT  *next;
-} ;
-
-/* New structure (member of process context) abstracts stream resource info */
-struct STRM_RES_OBJECT {
-	s32                    streamAllocated; /* Stream status */
-	DSP_HSTREAM             hStream;
-	u32                    uNumBufs;
-	u32                    uDir;
-	struct STRM_RES_OBJECT         *next;
-} ;
-
-/* Overall Bridge process resource usage state */
-enum GPP_PROC_RES_STATE {
-	PROC_RES_ALLOCATED,
-	PROC_RES_FREED
-} ;
-
-/* Process Context */
-struct PROCESS_CONTEXT{
-	/* Process State */
-	enum GPP_PROC_RES_STATE resState;
-
-	/* Process ID (Same as UNIX process ID) */
-	u32 pid;
-
-	/* Pointer to next process context
-	* (To maintain a linked list of process contexts) */
-	struct PROCESS_CONTEXT *next;
-
-	/* Processor info to which the process is related */
-	DSP_HPROCESSOR hProcessor;
-
-	/* DSP Node resources */
-	struct NODE_RES_OBJECT *pNodeList;
-
-	/* DMM resources */
-	struct DMM_RES_OBJECT *pDMMList;
-
-	/* DSP Heap resources */
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
-
-	/* Stream resources */
-	struct STRM_RES_OBJECT *pSTRMList;
-} ;
-#endif
-
-/*
- *  ======== DRV_Create ========
- *  Purpose:
- *      Creates the Driver Object. This is done during the driver loading.
- *      There is only one Driver Object in the DSP/BIOS Bridge.
- *  Parameters:
- *      phDrvObject:    Location to store created DRV Object handle.
- *  Returns:
- *      DSP_SOK:        Sucess
- *      DSP_EMEMORY:    Failed in Memory allocation
- *      DSP_EFAIL:      General Failure
- *  Requires:
- *      DRV Initialized (cRefs > 0 )
- *      phDrvObject != NULL.
- *  Ensures:
- *      DSP_SOK:        - *phDrvObject is a valid DRV interface to the device.
- *                      - List of DevObject Created and Initialized.
- *                      - List of DevNode String created and intialized.
- *                      - Registry is updated with the DRV Object.
- *      !DSP_SOK:       DRV Object not created
- *  Details:
- *      There is one Driver Object for the Driver representing
- *      the driver itself. It contains the list of device
- *      Objects and the list of Device Extensions in the system.
- *      Also it can hold other neccessary
- *      information in its storage area.
- */
-	extern DSP_STATUS DRV_Create(struct DRV_OBJECT **phDrvObject);
-
-/*
- *  ======== DRV_Destroy ========
- *  Purpose:
- *      destroys the Dev Object list, DrvExt list
- *      and destroy the DRV object
- *      Called upon driver unLoading.or unsuccesful loading of the driver.
- *  Parameters:
- *      hDrvObject:     Handle to Driver object .
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to destroy DRV Object
- *  Requires:
- *      DRV Initialized (cRegs > 0 )
- *      hDrvObject is not NULL and a valid DRV handle .
- *      List of DevObject is Empty.
- *      List of DrvExt is Empty
- *  Ensures:
- *      DSP_SOK:        - DRV Object destroyed and hDrvObject is not a valid
- *                        DRV handle.
- *                      - Registry is updated with "0" as the DRV Object.
- */
-	extern DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDrvObject);
-
-/*
- *  ======== DRV_Exit ========
- *  Purpose:
- *      Exit the DRV module, freeing any modules initialized in DRV_Init.
- *  Parameters:
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-	extern void DRV_Exit();
-
-/*
- *  ======== DRV_GetFirstDevObject ========
- *  Purpose:
- *      Returns the Ptr to the FirstDev Object in the List
- *  Parameters:
- *  Requires:
- *      DRV Initialized
- *  Returns:
- *      dwDevObject:  Ptr to the First Dev Object as a u32
- *      0 if it fails to retrieve the First Dev Object
- *  Ensures:
- */
-	extern u32 DRV_GetFirstDevObject();
-
-/*
- *  ======== DRV_GetFirstDevExtension ========
- *  Purpose:
- *      Returns the Ptr to the First Device Extension in the List
- *  Parameters:
- *  Requires:
- *      DRV Initialized
- *  Returns:
- *      dwDevExtension:     Ptr to the First Device Extension as a u32
- *      0:                  Failed to Get the Device Extension
- *  Ensures:
- */
-	extern u32 DRV_GetFirstDevExtension();
-
-/*
- *  ======== DRV_GetDevObject ========
- *  Purpose:
- *      Given a index, returns a handle to DevObject from the list
- *  Parameters:
- *      hDrvObject:     Handle to the Manager
- *      phDevObject:    Location to store the Dev Handle
- *  Requires:
- *      DRV Initialized
- *      uIndex >= 0
- *      hDrvObject is not NULL and Valid DRV Object
- *      phDevObject is not NULL
- *      Device Object List not Empty
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EFAIL:      Failed to Get the Dev Object
- *  Ensures:
- *      DSP_SOK:        *phDevObject != NULL
- *      DSP_EFAIL:      *phDevObject = NULL
- */
-	extern DSP_STATUS DRV_GetDevObject(u32 uIndex,
-					   struct DRV_OBJECT *hDrvObject,
-					   struct DEV_OBJECT **phDevObject);
-
-/*
- *  ======== DRV_GetNextDevObject ========
- *  Purpose:
- *      Returns the Ptr to the Next Device Object from the the List
- *  Parameters:
- *      hDevObject:     Handle to the Device Object
- *  Requires:
- *      DRV Initialized
- *      hDevObject != 0
- *  Returns:
- *      dwDevObject:    Ptr to the Next Dev Object as a u32
- *      0:              If it fail to get the next Dev Object.
- *  Ensures:
- */
-	extern u32 DRV_GetNextDevObject(u32 hDevObject);
-
-/*
- *  ======== DRV_GetNextDevExtension ========
- *  Purpose:
- *      Returns the Ptr to the Next Device Extension from the the List
- *  Parameters:
- *      hDevExtension:      Handle to the Device Extension
- *  Requires:
- *      DRV Initialized
- *      hDevExtension != 0.
- *  Returns:
- *      dwDevExtension:     Ptr to the Next Dev Extension
- *      0:                  If it fail to Get the next Dev Extension
- *  Ensures:
- */
-	extern u32 DRV_GetNextDevExtension(u32 hDevExtension);
-
-/*
- *  ======== DRV_Init ========
- *  Purpose:
- *      Initialize the DRV module.
- *  Parameters:
- *  Returns:
- *      TRUE if success; FALSE otherwise.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS DRV_Init();
-
-/*
- *  ======== DRV_InsertDevObject ========
- *  Purpose:
- *      Insert a DeviceObject into the list of Driver object.
- *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DeviceObject to insert.
- *  Returns:
- *      DSP_SOK:        If successful.
- *      DSP_EFAIL:      General Failure:
- *  Requires:
- *      hDrvObject != NULL and Valid DRV Handle.
- *      hDevObject != NULL.
- *  Ensures:
- *      DSP_SOK:        Device Object is inserted and the List is not empty.
- */
-	extern DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== DRV_RemoveDevObject ========
- *  Purpose:
- *      Search for and remove a Device object from the given list of Device Obj
- *      objects.
- *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DevObject to Remove
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to find pDevObject.
- *  Requires:
- *      hDrvObject != NULL and a Valid DRV Handle.
- *      hDevObject != NULL.
- *      List exists and is not empty.
- *  Ensures:
- *      List either does not exist (NULL), or is not empty if it does exist.
-*/
-	extern DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== DRV_RequestResources ========
- *  Purpose:
- *      Assigns the Resources or Releases them.
- *  Parameters:
- *      dwContext:          Path to the driver Registry Key.
- *      pDevNodeString:     Ptr to DevNode String stored in the Device Ext.
- *  Returns:
- *      TRUE if success; FALSE otherwise.
- *  Requires:
- *  Ensures:
- *      The Resources are assigned based on Bus type.
- *      The hardware is initialized. Resource information is
- *      gathered from the Registry(ISA, PCMCIA)or scanned(PCI)
- *      Resource structure is stored in the registry which will be
- *      later used by the CFG module.
- */
-	extern DSP_STATUS DRV_RequestResources(IN u32 dwContext,
-					       OUT u32 *pDevNodeString);
-
-/*
- *  ======== DRV_ReleaseResources ========
- *  Purpose:
- *      Assigns the Resources or Releases them.
- *  Parameters:
- *      dwContext:      Path to the driver Registry Key.
- *      hDrvObject:     Handle to the Driver Object.
- *  Returns:
- *      TRUE if success; FALSE otherwise.
- *  Requires:
- *  Ensures:
- *      The Resources are released based on Bus type.
- *      Resource structure is deleted from the registry
- */
-	extern DSP_STATUS DRV_ReleaseResources(IN u32 dwContext,
-					       struct DRV_OBJECT *hDrvObject);
-
-#endif				/* DRV_ */
--- a/arch/arm/plat-omap/include/bridge/dspdrv.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * bridge/inc/dspdrv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dspdrv.h ========
- *  Purpose:
- *      This is the Stream Interface for the DDSP Class driver.
- *      All Device operations are performed via DeviceIOControl.
- *      Read, Seek and Write not used.
- *
- *  Public Functions
- *      DSP_Close
- *      DSP_Deinit
- *      DSP_Init
- *      DSP_IOControl
- *      DSP_Open
- *      DSP_PowerUp
- *      DSP_PowerDown
- *
- *! Revision History
- *! ================
- *! 28-Jan-2000 rr: Type void changed to Void.
- *! 02-Dec-1999 rr: MAX_DEV define moved from wcdce.c file.Code cleaned up.
- *! 12-Nov-1999 rr: "#include<wncnxerr.h> removed.
- *! 05-Oct-1999 rr  Renamed the file name to wcdce.h Removed Bus Specific
- *!                 code and #defines to PCCARD.h.
- *! 24-Sep-1999 rr  Changed the DSP_COMMON_WINDOW_SIZE to 0x4000(16k) for the
- *!                 Memory windows.
- *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet driver.
- *!
- */
-
-#if !defined __DSPDRV_h__
-#define __DSPDRV_h__
-
-#define MAX_DEV     10		/* Max support of 10 devices */
-
-/*
- *  ======== DSP_Close ========
- *  Purpose:
- *      Called when the client application/driver unloads the DDSP DLL. Upon
- *      unloading, the DDSP DLL will call CloseFile().
- *  Parameters:
- *      dwDeviceContext:    Handle returned by XXX_Open used to identify
- *                          the open context of the device
- *  Returns:
- *      TRUE indicates the device is successfully closed. FALSE indicates
- *      otherwise.
- *  Requires:
- *      dwOpenContext!= NULL.
- *  Ensures:The Application instance owned objects are cleaned up.
- */
-extern bool DSP_Close(u32 dwDeviceContext);
-
-/*
- *  ======== DSP_Deinit ========
- *  Purpose:
- *      This function is called by Device Manager to de-initialize a device.
- *      This function is not called by applications.
- *  Parameters:
- *      dwDeviceContext:Handle to the device context. The XXX_Init function
- *      creates and returns this identifier.
- *  Returns:
- *      TRUE indicates the device successfully de-initialized. Otherwise it
- *      returns FALSE.
- *  Requires:
- *      dwDeviceContext!= NULL. For a built in device this should never
- *      get called.
- *  Ensures:
- */
-extern bool DSP_Deinit(u32 dwDeviceContext);
-
-/*
- *  ======== DSP_Init ========
- *  Purpose:
- *      This function is called by Device Manager to initialize a device.
- *      This function is not called by applications
- *  Parameters:
- *      dwContext:  Specifies a pointer to a string containing the registry
- *                  path to the active key for the stream interface driver.
- *                  HKEY_LOCAL_MACHINE\Drivers\Active
- *  Returns:
- *      Returns a handle to the device context created. This is the our actual
- *      Device Object representing the DSP Device instance.
- *  Requires:
- *  Ensures:
- *      Succeeded:  device context > 0
- *      Failed:     device Context = 0
- */
-extern u32 DSP_Init(OUT u32 *initStatus);
-
-#endif
--- a/arch/arm/plat-omap/include/bridge/dynamic_loader.h
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * bridge/inc/dynamic_loader.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-
-#ifndef _DYNAMIC_LOADER_H_
-#define _DYNAMIC_LOADER_H_
-#include <linux/kernel.h>
-#include <linux/types.h>
-
-/*
- * Dynamic Loader
- *
- * The function of the dynamic loader is to load a "module" containing
- * instructions for a "target" processor into that processor.  In the process
- * it assigns memory for the module, resolves symbol references made by the
- * module, and remembers symbols defined by the module.
- *
- * The dynamic loader is parameterized for a particular system by 4 classes
- * that supply the module and system specific functions it requires
- */
-	/* The read functions for the module image to be loaded */
-	struct Dynamic_Loader_Stream;
-
-	/* This class defines "host" symbol and support functions */
-	struct Dynamic_Loader_Sym;
-
-	/* This class defines the allocator for "target" memory */
-	struct Dynamic_Loader_Allocate;
-
-	/* This class defines the copy-into-target-memory functions */
-	struct Dynamic_Loader_Initialize;
-
-/*
- * Option flags to modify the behavior of module loading
- */
-#define DLOAD_INITBSS 0x1	/* initialize BSS sections to zero */
-#define DLOAD_BIGEND 0x2	/* require big-endian load module */
-#define DLOAD_LITTLE 0x4	/* require little-endian load module */
-
-	typedef void *DLOAD_mhandle;	/* module handle for loaded modules */
-
-/*****************************************************************************
- * Procedure Dynamic_Load_Module
- *
- * Parameters:
- *  module  The input stream that supplies the module image
- *  syms    Host-side symbol table and malloc/free functions
- *  alloc   Target-side memory allocation
- *  init    Target-side memory initialization, or NULL for symbol read only
- *  options Option flags DLOAD_*
- *  mhandle A module handle for use with Dynamic_Unload
- *
- * Effect:
- *  The module image is read using *module.  Target storage for the new image is
- * obtained from *alloc.  Symbols defined and referenced by the module are
- * managed using *syms.  The image is then relocated and references resolved
- * as necessary, and the resulting executable bits are placed into target memory
- * using *init.
- *
- * Returns:
- *  On a successful load, a module handle is placed in *mhandle, and zero is
- * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Load_Module(
-				       /* the source for the module image*/
-				       struct Dynamic_Loader_Stream *module,
-				       /* host support for symbols and storage*/
-				       struct Dynamic_Loader_Sym *syms,
-				       /* the target memory allocator*/
-				       struct Dynamic_Loader_Allocate *alloc,
-				       /* the target memory initializer*/
-				       struct Dynamic_Loader_Initialize *init,
-				       unsigned options,       /* option flags*/
-				       /* the returned module handle*/
-				       DLOAD_mhandle *mhandle
-	    );
-
-/*****************************************************************************
- * Procedure Dynamic_Open_Module
- *
- * Parameters:
- *  module  The input stream that supplies the module image
- *  syms    Host-side symbol table and malloc/free functions
- *  alloc   Target-side memory allocation
- *  init    Target-side memory initialization, or NULL for symbol read only
- *  options Option flags DLOAD_*
- *  mhandle A module handle for use with Dynamic_Unload
- *
- * Effect:
- *  The module image is read using *module.  Target storage for the new image is
- * obtained from *alloc.  Symbols defined and referenced by the module are
- * managed using *syms.  The image is then relocated and references resolved
- * as necessary, and the resulting executable bits are placed into target memory
- * using *init.
- *
- * Returns:
- *  On a successful load, a module handle is placed in *mhandle, and zero is
- * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Open_Module(
-				      /* the source for the module image */
-				      struct Dynamic_Loader_Stream *module,
-				      /* host support for symbols and storage */
-				      struct Dynamic_Loader_Sym *syms,
-				      /* the target memory allocator */
-				      struct Dynamic_Loader_Allocate *alloc,
-				      /* the target memory initializer */
-				      struct Dynamic_Loader_Initialize *init,
-				      unsigned options, /* option flags */
-				      /* the returned module handle */
-				      DLOAD_mhandle *mhandle
-	);
-
-/*****************************************************************************
- * Procedure Dynamic_Unload_Module
- *
- * Parameters:
- *  mhandle A module handle from Dynamic_Load_Module
- *  syms    Host-side symbol table and malloc/free functions
- *  alloc   Target-side memory allocation
- *
- * Effect:
- *  The module specified by mhandle is unloaded.  Unloading causes all
- * target memory to be deallocated, all symbols defined by the module to
- * be purged, and any host-side storage used by the dynamic loader for
- * this module to be released.
- *
- * Returns:
- *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Unload_Module(DLOAD_mhandle mhandle,	/* the module
-								 * handle*/
-					 /* host support for symbols and
-					  * storage */
-					 struct Dynamic_Loader_Sym *syms,
-					 /* the target memory allocator*/
-					 struct Dynamic_Loader_Allocate *alloc,
-					 /* the target memory initializer*/
-					 struct Dynamic_Loader_Initialize *init
-	    );
-
-/*****************************************************************************
- *****************************************************************************
- * A class used by the dynamic loader for input of the module image
- *****************************************************************************
- *****************************************************************************/
-	struct Dynamic_Loader_Stream {
-/* public: */
-    /*************************************************************************
-     * read_buffer
-     *
-     * PARAMETERS :
-     *  buffer  Pointer to the buffer to fill
-     *  bufsiz  Amount of data desired in sizeof() units
-     *
-     * EFFECT :
-     *  Reads the specified amount of data from the module input stream
-     * into the specified buffer.  Returns the amount of data read in sizeof()
-     * units (which if less than the specification, represents an error).
-     *
-     * NOTES:
-     *  In release 1 increments the file position by the number of bytes read
-     *
-     *************************************************************************/
-		int (*read_buffer) (struct Dynamic_Loader_Stream *thisptr,
-				    void *buffer, unsigned bufsiz);
-
-    /*************************************************************************
-     * set_file_posn (release 1 only)
-     *
-     * PARAMETERS :
-     *  posn  Desired file position relative to start of file in sizeof() units.
-     *
-     * EFFECT :
-     *  Adjusts the internal state of the stream object so that the next
-     * read_buffer call will begin to read at the specified offset from
-     * the beginning of the input module.  Returns 0 for success, non-zero
-     * for failure.
-     *
-     *************************************************************************/
-		int (*set_file_posn) (struct Dynamic_Loader_Stream *thisptr,
-					/* to be eliminated in release 2*/
-					unsigned int posn);
-
-	};
-
-/*****************************************************************************
- *****************************************************************************
- * A class used by the dynamic loader for symbol table support and
- * miscellaneous host-side functions
- *****************************************************************************
- *****************************************************************************/
-
-	typedef u32 LDR_ADDR;
-
-/*
- * the structure of a symbol known to the dynamic loader
- */
-	struct dynload_symbol {
-		LDR_ADDR value;
-	} ;
-
-	struct Dynamic_Loader_Sym {
-/* public: */
-    /*************************************************************************
-     * Find_Matching_Symbol
-     *
-     * PARAMETERS :
-     *  name    The name of the desired symbol
-     *
-     * EFFECT :
-     *  Locates a symbol matching the name specified.  A pointer to the
-     * symbol is returned if it exists; 0 is returned if no such symbol is
-     * found.
-     *
-     *************************************************************************/
-		struct dynload_symbol *(*Find_Matching_Symbol)
-			(struct Dynamic_Loader_Sym *
-							 thisptr,
-							 const char *name);
-
-    /*************************************************************************
-     * Add_To_Symbol_Table
-     *
-     * PARAMETERS :
-     *  nname       Pointer to the name of the new symbol
-     *  moduleid    An opaque module id assigned by the dynamic loader
-     *
-     * EFFECT :
-     *  The new symbol is added to the table.  A pointer to the symbol is
-     * returned, or NULL is returned for failure.
-     *
-     * NOTES:
-     *  It is permissible for this function to return NULL; the effect is that
-     * the named symbol will not be available to resolve references in
-     * subsequent loads.  Returning NULL will not cause the current load
-     * to fail.
-     *************************************************************************/
-		struct dynload_symbol *(*Add_To_Symbol_Table)
-						(struct Dynamic_Loader_Sym *
-							thisptr,
-							const char *nname,
-							unsigned moduleid);
-
-    /*************************************************************************
-     * Purge_Symbol_Table
-     *
-     * PARAMETERS :
-     *  moduleid    An opaque module id assigned by the dynamic loader
-     *
-     * EFFECT :
-     *  Each symbol in the symbol table whose moduleid matches the argument
-     * is removed from the table.
-     *************************************************************************/
-		void (*Purge_Symbol_Table) (struct Dynamic_Loader_Sym *thisptr,
-					    unsigned moduleid);
-
-    /*************************************************************************
-     * Allocate
-     *
-     * PARAMETERS :
-     *  memsiz  size of desired memory in sizeof() units
-     *
-     * EFFECT :
-     *  Returns a pointer to some "host" memory for use by the dynamic
-     * loader, or NULL for failure.
-     * This function is serves as a replaceable form of "malloc" to
-     * allow the user to configure the memory usage of the dynamic loader.
-     *************************************************************************/
-		void *(*Allocate) (struct Dynamic_Loader_Sym *thisptr,
-				   unsigned memsiz);
-
-    /*************************************************************************
-     * Deallocate
-     *
-     * PARAMETERS :
-     *  memptr  pointer to previously allocated memory
-     *
-     * EFFECT :
-     *  Releases the previously allocated "host" memory.
-     *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Sym *thisptr,
-				    void *memptr);
-
-    /*************************************************************************
-     * Error_Report
-     *
-     * PARAMETERS :
-     *  errstr  pointer to an error string
-     *  args    additional arguments
-     *
-     * EFFECT :
-     *  This function provides an error reporting interface for the dynamic
-     * loader.  The error string and arguments are designed as for the
-     * library function vprintf.
-     *************************************************************************/
-		void (*Error_Report) (struct Dynamic_Loader_Sym *thisptr,
-				      const char *errstr, va_list args);
-
-	};			/* class Dynamic_Loader_Sym */
-
-/*****************************************************************************
- *****************************************************************************
- * A class used by the dynamic loader to allocate and deallocate target memory.
- *****************************************************************************
- *****************************************************************************/
-
-	struct LDR_SECTION_INFO {
-		/* Name of the memory section assigned at build time */
-		const char *name;
-		LDR_ADDR run_addr;	/* execution address of the section */
-		LDR_ADDR load_addr;	/* load address of the section */
-		LDR_ADDR size;	/* size of the section in addressable units */
-#ifndef _BIG_ENDIAN
-		u16 page;	/* memory page or view */
-		u16 type;	/* one of the section types below */
-#else
-		u16 type;	/* one of the section types below */
-		u16 page;	/* memory page or view */
-#endif
-		/* a context field for use by Dynamic_Loader_Allocate;
-		 *   ignored but maintained by the dynamic loader */
-		u32 context;
-	} ;
-
-/* use this macro to extract type of section from LDR_SECTION_INFO.type field */
-#define DLOAD_SECTION_TYPE(typeinfo) (typeinfo & 0xF)
-
-/* type of section to be allocated */
-#define DLOAD_TEXT 0
-#define DLOAD_DATA 1
-#define DLOAD_BSS 2
-	/* internal use only, run-time cinit will be of type DLOAD_DATA */
-#define DLOAD_CINIT 3
-
-	struct Dynamic_Loader_Allocate {
-/* public: */
-
-    /*************************************************************************
-    * Function allocate
-    *
-    * Parameters:
-    *   info        A pointer to an information block for the section
-    *   align       The alignment of the storage in target AUs
-    *
-    * Effect:
-    *   Allocates target memory for the specified section and fills in the
-    * load_addr and run_addr fields of the section info structure. Returns TRUE
-    * for success, FALSE for failure.
-    *
-    * Notes:
-    *   Frequently load_addr and run_addr are the same, but if they are not
-    * load_addr is used with Dynamic_Loader_Initialize, and run_addr is
-    * used for almost all relocations.  This function should always initialize
-    * both fields.
-    *************************************************************************/
-		int (*Allocate) (struct Dynamic_Loader_Allocate *thisptr,
-				 struct LDR_SECTION_INFO *info, unsigned align);
-
-    /*************************************************************************
-    * Function deallocate
-    *
-    * Parameters:
-    *   info        A pointer to an information block for the section
-    *
-    * Effect:
-    *   Releases the target memory previously allocated.
-    *
-    * Notes:
-    * The content of the info->name field is undefined on call to this function.
-    *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Allocate *thisptr,
-				    struct LDR_SECTION_INFO *info);
-
-	};			/* class Dynamic_Loader_Allocate */
-
-/*****************************************************************************
- *****************************************************************************
- * A class used by the dynamic loader to load data into a target.  This class
- * provides the interface-specific functions needed to load data.
- *****************************************************************************
- *****************************************************************************/
-
-	struct Dynamic_Loader_Initialize {
-/* public: */
-    /*************************************************************************
-    * Function connect
-    *
-    * Parameters:
-    *   none
-    *
-    * Effect:
-    *   Connect to the initialization interface. Returns TRUE for success,
-    * FALSE for failure.
-    *
-    * Notes:
-    *   This function is called prior to use of any other functions in
-    * this interface.
-    *************************************************************************/
-		int (*connect) (struct Dynamic_Loader_Initialize *thisptr);
-
-    /*************************************************************************
-    * Function readmem
-    *
-    * Parameters:
-    *   bufr        Pointer to a word-aligned buffer for the result
-    *   locn        Target address of first data element
-    *   info        Section info for the section in which the address resides
-    *   bytsiz      Size of the data to be read in sizeof() units
-    *
-    * Effect:
-    *   Fills the specified buffer with data from the target.  Returns TRUE for
-    * success, FALSE for failure.
-    *************************************************************************/
-		int (*readmem) (struct Dynamic_Loader_Initialize *thisptr,
-				void *bufr,
-				LDR_ADDR locn,
-				struct LDR_SECTION_INFO *info,
-				unsigned bytsiz);
-
-    /*************************************************************************
-    * Function writemem
-    *
-    * Parameters:
-    *   bufr        Pointer to a word-aligned buffer of data
-    *   locn        Target address of first data element to be written
-    *   info        Section info for the section in which the address resides
-    *   bytsiz      Size of the data to be written in sizeof() units
-    *
-    * Effect:
-    *   Writes the specified buffer to the target.  Returns TRUE for success,
-    * FALSE for failure.
-    *************************************************************************/
-		int (*writemem) (struct Dynamic_Loader_Initialize *thisptr,
-				 void *bufr,
-				 LDR_ADDR locn,
-				 struct LDR_SECTION_INFO *info,
-				 unsigned bytsiz);
-
-    /*************************************************************************
-    * Function fillmem
-    *
-    * Parameters:
-    *   locn        Target address of first data element to be written
-    *   info        Section info for the section in which the address resides
-    *   bytsiz      Size of the data to be written in sizeof() units
-    *   val         Value to be written in each byte
-    * Effect:
-    *   Fills the specified area of target memory.  Returns TRUE for success,
-    * FALSE for failure.
-    *************************************************************************/
-		int (*fillmem) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR locn, struct LDR_SECTION_INFO *info,
-				unsigned bytsiz, unsigned val);
-
-    /*************************************************************************
-    * Function execute
-    *
-    * Parameters:
-    *   start       Starting address
-    *
-    * Effect:
-    *   The target code at the specified starting address is executed.
-    *
-    * Notes:
-    *   This function is called at the end of the dynamic load process
-    * if the input module has specified a starting address.
-    *************************************************************************/
-		int (*execute) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR start);
-
-    /*************************************************************************
-    * Function release
-    *
-    * Parameters:
-    *   none
-    *
-    * Effect:
-    *   Releases the connection to the load interface.
-    *
-    * Notes:
-    *   This function is called at the end of the dynamic load process.
-    *************************************************************************/
-		void (*release) (struct Dynamic_Loader_Initialize *thisptr);
-
-	};			/* class Dynamic_Loader_Initialize */
-
-#endif				/* _DYNAMIC_LOADER_H_ */
--- a/arch/arm/plat-omap/include/bridge/errbase.h
+++ /dev/null
@@ -1,509 +0,0 @@
-/*
- * bridge/inc/errbase.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== errbase.h ========
- *  Description:
- *      Central repository for DSP/BIOS Bridge error and status code.
- *
- *  Error codes are of the form:
- *      [<MODULE>]_E<ERRORCODE>
- *
- *  Success codes are of the form:
- *      [<MODULE>]_S<SUCCESSCODE>
- *
- *! Revision History:
- *! ================
- *! 24-Jan-2003 map Added DSP_SALREADYLOADED for persistent library checking
- *! 23-Nov-2002 gp: Minor comment cleanup.
- *! 13-May-2002 sg  Added DSP_SALREADYASLEEP and DSP_SALREADYWAKE.
- *! 18-Feb-2002 mk: Added DSP_EOVERLAYMEMORY, EFWRITE, ENOSECT.
- *! 31-Jan-2002 mk: Added definitions of DSP_STRUE and DSP_SFALSE.
- *! 29-Jan-2002 mk: Added definition of CFG_E_INSUFFICIENTBUFSIZE.
- *! 24-Oct-2001 sp: Consolidated all the error codes into this file.
- *! 24-Jul-2001 mk: Type-casted all definitions of WSX_STATUS types for
- *!                 removal of compile warnings.
- *! 22-Nov-1999 kc: Changes from code review.
- *! 18-Aug-1999 rr: Ported From WSX.
- *! 29-May-1996 gp: Removed WCD_ and WMD_ error ranges. Redefined format of
- *!                 error codes.
- *! 10-May-1996 gp: Created.
- */
-
-#ifndef ERRBASE_
-#define ERRBASE_
-
-/* Base of generic errors and component errors */
-#define DSP_SBASE               (DSP_STATUS)0x00008000
-#define DSP_EBASE               (DSP_STATUS)0x80008000
-
-#define DSP_COMP_EBASE          (DSP_STATUS)0x80040200
-#define DSP_COMP_ELAST          (DSP_STATUS)0x80047fff
-
-/* SUCCESS Codes */
-
-/* Generic success code */
-#define DSP_SOK                     (DSP_SBASE + 0)
-
-/* GPP is already attached to this DSP processor */
-#define DSP_SALREADYATTACHED        (DSP_SBASE + 1)
-
-/* This is the last object available for enumeration. */
-#define DSP_SENUMCOMPLETE           (DSP_SBASE + 2)
-
-/* The DSP is already asleep. */
-#define DSP_SALREADYASLEEP          (DSP_SBASE + 3)
-
-/* The DSP is already awake. */
-#define DSP_SALREADYAWAKE           (DSP_SBASE + 4)
-
-/* TRUE */
-#define DSP_STRUE                   (DSP_SBASE + 5)
-
-/* FALSE */
-#define DSP_SFALSE                  (DSP_SBASE + 6)
-
-/* A library contains no dependent library references */
-#define DSP_SNODEPENDENTLIBS        (DSP_SBASE + 7)
-
-/* A persistent library is already loaded by the dynamic loader */
-#define DSP_SALREADYLOADED          (DSP_SBASE + 8)
-
-/* Some error occured, but it is OK to continue */
-#define DSP_OKTO_CONTINUE          (DSP_SBASE + 9)
-
-/* FAILURE Codes */
-
-/* The caller does not have access privileges to call this function */
-#define DSP_EACCESSDENIED           (DSP_EBASE + 0)
-
-/* The Specified Connection already exists */
-#define DSP_EALREADYCONNECTED       (DSP_EBASE + 1)
-
-/* The GPP must be detached from the DSP before this function is called */
-#define DSP_EATTACHED               (DSP_EBASE + 2)
-
-/* During enumeration a change in the number or properties of the objects
- * has occurred. */
-#define DSP_ECHANGEDURINGENUM       (DSP_EBASE + 3)
-
-/* An error occurred while parsing the DSP executable file */
-#define DSP_ECORRUPTFILE            (DSP_EBASE + 4)
-
-/* A failure occurred during a delete operation */
-#define DSP_EDELETE                 (DSP_EBASE + 5)
-
-/* The specified direction is invalid */
-#define DSP_EDIRECTION              (DSP_EBASE + 6)
-
-/* A stream has been issued the maximum number of buffers allowed in the
- * stream at once ;  buffers must be reclaimed from the stream before any
- * more can be issued. */
-#define DSP_ESTREAMFULL             (DSP_EBASE + 7)
-
-/* A general failure occurred */
-#define DSP_EFAIL                   (DSP_EBASE + 8)
-
-/* The specified executable file could not be found. */
-#define DSP_EFILE                   (DSP_EBASE + 9)
-
-/* The specified handle is invalid. */
-#define DSP_EHANDLE                 (DSP_EBASE + 0xa)
-
-/* An invalid argument was specified. */
-#define DSP_EINVALIDARG             (DSP_EBASE + 0xb)
-
-/* A memory allocation failure occurred. */
-#define DSP_EMEMORY                 (DSP_EBASE + 0xc)
-
-/* The requested operation is invalid for this node type. */
-#define DSP_ENODETYPE               (DSP_EBASE + 0xd)
-
-/* No error text was found for the specified error code. */
-#define DSP_ENOERRTEXT              (DSP_EBASE + 0xe)
-
-/* No more connections can be made for this node. */
-#define DSP_ENOMORECONNECTIONS      (DSP_EBASE + 0xf)
-
-/* The indicated operation is not supported. */
-#define DSP_ENOTIMPL                (DSP_EBASE + 0x10)
-
-/* I/O is currently pending. */
-#define DSP_EPENDING                (DSP_EBASE + 0x11)
-
-/* An invalid pointer was specified. */
-#define DSP_EPOINTER                (DSP_EBASE + 0x12)
-
-/* A parameter is specified outside its valid range. */
-#define DSP_ERANGE                  (DSP_EBASE + 0x13)
-
-/* An invalid size parameter was specified. */
-#define DSP_ESIZE                   (DSP_EBASE + 0x14)
-
-/* A stream creation failure occurred on the DSP. */
-#define DSP_ESTREAM                 (DSP_EBASE + 0x15)
-
-/* A task creation failure occurred on the DSP. */
-#define DSP_ETASK                   (DSP_EBASE + 0x16)
-
-/* A timeout occurred before the requested operation could complete. */
-
-#define DSP_ETIMEOUT                (DSP_EBASE + 0x17)
-
-/* A data truncation occurred, e.g., when requesting a descriptive error
- * string, not enough space was allocated for the complete error message. */
-
-#define DSP_ETRUNCATED              (DSP_EBASE + 0x18)
-
-/* A parameter is invalid. */
-#define DSP_EVALUE                  (DSP_EBASE + 0x1a)
-
-/* The state of the specified object is incorrect for the requested
- * operation. */
-#define DSP_EWRONGSTATE             (DSP_EBASE + 0x1b)
-
-/* Symbol not found in the COFF file.  DSPNode_Create will return this if
- * the iAlg function table for an xDAIS socket is not found in the COFF file.
- * In this case, force the symbol to be linked into the COFF file.
- * DSPNode_Create, DSPNode_Execute, and DSPNode_Delete will return this if
- * the create, execute, or delete phase function, respectively, could not be
- * found in the COFF file. */
-#define DSP_ESYMBOL                 (DSP_EBASE + 0x1c)
-
-/* UUID not found in registry.  */
-#define DSP_EUUID                   (DSP_EBASE + 0x1d)
-
-/* Unable to read content of DCD data section ; this is typically caused by
- * improperly configured nodes. */
-#define DSP_EDCDREADSECT            (DSP_EBASE + 0x1e)
-
-/* Unable to decode DCD data section content ; this is typically caused by
- * changes to DSP/BIOS Bridge data structures. */
-#define DSP_EDCDPARSESECT           (DSP_EBASE + 0x1f)
-
-/* Unable to get pointer to DCD data section ; this is typically caused by
- * improperly configured UUIDs. */
-#define DSP_EDCDGETSECT             (DSP_EBASE + 0x20)
-
-/* Unable to load file containing DCD data section ; this is typically
- * caused by a missing COFF file. */
-#define DSP_EDCDLOADBASE            (DSP_EBASE + 0x21)
-
-/* The specified COFF file does not contain a valid node registration
- * section. */
-#define DSP_EDCDNOAUTOREGISTER      (DSP_EBASE + 0x22)
-
-/* A requested resource is not available. */
-#define DSP_ERESOURCE               (DSP_EBASE + 0x28)
-
-/* A critical error has occurred, and the DSP is being re-started. */
-#define DSP_ERESTART                (DSP_EBASE + 0x29)
-
-/* A DSP memory free operation failed. */
-#define DSP_EFREE                   (DSP_EBASE + 0x2a)
-
-/* A DSP I/O free operation failed. */
-#define DSP_EIOFREE                 (DSP_EBASE + 0x2b)
-
-/* Multiple instances are not allowed. */
-#define DSP_EMULINST                (DSP_EBASE + 0x2c)
-
-/* A specified entity was not found.  */
-#define DSP_ENOTFOUND               (DSP_EBASE + 0x2d)
-
-/* A DSP I/O resource is not available. */
-#define DSP_EOUTOFIO                (DSP_EBASE + 0x2e)
-
-/* A shared memory buffer contained in a message or stream could not be
- * mapped to the GPP client process's virtual space. */
-#define DSP_ETRANSLATE              (DSP_EBASE + 0x2f)
-
-/* File or section load write function failed to write to DSP */
-#define DSP_EFWRITE                 (DSP_EBASE + 0x31)
-
-/* Unable to find a named section in DSP executable */
-#define DSP_ENOSECT                 (DSP_EBASE + 0x32)
-
-/* Unable to open file */
-#define DSP_EFOPEN                  (DSP_EBASE + 0x33)
-
-/* Unable to read file */
-#define DSP_EFREAD                  (DSP_EBASE + 0x34)
-
-/* A non-existent memory segment identifier was specified */
-#define DSP_EOVERLAYMEMORY          (DSP_EBASE + 0x37)
-
-/* Invalid segment ID */
-#define DSP_EBADSEGID               (DSP_EBASE + 0x38)
-
-/* Invalid alignment */
-#define DSP_EALIGNMENT               (DSP_EBASE + 0x39)
-
-/* Invalid stream mode */
-#define DSP_ESTRMMODE               (DSP_EBASE + 0x3a)
-
-/* Nodes not connected */
-#define DSP_ENOTCONNECTED           (DSP_EBASE + 0x3b)
-
-/* Not shared memory */
-#define DSP_ENOTSHAREDMEM           (DSP_EBASE + 0x3c)
-
-/* Error occurred in a dynamic loader library function */
-#define DSP_EDYNLOAD                (DSP_EBASE + 0x3d)
-
-/* Device in 'sleep/suspend' mode due to DPM */
-#define DSP_EDPMSUSPEND             (DSP_EBASE + 0x3e)
-
-/* A node-specific error has occurred. */
-#define DSP_EUSER1                  (DSP_EBASE + 0x40)
-#define DSP_EUSER2                  (DSP_EBASE + 0x41)
-#define DSP_EUSER3                  (DSP_EBASE + 0x42)
-#define DSP_EUSER4                  (DSP_EBASE + 0x43)
-#define DSP_EUSER5                  (DSP_EBASE + 0x44)
-#define DSP_EUSER6                  (DSP_EBASE + 0x45)
-#define DSP_EUSER7                  (DSP_EBASE + 0x46)
-#define DSP_EUSER8                  (DSP_EBASE + 0x47)
-#define DSP_EUSER9                  (DSP_EBASE + 0x48)
-#define DSP_EUSER10                 (DSP_EBASE + 0x49)
-#define DSP_EUSER11                 (DSP_EBASE + 0x4a)
-#define DSP_EUSER12                 (DSP_EBASE + 0x4b)
-#define DSP_EUSER13                 (DSP_EBASE + 0x4c)
-#define DSP_EUSER14                 (DSP_EBASE + 0x4d)
-#define DSP_EUSER15                 (DSP_EBASE + 0x4e)
-#define DSP_EUSER16                 (DSP_EBASE + 0x4f)
-
-/* FAILURE Codes : DEV */
-#define DEV_EBASE                   (DSP_COMP_EBASE + 0x000)
-
-/* The mini-driver expected a newer version of the class driver. */
-#define DEV_E_NEWWMD                (DEV_EBASE + 0x00)
-
-/* WMD_DRV_Entry function returned a NULL function interface table. */
-#define DEV_E_NULLWMDINTF           (DEV_EBASE + 0x01)
-
-/* FAILURE Codes : LDR */
-#define LDR_EBASE                   (DSP_COMP_EBASE + 0x100)
-
-/* Insufficient memory to export class driver services. */
-#define LDR_E_NOMEMORY              (LDR_EBASE + 0x00)
-
-/* Unable to find WMD file in system directory. */
-#define LDR_E_FILEUNABLETOOPEN      (LDR_EBASE + 0x01)
-
-/* FAILURE Codes : CFG */
-#define CFG_EBASE                   (DSP_COMP_EBASE + 0x200)
-
-/* Invalid pointer passed into a configuration module function */
-#define CFG_E_INVALIDPOINTER        (CFG_EBASE + 0x00)
-
-/* Invalid device node handle passed into a configuration module function. */
-#define CFG_E_INVALIDHDEVNODE       (CFG_EBASE + 0x01)
-
-/* Unable to retrieve resource information from the registry. */
-#define CFG_E_RESOURCENOTAVAIL      (CFG_EBASE + 0x02)
-
-/* Unable to find board name key in registry. */
-#define CFG_E_INVALIDBOARDNAME      (CFG_EBASE + 0x03)
-
-/* Unable to find a device node in registry with given unit number. */
-#define CFG_E_INVALIDUNITNUM        (CFG_EBASE + 0x04)
-
-/* Insufficient buffer size */
-#define CFG_E_INSUFFICIENTBUFSIZE   (CFG_EBASE + 0x05)
-
-/* FAILURE Codes : BRD */
-#define BRD_EBASE                   (DSP_COMP_EBASE + 0x300)
-
-/* Board client does not have sufficient access rights for this operation. */
-#define BRD_E_ACCESSDENIED          (BRD_EBASE + 0x00)
-
-/* Unable to find trace buffer symbols in the DSP executable COFF file. */
-#define BRD_E_NOTRACEBUFFER         (BRD_EBASE + 0x01)
-
-/* Attempted to auto-start board, but no default DSP executable configured. */
-#define BRD_E_NOEXEC                (BRD_EBASE + 0x02)
-
-/* The operation failed because it was started from a wrong state */
-#define BRD_E_WRONGSTATE            (BRD_EBASE + 0x03)
-
-/* FAILURE Codes : COD */
-#define COD_EBASE                   (DSP_COMP_EBASE + 0x400)
-
-/* No symbol table is loaded for this board. */
-#define COD_E_NOSYMBOLSLOADED       (COD_EBASE + 0x00)
-
-/* Symbol not found in for this board. */
-#define COD_E_SYMBOLNOTFOUND        (COD_EBASE + 0x01)
-
-/* ZL DLL module is not exporting the correct function interface. */
-#define COD_E_NOZLFUNCTIONS         (COD_EBASE + 0x02)
-
-/* Unable to initialize the ZL COFF parsing module. */
-#define COD_E_ZLCREATEFAILED        (COD_EBASE + 0x03)
-
-/* Unable to open DSP executable COFF file. */
-#define COD_E_OPENFAILED            (COD_EBASE + 0x04)
-
-/* Unable to parse DSP executable COFF file. */
-#define COD_E_LOADFAILED            (COD_EBASE + 0x05)
-
-/* Unable to read DSP executable COFF file. */
-#define COD_E_READFAILED            (COD_EBASE + 0x06)
-
-/* FAILURE Codes : CHNL */
-#define CHNL_EBASE                  (DSP_COMP_EBASE + 0x500)
-
-/* Attempt to created channel manager with too many channels. */
-#define CHNL_E_MAXCHANNELS          (CHNL_EBASE + 0x00)
-
-/* No channel manager exists for this mini-driver. */
-#define CHNL_E_NOMGR                (CHNL_EBASE + 0x01)
-
-/* No free channels are available. */
-#define CHNL_E_OUTOFSTREAMS         (CHNL_EBASE + 0x02)
-
-/* Channel ID is out of range. */
-#define CHNL_E_BADCHANID            (CHNL_EBASE + 0x03)
-
-/* Channel is already in use. */
-#define CHNL_E_CHANBUSY             (CHNL_EBASE + 0x04)
-
-/* Invalid channel mode argument. */
-#define CHNL_E_BADMODE              (CHNL_EBASE + 0x05)
-
-/* dwTimeOut parameter was CHNL_IOCNOWAIT, yet no I/O completions were
- * queued. */
-#define CHNL_E_NOIOC                (CHNL_EBASE + 0x06)
-
-/* I/O has been cancelled on this channel. */
-#define CHNL_E_CANCELLED            (CHNL_EBASE + 0x07)
-
-/* End of stream was already requested on this output channel. */
-#define CHNL_E_EOS                  (CHNL_EBASE + 0x09)
-
-/* Unable to create the channel event object. */
-#define CHNL_E_CREATEEVENT          (CHNL_EBASE + 0x0A)
-
-/* Board name and unit number do not identify a valid board name. */
-#define CHNL_E_BRDID                (CHNL_EBASE + 0x0B)
-
-/* Invalid IRQ configured for this WMD for this system. */
-#define CHNL_E_INVALIDIRQ           (CHNL_EBASE + 0x0C)
-
-/* DSP word size of zero configured for this device. */
-#define CHNL_E_INVALIDWORDSIZE      (CHNL_EBASE + 0x0D)
-
-/* A zero length memory base was specified for a shared memory class driver. */
-#define CHNL_E_INVALIDMEMBASE       (CHNL_EBASE + 0x0E)
-
-/* Memory map is not configured, or unable to map physical to linear
- * address. */
-#define CHNL_E_NOMEMMAP             (CHNL_EBASE + 0x0F)
-
-/* Attempted to create a channel manager  when one already exists. */
-#define CHNL_E_MGREXISTS            (CHNL_EBASE + 0x10)
-
-/* Unable to plug channel ISR for configured IRQ. */
-#define CHNL_E_ISR                  (CHNL_EBASE + 0x11)
-
-/* No free I/O request packets are available. */
-#define CHNL_E_NOIORPS              (CHNL_EBASE + 0x12)
-
-/* Buffer size is larger than the size of physical channel. */
-#define CHNL_E_BUFSIZE              (CHNL_EBASE + 0x13)
-
-/* User cannot mark end of stream on an input channel. */
-#define CHNL_E_NOEOS                (CHNL_EBASE + 0x14)
-
-/* Wait for flush operation on an output channel timed out. */
-#define CHNL_E_WAITTIMEOUT          (CHNL_EBASE + 0x15)
-
-/* User supplied hEvent must be specified with pstrEventName attribute */
-#define CHNL_E_BADUSEREVENT         (CHNL_EBASE + 0x16)
-
-/* Illegal user event name specified */
-#define CHNL_E_USEREVENTNAME        (CHNL_EBASE + 0x17)
-
-/* Unable to prepare buffer specified */
-#define CHNL_E_PREPFAILED           (CHNL_EBASE + 0x18)
-
-/* Unable to Unprepare buffer specified */
-#define CHNL_E_UNPREPFAILED         (CHNL_EBASE + 0x19)
-
-/* FAILURE Codes : SYNC */
-#define SYNC_EBASE                  (DSP_COMP_EBASE + 0x600)
-
-/* Wait on a kernel event failed. */
-#define SYNC_E_FAIL                 (SYNC_EBASE + 0x00)
-
-/* Timeout expired while waiting for event to be signalled. */
-#define SYNC_E_TIMEOUT              (SYNC_EBASE + 0x01)
-
-/* FAILURE Codes : WMD */
-#define WMD_EBASE                   (DSP_COMP_EBASE + 0x700)
-
-/* A test of hardware assumptions or integrity failed. */
-#define WMD_E_HARDWARE              (WMD_EBASE + 0x00)
-
-/* One or more configuration parameters violated WMD hardware assumptions. */
-#define WMD_E_BADCONFIG             (WMD_EBASE + 0x01)
-
-/* Timeout occurred waiting for a response from the hardware. */
-#define WMD_E_TIMEOUT               (WMD_EBASE + 0x02)
-
-/* FAILURE Codes : REG */
-#define REG_EBASE                   (DSP_COMP_EBASE + 0x800)
-
-/* Invalid subkey parameter. */
-#define REG_E_INVALIDSUBKEY         (REG_EBASE + 0x00)
-
-/* Invalid entry parameter. */
-#define REG_E_INVALIDENTRY          (REG_EBASE + 0x01)
-
-/* No more registry values. */
-#define REG_E_NOMOREITEMS           (REG_EBASE + 0x02)
-
-/* Insufficient space to hold data in registry value. */
-#define REG_E_MOREDATA              (REG_EBASE + 0x03)
-
-/* FAILURE Codes : KFILE */
-#define KFILE_EBASE                 (DSP_COMP_EBASE + 0x900)
-
-/* Invalid file handle. */
-#define E_KFILE_INVALIDHANDLE       (KFILE_EBASE + 0x01)
-
-/* Bad file name. */
-#define E_KFILE_BADFILENAME         (KFILE_EBASE + 0x02)
-
-/* Invalid file mode. */
-#define E_KFILE_INVALIDMODE         (KFILE_EBASE + 0x03)
-
-/* No resources available. */
-#define E_KFILE_NORESOURCES         (KFILE_EBASE + 0x04)
-
-/* Invalid file buffer        . */
-#define E_KFILE_INVALIDBUFFER       (KFILE_EBASE + 0x05)
-
-/* Bad origin argument. */
-#define E_KFILE_BADORIGINFLAG       (KFILE_EBASE + 0x06)
-
-/* Invalid file offset value. */
-#define E_KFILE_INVALIDOFFSET       (KFILE_EBASE + 0x07)
-
-/* General KFILE error condition */
-#define E_KFILE_ERROR               (KFILE_EBASE + 0x08)
-
-#endif				/* ERRBASE_ */
--- a/arch/arm/plat-omap/include/bridge/gb.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * bridge/inc/gb.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== gb.h ========
- *  Generic bitmap manager.
- *
- *! Revision History
- *! ================
- */
-
-#ifndef GB_
-#define GB_
-
-#define GB_NOBITS (~0)
-#include <host_os.h>
-typedef s32 GB_BitNum;
-struct GB_TMap;
-
-/*
- *  ======== GB_clear ========
- *  Clear the bit in position bitn in the bitmap map.  Bit positions are
- *  zero based.
- */
-
-extern void GB_clear(struct GB_TMap *map, GB_BitNum bitn);
-
-/*
- *  ======== GB_create ========
- *  Create a bit map with len bits.  Initially all bits are cleared.
- */
-
-extern struct GB_TMap *GB_create(GB_BitNum len);
-
-/*
- *  ======== GB_delete ========
- *  Delete previously created bit map
- */
-
-extern void GB_delete(struct GB_TMap *map);
-
-/*
- *  ======== GB_findandset ========
- *  Finds a clear bit, sets it, and returns the position
- */
-
-extern GB_BitNum GB_findandset(struct GB_TMap *map);
-
-/*
- *  ======== GB_minclear ========
- *  GB_minclear returns the minimum clear bit position.  If no bit is
- *  clear, GB_minclear returns -1.
- */
-extern GB_BitNum GB_minclear(struct GB_TMap *map);
-
-/*
- *  ======== GB_set ========
- *  Set the bit in position bitn in the bitmap map.  Bit positions are
- *  zero based.
- */
-
-extern void GB_set(struct GB_TMap *map, GB_BitNum bitn);
-
-/*
- *  ======== GB_test ========
- *  Returns TRUE if the bit in position bitn is set in map; otherwise
- *  GB_test returns FALSE.  Bit positions are zero based.
- */
-
-extern bool GB_test(struct GB_TMap *map, GB_BitNum bitn);
-
-#endif				/*GB_ */
--- a/arch/arm/plat-omap/include/bridge/getsection.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * bridge/inc/getsection.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-#ifndef _GETSECTION_H_
-#define _GETSECTION_H_
-
-
-#include "dynamic_loader.h"
-
-/*
- * Get Section Information
- *
- * This file provides an API add-on to the dynamic loader that allows the user
- * to query section information and extract section data from dynamic load
- * modules.
- *
- * NOTE:
- * Functions in this API assume that the supplied Dynamic_Loader_Stream object
- * supports the set_file_posn method.
- */
-
-	/* opaque handle for module information */
-	typedef void *DLOAD_module_info;
-
-/*
- * Procedure DLOAD_module_open
- *
- * Parameters:
- *  module  The input stream that supplies the module image
- *  syms    Host-side malloc/free and error reporting functions.
- *          Other methods are unused.
- *
- * Effect:
- *  Reads header information from a dynamic loader module using the specified
- * stream object, and returns a handle for the module information.  This
- * handle may be used in subsequent query calls to obtain information
- * contained in the module.
- *
- * Returns:
- *  NULL if an error is encountered, otherwise a module handle for use
- * in subsequent operations.
- */
-	extern DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream
-						   *module,
-						   struct Dynamic_Loader_Sym
-						   *syms);
-
-/*
- * Procedure DLOAD_GetSectionInfo
- *
- * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
- *  sectionName Pointer to the string name of the section desired
- *  sectionInfo Address of a section info structure pointer to be initialized
- *
- * Effect:
- *  Finds the specified section in the module information, and fills in
- * the provided LDR_SECTION_INFO structure.
- *
- * Returns:
- *  TRUE for success, FALSE for section not found
- */
-	extern int DLOAD_GetSectionInfo(DLOAD_module_info minfo,
-					const char *sectionName,
-					const struct LDR_SECTION_INFO
-					** const sectionInfo);
-
-/*
- * Procedure DLOAD_GetSection
- *
- * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
- *  sectionInfo Pointer to a section info structure for the desired section
- *  sectionData Buffer to contain the section initialized data
- *
- * Effect:
- *  Copies the initialized data for the specified section into the
- * supplied buffer.
- *
- * Returns:
- *  TRUE for success, FALSE for section not found
- */
-	extern int DLOAD_GetSection(DLOAD_module_info minfo,
-				    const struct LDR_SECTION_INFO *sectionInfo,
-				    void *sectionData);
-
-/*
- * Procedure DLOAD_module_close
- *
- * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
- *
- * Effect:
- *  Releases any storage associated with the module handle.  On return,
- * the module handle is invalid.
- *
- * Returns:
- *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report(), where syms was
- * an argument to DLOAD_module_open
- */
-	extern void DLOAD_module_close(DLOAD_module_info minfo);
-
-#endif				/* _GETSECTION_H_ */
--- a/arch/arm/plat-omap/include/bridge/gh.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * bridge/inc/gh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== gh.h ========
- *
- *! Revision History
- *! ================
- */
-
-#ifndef GH_
-#define GH_
-#include <host_os.h>
-
-extern struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
-		u16(*hash) (void *, u16), bool(*match) (void *, void *),
-		void(*delete) (void *));
-extern void GH_delete(struct GH_THashTab *hashTab);
-extern void GH_exit(void);
-extern void *GH_find(struct GH_THashTab *hashTab, void *key);
-extern void GH_init(void);
-extern void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value);
-#endif				/* GH_ */
--- a/arch/arm/plat-omap/include/bridge/gs.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * bridge/inc/gs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== gs.h ========
- *  Memory allocation/release wrappers.  This module allows clients to
- *  avoid OS spacific issues related to memory allocation.  It also provides
- *  simple diagnostic capabilities to assist in the detection of memory
- *  leaks.
- *! Revision History
- *! ================
- */
-
-#ifndef GS_
-#define GS_
-
-/*
- *  ======== GS_alloc ========
- *  Alloc size bytes of space.  Returns pointer to space
- *  allocated, otherwise NULL.
- */
-extern void *GS_alloc(u32 size);
-
-/*
- *  ======== GS_exit ========
- *  Module exit.  Do not change to "#define GS_init()"; in
- *  some environments this operation must actually do some work!
- */
-extern void GS_exit(void);
-
-/*
- *  ======== GS_free ========
- *  Free space allocated by GS_alloc() or GS_calloc().
- */
-extern void GS_free(void *ptr);
-
-/*
- *  ======== GS_frees ========
- *  Free space allocated by GS_alloc() or GS_calloc() and assert that
- *  the size of the allocation is size bytes.
- */
-extern void GS_frees(void *ptr, u32 size);
-
-/*
- *  ======== GS_init ========
- *  Module initialization.  Do not change to "#define GS_init()"; in
- *  some environments this operation must actually do some work!
- */
-extern void GS_init(void);
-
-#endif				/*GS_ */
--- a/arch/arm/plat-omap/include/bridge/gt.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * bridge/inc/gt.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== gt.h ========
- *  Purpose:
- *      There are two definitions that affect which portions of trace
- *      are acutally compiled into the client: GT_TRACE and GT_ASSERT. If
- *      GT_TRACE is set to 0 then all trace statements (except for assertions)
- *      will be compiled out of the client. If GT_ASSERT is set to 0 then
- *      assertions will be compiled out of the client. GT_ASSERT can not be
- *      set to 0 unless GT_TRACE is also set to 0 (i.e. GT_TRACE == 1 implies
- *      GT_ASSERT == 1).
- *
- *! Revision History
- *! ================
- *! 02-Feb-2000 rr: Renamed this file to gtce.h. GT CLASS and trace definitions
- *!                 are WinCE Specific.
- *! 03-Jan-1997	ge	Replaced "GT_" prefix to GT_Config structure members
- *!                 to eliminate preprocessor confusion with other macros.
- */
-#include <linux/types.h>
-#ifndef GT_
-#define GT_
-
-#ifndef GT_TRACE
-#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
-#endif
-
-#include <host_os.h>
-
-#if !defined(GT_ASSERT) || GT_TRACE
-#define GT_ASSERT 1
-#endif
-
-struct GT_Config {
-	Fxn PRINTFXN;
-	Fxn PIDFXN;
-	Fxn TIDFXN;
-	Fxn ERRORFXN;
-};
-
-extern struct GT_Config *GT;
-
-struct GT_Mask {
-	char *modName;
-	u8 *flags;
-} ;
-
-/*
- *  New GT Class defenitions.
- *
- *  The following are the explanations and how it could be used in the code
- *
- *  -   GT_ENTER    On Entry to Functions
- *
- *  -   GT_1CLASS   Display level of debugging status- Object/Automatic
- *                  variables
- *  -   GT_2CLASS   ---- do ----
- *
- *  -   GT_3CLASS   ---- do ---- + It can be used(recommended) for debug
- *		    status in the ISR, IST
- *  -   GT_4CLASS   ---- do ----
- *
- *  -   GT_5CLASS   Display entry for module init/exit functions
- *
- *  -   GT_6CLASS   Warn whenever SERVICES function fails
- *
- *  -   GT_7CLASS   Warn failure of Critical failures
- *
- */
-
-#define GT_ENTER	((u8)0x01)
-#define GT_1CLASS	((u8)0x02)
-#define GT_2CLASS	((u8)0x04)
-#define GT_3CLASS	((u8)0x08)
-#define GT_4CLASS	((u8)0x10)
-#define GT_5CLASS	((u8)0x20)
-#define GT_6CLASS	((u8)0x40)
-#define GT_7CLASS	((u8)0x80)
-
-#ifdef _LINT_
-
-/* LINTLIBRARY */
-
-/*
- *  ======== GT_assert ========
- */
-/* ARGSUSED */
-void GT_assert(struct GT_Mask mask, s32 expr)
-{
-}
-
-/*
- *  ======== GT_config ========
- */
-/* ARGSUSED */
-void GT_config(struct GT_Config config)
-{
-}
-
-/*
- *  ======== GT_create ========
- */
-/* ARGSUSED */
-void GT_create(struct GT_Mask *mask, char *modName)
-{
-}
-
-/*
- *  ======== GT_curLine ========
- *  Purpose:
- *      Returns the current source code line number. Is useful for performing
- *      branch testing using trace.  For example,
- *
- *      GT_1trace(curTrace, GT_1CLASS,
- *          "in module XX_mod, executing line %u\n", GT_curLine());
- */
-/* ARGSUSED */
-u16 GT_curLine(void)
-{
-	return (u16)NULL;
-}
-
-/*
- *  ======== GT_exit ========
- */
-/* ARGSUSED */
-void GT_exit(void)
-{
-}
-
-/*
- *  ======== GT_init ========
- */
-/* ARGSUSED */
-void GT_init(void)
-{
-}
-
-/*
- *  ======== GT_query ========
- */
-/* ARGSUSED */
-bool GT_query(struct GT_Mask mask, u8 class)
-{
-	return false;
-}
-
-/*
- *  ======== GT_set ========
- *  sets trace mask according to settings
- */
-
-/* ARGSUSED */
-void GT_set(char *settings)
-{
-}
-
-/*
- *  ======== GT_setprintf ========
- *  sets printf function
- */
-
-/* ARGSUSED */
-void GT_setprintf(Fxn fxn)
-{
-}
-
-/* ARGSUSED */
-void GT_0trace(struct GT_Mask mask, u8 class, char *format)
-{
-}
-
-/* ARGSUSED */
-void GT_1trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_2trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_3trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_4trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_5trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_6trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-#else
-
-#define	GT_BOUND    26		/* 26 letters in alphabet */
-
-extern void _GT_create(struct GT_Mask *mask, char *modName);
-
-#define GT_exit()
-
-extern void GT_init(void);
-extern void _GT_set(char *str);
-extern s32 _GT_trace(struct GT_Mask *mask, char *format, ...);
-
-#if GT_ASSERT == 0
-
-#define GT_assert(mask, expr)
-#define GT_config(config)
-#define GT_configInit(config)
-#define GT_seterror(fxn)
-
-#else
-
-extern struct GT_Config _GT_params;
-
-#define GT_assert(mask, expr) \
-	(!(expr) ? \
-	    printk("assertion violation: %s, line %d\n", \
-			    __FILE__, __LINE__), NULL : NULL)
-
-#define GT_config(config)     (_GT_params = *(config))
-#define GT_configInit(config) (*(config) = _GT_params)
-#define GT_seterror(fxn)      (_GT_params.ERRORFXN = (Fxn)(fxn))
-
-#endif
-
-#if GT_TRACE == 0
-
-#define GT_curLine()                ((u16)__LINE__)
-#define GT_create(mask, modName)
-#define GT_exit()
-#define GT_init()
-#define GT_set(settings)
-#define GT_setprintf(fxn)
-
-#define GT_query(mask, class)     false
-
-#define GT_0trace(mask, class, format)
-#define GT_1trace(mask, class, format, arg1)
-#define GT_2trace(mask, class, format, arg1, arg2)
-#define GT_3trace(mask, class, format, arg1, arg2, arg3)
-#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4)
-#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5)
-#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6)
-
-#else				/* GT_TRACE == 1 */
-
-
-#define GT_create(mask, modName)    _GT_create((mask), (modName))
-#define GT_curLine()                ((u16)__LINE__)
-#define GT_set(settings)          _GT_set(settings)
-#define GT_setprintf(fxn)         (_GT_params.PRINTFXN = (Fxn)(fxn))
-
-#define GT_query(mask, class) ((*(mask).flags & (class)))
-
-#define GT_0trace(mask, class, format) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format)) : 0)
-
-#define GT_1trace(mask, class, format, arg1) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1)) : 0)
-
-#define GT_2trace(mask, class, format, arg1, arg2) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2)) : 0)
-
-#define GT_3trace(mask, class, format, arg1, arg2, arg3) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3)) : 0)
-
-#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4)) : 0)
-
-#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5)) : 0)
-
-#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5), \
-	(arg6)) : 0)
-
-#endif				/* GT_TRACE */
-
-#endif				/* _LINT_ */
-
-#endif				/* GTCE_ */
--- a/arch/arm/plat-omap/include/bridge/host_os.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * bridge/inc/host_os.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== windows.h ========
- *
- *! Revision History
- *! ================
- *! 08-Mar-2004 sb Added cacheflush.h to support Dynamic Memory Mapping feature
- *! 16-Feb-2004 sb Added headers required for consistent_alloc
- */
-
-#ifndef _HOST_OS_H_
-#define _HOST_OS_H_
-
-#include <linux/autoconf.h>
-#include <asm/system.h>
-#include <asm/atomic.h>
-#include <linux/semaphore.h>
-#include <linux/uaccess.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/syscalls.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/stddef.h>
-#include <linux/types.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/ctype.h>
-#include <linux/mm.h>
-#include <linux/device.h>
-#include <linux/vmalloc.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-#include <dbtype.h>
-
-#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
-#include <mach/clock.h>
-#ifdef CONFIG_ARCH_OMAP3430
-#include <linux/clk.h>
-#endif
-#endif
-
-#include <linux/pagemap.h>
-#include <asm/cacheflush.h>
-#include <linux/dma-mapping.h>
-
-/*  ----------------------------------- Macros */
-
-#define SEEK_SET        0	/* Seek from beginning of file.  */
-#define SEEK_CUR        1	/* Seek from current position.  */
-#define SEEK_END        2	/* Seek from end of file.  */
-
-/* TODO -- Remove, once BP defines them */
-#ifdef CONFIG_ARCH_OMAP3430
-#define INT_MAIL_MPU_IRQ        26
-#define INT_DSP_MMU_IRQ        28
-#endif
-
-#endif
--- a/arch/arm/plat-omap/include/bridge/iodefs.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * bridge/inc/iodefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== iodefs.h ========
- *  Description:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
-#ifndef IODEFS_
-#define IODEFS_
-
-#define IO_MAXIRQ   0xff	/* Arbitrarily large number. */
-
-/* IO Objects: */
-	struct IO_MGR;
-
-/* IO manager attributes: */
-	struct IO_ATTRS {
-		u8 bIRQ;	/* Channel's I/O IRQ number. */
-		bool fShared;	/* TRUE if the IRQ is shareable. */
-		u32 uWordSize;	/* DSP Word size. */
-		u32 dwSMBase;	/* Physical base address of shared memory. */
-		u32 uSMLength;	/* Size (in bytes) of shared memory. */
-	} ;
-
-#endif				/* IODEFS_ */
--- a/arch/arm/plat-omap/include/bridge/io.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * bridge/inc/io.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== io.h ========
- *  Description:
- *      The io module manages IO between CHNL and MSG.
- *
- *  Public Functions:
- *      IO_Create
- *      IO_Destroy
- *      IO_Exit
- *      IO_Init
- *      IO_OnLoaded
- *
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
-#ifndef IO_
-#define IO_
-
-#include <cfgdefs.h>
-#include <devdefs.h>
-
-#include <iodefs.h>
-
-/*
- *  ======== IO_Create ========
- *  Purpose:
- *      Create an IO manager object, responsible for managing IO between
- *      CHNL and MSG.
- *  Parameters:
- *      phChnlMgr:              Location to store a channel manager object on
- *                              output.
- *      hDevObject:             Handle to a device object.
- *      pMgrAttrs:              IO manager attributes.
- *      pMgrAttrs->bIRQ:        I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
- *  Returns:
- *      DSP_SOK:                Success;
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
- *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
- *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
- *  Requires:
- *      IO_Init() called.
- *      phIOMgr != NULL.
- *      pMgrAttrs != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr,
-				    struct DEV_OBJECT *hDevObject,
-				    IN CONST struct IO_ATTRS *pMgrAttrs);
-
-/*
- *  ======== IO_Destroy ========
- *  Purpose:
- *      Destroy the IO manager.
- *  Parameters:
- *      hIOMgr:         IOmanager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
- *  Requires:
- *      IO_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr);
-
-/*
- *  ======== IO_Exit ========
- *  Purpose:
- *      Discontinue usage of the IO module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      IO_Init() previously called.
- *  Ensures:
- *      Resources, if any acquired in IO_Init(), are freed when the last
- *      client of IO calls IO_Exit().
- */
-	extern void IO_Exit(void);
-
-/*
- *  ======== IO_Init ========
- *  Purpose:
- *      Initialize the IO module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occurred.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CHNL functions.
- */
-	extern bool IO_Init(void);
-
-/*
- *  ======== IO_OnLoaded ========
- *  Purpose:
- *      Called when a program is loaded so IO manager can update its
- *      internal state.
- *  Parameters:
- *      hIOMgr:         IOmanager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
- *  Requires:
- *      IO_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS IO_OnLoaded(struct IO_MGR *hIOMgr);
-
-#endif				/* CHNL_ */
--- a/arch/arm/plat-omap/include/bridge/io_sm.h
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- * bridge/inc/io_sm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== io_sm.h ========
- *  Description:
- *      IO dispatcher for a shared memory channel driver.
- *      Also, includes macros to simulate SHM via port io calls.
- *
- *  Public Functions:
- *      IO_Dispatch
- *      IO_DPC
- *      IO_ISR
- *      IO_RequestChnl
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 01-Mar-2004 vp: Added IVA releated functions.
- *! 23-Apr-2003 sb: Fixed mailbox deadlock
- *! 06-Feb-2003 kc  Added IO_DDMAClearChnlDesc and IO_DDZCClearChnlDesc.
- *! 21-Dec-2001 ag  Removed unused param in IO_DDMAInitChnlDesc().
- *                  Updated comments. Removed #ifdef CHNL_NOIPCINTR.
- *! 05-Nov-2001 kc  Updated IO_CALLISR macro.
- *! 01-May-2001 jeh Removed IO_RequestMsg.
- *! 29-Mar-2001 ag  Added #ifdef CHNL_NOIPCINTR.
- *! 04-Dec-2000 jeh Added IO_RequestMsg.
- *! 26-Oct-2000 jeh Added IO_GetLong, IO_SetLong, IO_ReadValueLong, and
- *!                 IO_WriteValueLong, for passing arg in SHM structure.
- *! 20-Jan-2000 ag: Updated header comments per code review.
- *! 05-Jan-2000 ag: Text format clean-up.
- *! 02-Nov-1999 ag: Updated header descriptions.
- *! 25-May-1999 jg: Removed assumption of 4 bytes / word.
- *! 12-Aug-1996 gp: Created.
- */
-
-#ifndef IOSM_
-#define IOSM_
-
-#include <_chnl_sm.h>
-#include <host_os.h>
-
-#include <iodefs.h>
-
-#define IO_INPUT            0
-#define IO_OUTPUT           1
-#define IO_SERVICE          2
-#define IO_MAXSERVICE       IO_SERVICE
-
-#define IO_MGRSIGNATURE     0x494f4D43	/* "IOGR" */
-
-#define DSPFieldAddr(type, field, base, wordsize) \
-    ((((s32)&(((type *)0)->field)) / wordsize) + (u32)base)
-
-/* Access can be different SM access word size (e.g. 16/32 bit words) */
-#define IO_SetValue(pContext, type, base, field, value) (base->field = value)
-#define IO_GetValue(pContext, type, base, field)	(base->field)
-#define IO_OrValue(pContext, type, base, field, value)  (base->field |= value)
-#define IO_AndValue(pContext, type, base, field, value) (base->field &= value)
-#define IO_SetLong(pContext, type, base, field, value)  (base->field = value)
-#define IO_GetLong(pContext, type, base, field)         (base->field)
-
-#define IO_DisableInterrupt(h)  CHNLSM_DisableInterrupt(h)
-#define IO_EnableInterrupt(h)   CHNLSM_EnableInterrupt(h)
-#define IO_InterruptDSP(h)      CHNLSM_InterruptDSP(h)
-#define IO_InterruptDSP2(h, v)  CHNLSM_InterruptDSP2(h, v)
-#define IO_CALLDPC(h)           CHNLSM_DPC(h)
-#define IO_CALLISR(h, pFlag, pwMBRegVal)   CHNLSM_ISR(h, pFlag, pwMBRegVal)
-
-/*
- *  ======== IO_CancelChnl ========
- *  Purpose:
- *      Cancel IO on a given channel.
- *  Parameters:
- *      hIOMgr:     IO Manager.
- *      ulChnl:     Index of channel to cancel IO on.
- *  Returns:
- *  Requires:
- *      Valid hIOMgr.
- *  Ensures:
- */
-	extern void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl);
-
-/*
- *  ======== IO_DPC ========
- *  Purpose:
- *      Deferred procedure call for shared memory channel driver ISR.  Carries
- *      out the dispatch of I/O.
- *  Parameters:
- *      pRefData:   Pointer to reference data registered via a call to
- *                  DPC_Create().
- *  Returns:
- *  Requires:
- *      Must not block.
- *      Must not acquire resources.
- *      All data touched must be locked in memory if running in kernel mode.
- *  Ensures:
- *      Non-preemptible (but interruptible).
- */
-	extern void IO_DPC(IN OUT void *pRefData);
-
-/*
- *  ======== IO_ISR ========
- *  Purpose:
- *      Main interrupt handler for the shared memory WMD channel manager.
- *      Calls the WMD's CHNLSM_ISR to determine if this interrupt is ours, then
- *      schedules a DPC to dispatch I/O..
- *  Parameters:
- *      pRefData:   Pointer to the channel manager object for this board.
- *                  Set in an initial call to ISR_Install().
- *  Returns:
- *      TRUE if interrupt handled; FALSE otherwise.
- *  Requires:
- *      Must be in locked memory if executing in kernel mode.
- *      Must only call functions which are in locked memory if Kernel mode.
- *      Must only call asynchronous services.
- *      Interrupts are disabled and EOI for this interrupt has been sent.
- *  Ensures:
- */
-       irqreturn_t IO_ISR(int irq, IN void *pRefData);
-/*
- *  ======== IO_RequestChnl ========
- *  Purpose:
- *      Request I/O from the DSP. Sets flags in shared memory, then interrupts
- *      the DSP.
- *  Parameters:
- *      hIOMgr:     IO manager handle.
- *      pChnl:      Ptr to the channel requesting I/O.
- *      iMode:      Mode of channel: {IO_INPUT | IO_OUTPUT}.
- *  Returns:
- *  Requires:
- *      pChnl != NULL
- *  Ensures:
- */
-	extern void IO_RequestChnl(struct IO_MGR *hIOMgr,
-				   struct CHNL_OBJECT *pChnl,
-				   u32 iMode, OUT u16 *pwMbVal);
-
-/*
- *  ======== IO_Schedule ========
- *  Purpose:
- *      Schedule DPC for IO.
- *  Parameters:
- *      pIOMgr:     Ptr to a I/O manager.
- *  Returns:
- *  Requires:
- *      pChnl != NULL
- *  Ensures:
- */
-	extern void IO_Schedule(struct IO_MGR *hIOMgr);
-
-/*
- * DSP-DMA IO functions
- */
-
-/*
- *  ======== IO_DDMAInitChnlDesc ========
- *  Purpose:
- *      Initialize DSP DMA channel descriptor.
- *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      uDDMAChnlId:    DDMA channel identifier.
- *      uNumDesc:       Number of buffer descriptors(equals # of IOReqs &
- *                      Chirps)
- *      pDsp:           Dsp address;
- *  Returns:
- *  Requires:
- *     uDDMAChnlId < DDMA_MAXDDMACHNLS
- *     uNumDesc > 0
- *     pVa != NULL
- *     pDspPa != NULL
- *
- *  Ensures:
- */
-	extern void IO_DDMAInitChnlDesc(struct IO_MGR *hIOMgr, u32 uDDMAChnlId,
-					u32 uNumDesc, void *pDsp);
-
-/*
- *  ======== IO_DDMAClearChnlDesc ========
- *  Purpose:
- *      Clear DSP DMA channel descriptor.
- *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      uDDMAChnlId:    DDMA channel identifier.
- *  Returns:
- *  Requires:
- *     uDDMAChnlId < DDMA_MAXDDMACHNLS
- *  Ensures:
- */
-	extern void IO_DDMAClearChnlDesc(struct IO_MGR *hIOMgr,
-					 u32 uDDMAChnlId);
-
-/*
- *  ======== IO_DDMARequestChnl ========
- *  Purpose:
- *      Request channel DSP-DMA from the DSP. Sets up SM descriptors and
- *      control fields in shared memory.
- *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
- *      pChnl:      Ptr to channel object
- *      pChirp:     Ptr to channel i/o request packet.
- *  Returns:
- *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
- *  Ensures:
- */
-	extern void IO_DDMARequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
-
-/*
- * Zero-copy IO functions
- */
-
-/*
- *  ======== IO_DDZCInitChnlDesc ========
- *  Purpose:
- *      Initialize ZCPY channel descriptor.
- *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
- *      uZId:       zero-copy channel identifier.
- *  Returns:
- *  Requires:
- *     uDDMAChnlId < DDMA_MAXZCPYCHNLS
- *     hIOMgr != Null
- *  Ensures:
- */
-	extern void IO_DDZCInitChnlDesc(struct IO_MGR *hIOMgr, u32 uZId);
-
-/*
- *  ======== IO_DDZCClearChnlDesc ========
- *  Purpose:
- *      Clear DSP ZC channel descriptor.
- *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      uChnlId:        ZC channel identifier.
- *  Returns:
- *  Requires:
- *      hIOMgr is valid
- *      uChnlId < DDMA_MAXZCPYCHNLS
- *  Ensures:
- */
-	extern void IO_DDZCClearChnlDesc(struct IO_MGR *hIOMgr, u32 uChnlId);
-
-/*
- *  ======== IO_DDZCRequestChnl ========
- *  Purpose:
- *      Request zero-copy channel transfer. Sets up SM descriptors and
- *      control fields in shared memory.
- *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      pChnl:          Ptr to channel object
- *      pChirp:         Ptr to channel i/o request packet.
- *  Returns:
- *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
- *  Ensures:
- */
-	extern void IO_DDZCRequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
-
-/*
- *  ======== IO_SHMsetting ========
- *  Purpose:
- *      Sets the shared memory setting
- *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      desc:             Shared memory type
- *      pArgs:          Ptr to SHM setting
- *  Returns:
- *  Requires:
- *      hIOMgr != NULL
- *      pArgs != NULL
- *  Ensures:
- */
-	extern DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr,
-					IN enum SHM_DESCTYPE desc,
-					IN void *pArgs);
-
-/*
- *  Misc functions for the CHNL_IO shared memory library:
- */
-
-/* Maximum channel bufsize that can be used. */
-	extern u32 IO_BufSize(struct IO_MGR *hIOMgr);
-
-	extern u32 IO_ReadValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr);
-
-	extern void IO_WriteValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
-
-	extern u32 IO_ReadValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr);
-
-	extern void IO_WriteValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr, u32 dwValue);
-
-	extern void IO_OrSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
-
-	extern void IO_AndSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 dwDSPAddr, u32 dwValue);
-
-	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
-
-       extern void IO_SM_init(void);
-
-/*
- *  ========PrintDspTraceBuffer ========
- *      Print DSP tracebuffer.
- */
-       extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
-                                               *hWmdContext);
-
-#endif				/* IOSM_ */
--- a/arch/arm/plat-omap/include/bridge/kfile.h
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * bridge/inc/kfile.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== kfile.h ========
- *  Purpose:
- *      Provide file I/O management capabilities.
- *
- *  Public Functions:
- *      KFILE_Close
- *      KFILE_Exit
- *      KFILE_Init
- *      KFILE_Open
- *      KFILE_Read
- *      KFILE_Seek
- *      KFILE_Tell
- *      KFILE_Write
- *
- *  Notes:
- *      The KFILE module is not like most of the other DSP/BIOS Bridge modules
- *      in that it doesn't return WSX_STATUS type values.  Rather, it's
- *      prototypes are meant to match the stdio file prototypes
- *      (ie, fopen, fclose, etc.).
- *
- *! Revision History
- *! ================
- *! 29-Oct-1999 kc:  Clean up for code review.
- *! 07-Jan-1998 cr:  Clean up for code review.
- *! 15-Aug-1997 cr:  Added E_KFILE_ERROR for general error condition.
- *! 04-Aug-1997 cr:  Added explicit CDECL descriptions.
- *! 11-Nov-1996 cr:  Implemented changes based on code review.
- *! 05-Nov-1996 cr:  Cleaned up for code review.
- *! 29-May-1996 gp:  Added requirement that size != 0 in _Write() and _Read().
- *! 28-May-1996 mg:  Changed return values for Read/Write.
- *! 14-Dec-1995 cr:  Created.
- */
-
-#ifndef KFILE_
-#define KFILE_
-
-/*
- *  Constants for KFILE_Seek.  Note that these MUST be the same definitions as
- *  those defined for fseek.
- */
-#define KFILE_SEEK_SET          0x00	/* seek from beginning of file */
-#define KFILE_SEEK_CUR          0x01	/* seek from current position */
-#define KFILE_SEEK_END          0x02	/* seek from end of file */
-
-	struct KFILE_FileObj;
-
-/*
- *  ======== KFILE_Close ========
- *  Purpose:
- *      This function closes a file's stream.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      0:                      success.
- *      E_KFILE_ERROR:          unable to close specified handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Close(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void KFILE_Exit();
-
-/*
- *  ======== KFILE_Init ========
- *  Purpose:
- *      Initializes private state of KFILE module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      KFILE initialized.
- */
-	extern bool KFILE_Init();
-
-/*
- *  ======== KFILE_Open ========
- *  Purpose:
- *      Opens a file for use.
- *  Parameters:
- *      pszFileName:    Full path to name of the file to open.
- *      pszMode:        String containing open status.  Only the first
- *                      character of the string is examined, for either
- *                      "r" (read) or "w" (write) mode.
- *  Returns:
- *      A valid file handle if success, else NULL.
- *  Requires:
- *      - KFILE initialized.
- *      - pszMode != NULL.
- *      - pszFileName != NULL.
- *  Ensures:
- */
-	extern struct KFILE_FileObj *KFILE_Open(IN CONST char *filename,
-				       IN CONST char *mode);
-
-/*
- *  ======== KFILE_Read ========
- *  Purpose:
- *      This function reads a specified number of bytes into a buffer.
- *  Parameters:
- *      pBuffer:    Array to which the file data is copied.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to read in.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects read from file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer is a valid pointer.
- *  Ensures:
- */
-	extern s32 KFILE_Read(OUT void *buffer,
-			      IN s32 size, IN s32 count,
-			      IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Seek ========
- *  Purpose:
- *      This function sets the file position indicator.  NOTE:  we don't
- *      support seeking beyond the boundaries of a file.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *      offset:     Number of bytes from the origin to move.
- *      origin:     File reference point, one of the following values:
- *                  KFILE_SEEK_SET:  Seek from beginning of file.
- *                  KFILE_SEEK_CUR:  Seek from current position.
- *                  KFILE_SEEK_END:  Seek from end of file.
- *  Returns:
- *      0: success.
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      E_KFILE_BADORIGIN:      invalid origin paramater.
- *      E_KFILE_ERROR:          general failure.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Seek(IN struct KFILE_FileObj *hFile,
-			      IN s32 offset, IN s32 origin);
-
-/*
- *  ======== KFILE_Tell ========
- *  Purpose:
- *      This function reports the current value of the position indicator.
- *  Parameters:
- *      hFile:          Handle of the file stream returned by KFILE_Open.
- *  Return value:
- *      > 0: success; returns # of bytes the position indicator is from
- *           beginning of file.
- *      E_KFILE_ERROR:          general failure.
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Tell(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Write ========
- *  Purpose:
- *      This function writes a number of objects to the stream.
- *  Parameters:
- *      pBuffer:    Array from which the file data is written.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to write out.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects written to file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer != NULL.
- *  Postcondition:
- *      The file position indicator is advanced by the number of
- *      characters written.
- */
-	extern s32 KFILE_Write(OUT void *buffer,
-			       IN s32 size,
-			       IN s32 count,
-			       IN struct KFILE_FileObj *hFile);
-
-#endif				/* KFILE_ */
--- a/arch/arm/plat-omap/include/bridge/ldr.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * bridge/inc/ldr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== ldr.h ========
- *  Purpose:
- *      Provide module loading services and symbol export services.
- *
- *  Public Functions:
- *      LDR_Exit
- *      LDR_FreeModule
- *      LDR_GetProcAddress
- *      LDR_Init
- *      LDR_LoadModule
- *
- *  Notes:
- *      This service is meant to be used by modules of the DSP/BIOS Bridge
- *       class driver.
- *
- *! Revision History:
- *! ================
- *! 22-Nov-1999 kc: Changes from code review.
- *! 12-Nov-1999 kc: Removed declaration of unused loader object.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 12-Jan-1998 cr: Cleaned up for code review.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 11-Nov-1996 cr: Cleaned up for code review.
- *! 16-May-1996 gp: Created.
- */
-
-#ifndef LDR_
-#define LDR_
-
-/* Loader objects: */
-	struct LDR_MODULE;
-
-#endif				/* LDR_ */
--- a/arch/arm/plat-omap/include/bridge/list.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * bridge/inc/list.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== list.h ========
- *  Purpose:
- *      Declarations of list management control structures and definitions
- *      of inline list management functions.
- *
- *  Public Functions:
- *      LST_Create
- *      LST_Delete
- *      LST_Exit
- *      LST_First
- *      LST_GetHead
- *      LST_InitElem
- *      LST_Init
- *      LST_InsertBefore
- *      LST_IsEmpty
- *      LST_Next
- *      LST_PutTail
- *      LST_RemoveElem
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 10-Aug-2000 ag:  Added LST_InsertBefore().
- *! 29-Oct-1999 kc:  Cleaned up for code review.
- *! 16-Aug-1997 cr:  added explicit identifiers.
- *! 10-Aug-1996 gp:  Acquired from SMM for WinSPOX v.1.1; renamed identifiers.
- *! 21-Oct-1994 dh4: Cleaned / commented for code review.
- *! 08-Jun-1994 dh4: Converted to SPM (added extern "C").
- */
-
-#ifndef LIST_
-#define LIST_
-
-#include <host_os.h>
-
-#define LST_IsEmpty(l)      (((l)->head.next == &(l)->head))
-
-	struct LST_ELEM {
-		struct LST_ELEM *next;
-		struct LST_ELEM *prev;
-		struct LST_ELEM *self;
-	} ;
-
-	struct LST_LIST {
-		struct LST_ELEM head;
-	} ;
-
-/*
- *  ======== LST_Create ========
- *  Purpose:
- *      Allocates and initializes a circular list.
- *  Details:
- *      Uses portable MEM_Calloc() function to allocate a list containing
- *      a single element and initializes that element to indicate that it
- *      is the "end of the list" (i.e., the list is empty).
- *      An empty list is indicated by the "next" pointer in the element
- *      at the head of the list pointing to the head of the list, itself.
- *  Parameters:
- *  Returns:
- *      Pointer to beginning of created list (success)
- *      NULL --> Allocation failed
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *  Notes:
- *      The created list contains a single element.  This element is the
- *      "empty" element, because its "next" and "prev" pointers point at
- *      the same location (the element itself).
- */
-	extern struct LST_LIST *LST_Create();
-
-/*
- *  ======== LST_Delete ========
- *  Purpose:
- *      Removes a list by freeing its control structure's memory space.
- *  Details:
- *      Uses portable MEM_Free() function to deallocate the memory
- *      block pointed at by the input parameter.
- *  Parameters:
- *      pList:  Pointer to list control structure of list to be deleted
- *  Returns:
- *      Void
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *  Ensures:
- *  Notes:
- *      Must ONLY be used for empty lists, because it does not walk the
- *      chain of list elements.  Calling this function on a non-empty list
- *      will cause a memory leak.
- */
-	extern void LST_Delete(IN struct LST_LIST *pList);
-
-/*
- *  ======== LST_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void LST_Exit();
-
-/*
- *  ======== LST_First ========
- *  Purpose:
- *      Returns a pointer to the first element of the list, or NULL if the list
- *      is empty.
- *  Parameters:
- *      pList:  Pointer to list control structure.
- *  Returns:
- *      Pointer to first list element, or NULL.
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *  Ensures:
- */
-	extern struct LST_ELEM *LST_First(IN struct LST_LIST *pList);
-
-/*
- *  ======== LST_GetHead ========
- *  Purpose:
- *      Pops the head off the list and returns a pointer to it.
- *  Details:
- *      If the list is empty, returns NULL.
- *      Else, removes the element at the head of the list, making the next
- *      element the head of the list.
- *      The head is removed by making the tail element of the list point its
- *      "next" pointer at the next element after the head, and by making the
- *      "prev" pointer of the next element after the head point at the tail
- *      element.  So the next element after the head becomes the new head of
- *      the list.
- *  Parameters:
- *      pList:  Pointer to list control structure of list whose head
- *              element is to be removed
- *  Returns:
- *      Pointer to element that was at the head of the list (success)
- *      NULL          No elements in list
- *  Requires:
- *      - head.self must be correctly set to &head.
- *      - LST initialized.
- *      - pList != NULL.
- *  Ensures:
- *  Notes:
- *      Because the tail of the list points forward (its "next" pointer) to
- *      the head of the list, and the head of the list points backward (its
- *      "prev" pointer) to the tail of the list, this list is circular.
- */
-	extern struct LST_ELEM *LST_GetHead(IN struct LST_LIST *pList);
-
-/*
- *  ======== LST_Init ========
- *  Purpose:
- *      Initializes private state of LST module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE otherwise.
- *  Requires:
- *  Ensures:
- *      LST initialized.
- */
-	extern bool LST_Init();
-
-/*
- *  ======== LST_InitElem ========
- *  Purpose:
- *      Initializes a list element to default (cleared) values
- *  Details:
- *  Parameters:
- *      pElem:  Pointer to list element to be reset
- *  Returns:
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *  Notes:
- *      This function must not be called to "reset" an element in the middle
- *      of a list chain -- that would break the chain.
- *
- */
-	extern void LST_InitElem(IN struct LST_ELEM *pListElem);
-
-/*
- *  ======== LST_InsertBefore ========
- *  Purpose:
- *     Insert the element before the existing element.
- *  Parameters:
- *      pList:          Pointer to list control structure.
- *      pElem:          Pointer to element in list to insert.
- *      pElemExisting:  Pointer to existing list element.
- *  Returns:
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *      - pElem != NULL.
- *      - pElemExisting != NULL.
- *  Ensures:
- */
-	extern void LST_InsertBefore(IN struct LST_LIST *pList,
-				     IN struct LST_ELEM *pElem,
-				     IN struct LST_ELEM *pElemExisting);
-
-/*
- *  ======== LST_Next ========
- *  Purpose:
- *      Returns a pointer to the next element of the list, or NULL if the next
- *      element is the head of the list or the list is empty.
- *  Parameters:
- *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
- *  Returns:
- *      Pointer to list element, or NULL.
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *      - pCurElem != NULL.
- *  Ensures:
- */
-	extern struct LST_ELEM *LST_Next(IN struct LST_LIST *pList,
-					 IN struct LST_ELEM *pCurElem);
-
-/*
- *  ======== LST_PutTail ========
- *  Purpose:
- *      Adds the specified element to the tail of the list
- *  Details:
- *      Sets new element's "prev" pointer to the address previously held by
- *      the head element's prev pointer.  This is the previous tail member of
- *      the list.
- *      Sets the new head's prev pointer to the address of the element.
- *      Sets next pointer of the previous tail member of the list to point to
- *      the new element (rather than the head, which it had been pointing at).
- *      Sets new element's next pointer to the address of the head element.
- *      Sets head's prev pointer to the address of the new element.
- *  Parameters:
- *      pList:  Pointer to list control structure to which *pElem will be
- *              added
- *      pElem:  Pointer to list element to be added
- *  Returns:
- *      Void
- *  Requires:
- *      *pElem and *pList must both exist.
- *      pElem->self = pElem before pElem is passed to this function.
- *      LST initialized.
- *  Ensures:
- *  Notes:
- *      Because the tail is always "just before" the head of the list (the
- *      tail's "next" pointer points at the head of the list, and the head's
- *      "prev" pointer points at the tail of the list), the list is circular.
- *  Warning: if pElem->self is not set beforehand, LST_GetHead() will
- *      return an erroneous pointer when it is called for this element.
- */
-	extern void LST_PutTail(IN struct LST_LIST *pList,
-				IN struct LST_ELEM *pListElem);
-
-/*
- *  ======== LST_RemoveElem ========
- *  Purpose:
- *      Removes (unlinks) the given element from the list, if the list is not
- *      empty.  Does not free the list element.
- *  Parameters:
- *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
- *  Returns:
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *      - pCurElem != NULL.
- *  Ensures:
- */
-extern void LST_RemoveElem(IN struct LST_LIST *pList,
-			   IN struct LST_ELEM *pCurElem);
-
-#endif				/* LIST_ */
--- a/arch/arm/plat-omap/include/bridge/mbx_sh.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * bridge/inc/mbx_sh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== mbx_sh.h ========
- *  Definitions for shared mailbox cmd/data values.(used on both
- *     the GPP and DSP sides).
- *
- *  Bridge usage of OMAP mailbox 1 is determined by the "class" of the
- *     mailbox interrupt's cmd value received. The class value are defined
- *     as a bit (10 thru 15) being set.
- *
- *  Note: Only 16 bits of each  is used. Other 16 bit data reg available.
- *
- *   16 bit Mbx bit defns:
- *
- * A). Exception/Error handling (Module DEH) : class = 0.
- *
- *    15         10                  0
- *   ---------------------------------
- *   |0|0|0|0|0|0|x|x|x|x|x|x|x|x|x|x|
- *   ---------------------------------
- *   |  (class)  | (module specific) |
- *
- *
- *
- * B: DSP-DMA link driver channels (DDMA) : class = 1.
- *
- *    15         10                  0
- *   ---------------------------------
- *   |0|0|0|0|0|1|b|b|b|b|b|c|c|c|c|c|
- *   ---------------------------------
- *   |  (class)  | (module specific) |
- *
- *   where b -> buffer index  (32 DDMA buffers/chnl max)
- *         c -> channel Id    (32 DDMA chnls max)
- *
- *
- *
- *
- * C: Proc-copy link driver channels (PCPY) : class = 2.
- *
- *    15         10                  0
- *   ---------------------------------
- *   |0|0|0|0|1|0|x|x|x|x|x|x|x|x|x|x|
- *   ---------------------------------
- *   |  (class)  | (module specific) |
- *
- *
- * D: Zero-copy link driver channels (DDZC) : class = 4.
- *
- *    15         10                  0
- *   ---------------------------------
- *   |0|0|0|1|0|0|x|x|x|x|x|c|c|c|c|c|
- *   ---------------------------------
- *   |  (class)  | (module specific) |
- *
- *   where x -> not used
- *         c -> channel Id    (32 ZCPY chnls max)
- *
- *
- * E: Power management : class = 8.
- *
- *    15         10                  0
- *   ---------------------------------
- *   |0|0|1|0|0|0|x|x|x|x|x|c|c|c|c|c|
-
- * 	0010 00xx xxxc cccc
- *	0010 00nn pppp qqqq
- *	nn:
- *	00 = reserved
- *	01 = pwr state change
- *	10 = opp pre-change
- *	11 = opp post-change
- *
- *	if nn = pwr state change:
- *	pppp = don't care
- *	qqqq:
- *	0010 = hibernate
- *	0010 0001 0000 0010
- *	0110 = retention
- *	0010 0001 0000 0110
- *	others reserved
- *
- *	if nn = opp pre-change:
- *	pppp = current opp
- *	qqqq = next opp
- *
- *	if nn = opp post-change:
- *	pppp = prev opp
- *	qqqq = current opp
- *
- *   ---------------------------------
- *   |  (class)  | (module specific) |
- *
- *   where x -> not used
- *         c -> Power management command
- *
- *
- *
- *! Revision History:
- *! ================
- *! 19-Sep-2002 mr  Added DEH reset const
- *! 24-Apr-2002 sg  Added more PM commands.
- *! 04-Mar-2002 gv  Added MBX_PM_CLASS
- *! 22-Jan-2002 ag  Bug fix in MBX_SETZCPYVAL(x) macro.
- *! 21-Dec-2001 ag  Added bit masks defns.
- *! 17-Dec-2001 ag: created.
- */
-
-#ifndef _MBX_SH_H
-#define _MBX_SH_H
-
-#define MBX_CLASS_MSK      0xFC00	/* Class bits are 10 thru 15 */
-#define MBX_VALUE_MSK      0x03FF	/* Value is 0 thru 9 */
-
-#define MBX_DEH_CLASS      0x0000	/* DEH owns Mbx INTR */
-#define MBX_DDMA_CLASS     0x0400	/* DSP-DMA link drvr chnls owns INTR */
-#define MBX_PCPY_CLASS     0x0800	/* PROC-COPY  " */
-#define MBX_ZCPY_CLASS     0x1000	/* ZERO-COPY  " */
-#define MBX_PM_CLASS       0x2000	/* Power Management */
-#define MBX_DBG_CLASS      0x4000	/* For debugging purpose */
-
-/*
- * Exception Handler codes
- * Magic code used to determine if DSP signaled exception.
- */
-#define MBX_DEH_BASE        0x0
-#define MBX_DEH_USERS_BASE  0x100	/* 256 */
-#define MBX_DEH_LIMIT       0x3FF	/* 1023 */
-#define MBX_DEH_RESET       0x101	/* DSP RESET (DEH) */
-#define MBX_DEH_EMMU        0X103 /*DSP MMU FAULT RECOVERY*/
-
-/*
- *  Link driver command/status codes.
- */
-/* DSP-DMA */
-#define MBX_DDMA_NUMCHNLBITS 5	/* # chnl Id: # bits available */
-#define MBX_DDMA_CHNLSHIFT   0	/* # of bits to shift */
-#define MBX_DDMA_CHNLMSK     0x01F	/* bits 0 thru 4 */
-
-#define MBX_DDMA_NUMBUFBITS  5	/* buffer index: # of bits avail */
-#define MBX_DDMA_BUFSHIFT    (MBX_DDMA_NUMCHNLBITS + MBX_DDMA_CHNLSHIFT)
-#define MBX_DDMA_BUFMSK      0x3E0	/* bits 5 thru 9 */
-
-/* Zero-Copy */
-#define MBX_ZCPY_NUMCHNLBITS 5	/* # chnl Id: # bits available */
-#define MBX_ZCPY_CHNLSHIFT   0	/* # of bits to shift */
-#define MBX_ZCPY_CHNLMSK     0x01F	/* bits 0 thru 4 */
-
-/*  Power Management Commands */
-#define MBX_PM_DSPIDLE                  (MBX_PM_CLASS + 0x0)
-#define MBX_PM_DSPWAKEUP                (MBX_PM_CLASS + 0x1)
-#define MBX_PM_EMERGENCYSLEEP           (MBX_PM_CLASS + 0x2)
-#define MBX_PM_SLEEPUNTILRESTART        (MBX_PM_CLASS + 0x3)
-#define MBX_PM_DSPGLOBALIDLE_OFF        (MBX_PM_CLASS + 0x4)
-#define MBX_PM_DSPGLOBALIDLE_ON         (MBX_PM_CLASS + 0x5)
-#define MBX_PM_SETPOINT_PRENOTIFY       (MBX_PM_CLASS + 0x6)
-#define MBX_PM_SETPOINT_POSTNOTIFY      (MBX_PM_CLASS + 0x7)
-#define MBX_PM_DSPRETN                  (MBX_PM_CLASS + 0x8)
-#define MBX_PM_DSPRETENTION        (MBX_PM_CLASS + 0x8)
-#define MBX_PM_DSPHIBERNATE        (MBX_PM_CLASS + 0x9)
-#define MBX_PM_HIBERNATE_EN        (MBX_PM_CLASS + 0xA)
-#define MBX_PM_OPP_REQ                  (MBX_PM_CLASS + 0xB)
-#define MBX_PM_OPP_CHG                  (MBX_PM_CLASS + 0xC)
-
-#define MBX_PM_TYPE_MASK 0x0300
-#define MBX_PM_TYPE_PWR_CHNG 0x0100
-#define MBX_PM_TYPE_OPP_PRECHNG 0x0200
-#define MBX_PM_TYPE_OPP_POSTCHNG 0x0300
-#define MBX_PM_TYPE_OPP_MASK 0x0300
-#define MBX_PM_OPP_PRECHNG (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG)
-/* DSP to MPU */
-#define MBX_PM_OPP_CHNG(OPP) (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG | (OPP))
-#define MBX_PM_RET (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0006)
-#define MBX_PM_HIB (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0002)
-#define MBX_PM_OPP_1 0
-#define MBX_PM_OPP_2 1
-#define MBX_PM_OPP_3 2
-#define MBX_PM_OPP_4 3
-#define MBX_OLDOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
-#define MBX_NEWOPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
-#define MBX_PREVOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
-#define MBX_CUROPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
-
-/* Bridge Debug Commands */
-#define MBX_DBG_SYSPRINTF       (MBX_DBG_CLASS + 0x0)
-
-/*
- * Useful macros
- */
-/* DSP-DMA channel */
-#define MBX_SETDDMAVAL(x, y)  (MBX_DDMA_CLASS | (x << MBX_DDMA_BUFSHIFT) | \
-	(y << MBX_DDMA_CHNLSHIFT))
-
-/* Zero-Copy channel */
-#define MBX_SETZCPYVAL(x)  (MBX_ZCPY_CLASS | (x << MBX_ZCPY_CHNLSHIFT))
-
-#endif				/* _MBX_SH_H */
--- a/arch/arm/plat-omap/include/bridge/memdefs.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * bridge/inc/memdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== memdefs.h ========
- *  Purpose:
- *      Global MEM constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 28-Aug-2001 ag:  Added MEM_[SET][GET]VIRTUALSEGID.
- *! 10-Aug-1999 kc:  Based on wsx-c18.
- *! 15-Nov-1996 gp:  Renamed from wsxmem.h and moved to kwinos.
- *! 21-Aug-1996 cr:  Created from mem.h.
- */
-
-#ifndef MEMDEFS_
-#define MEMDEFS_
-
-/* Memory Pool Attributes: */
-	enum MEM_POOLATTRS {
-		MEM_PAGED = 0,
-		MEM_NONPAGED = 1,
-		MEM_LARGEVIRTMEM = 2
-	} ;
-
-/*
- *  MEM_VIRTUALSEGID is used by Node & Strm to access virtual address space in
- *  the correct client process context.
- */
-#define MEM_SETVIRTUALSEGID     0x10000000
-#define MEM_GETVIRTUALSEGID     0x20000000
-#define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
-
-#define TO_VIRTUAL_UNCACHED(x) x
-#define INTREG_TO_VIRTUAL_UNCACHED(x) x
-
-#endif				/* MEMDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/mem.h
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * bridge/inc/mem.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== mem.h ========
- *  Purpose:
- *      Memory management and address mapping services for the DSP/BIOS Bridge
- *      class driver and mini-driver.
- *
- *  Public Functions:
- *      MEM_Alloc
- *      MEM_AllocObject
- *      MEM_AllocPhysMem
- *      MEM_Calloc
- *      MEM_Exit
- *      MEM_FlushCache
- *      MEM_Free
- *      MEM_FreeObject
- *      MEM_FreePhysMem
- *      MEM_GetNumPages
- *      MEM_Init
- *      MEM_IsValidHandle
- *      MEM_LinearAddress
- *      MEM_PageLock
- *      MEM_PageUnlock
- *      MEM_UnMapLinearAddress
- *      MEM_VirtualToPhysical
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
- *! 01-Sep-2001 ag: Cleaned up notes for MEM_LinearAddress() does not
- *!                   require phys address to be page aligned!
- *! 02-Dec-1999 rr: stdwin.h included for retail build
- *! 12-Nov-1999 kc: Added warning about use of MEM_LinearAddress.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Aug-1999 kc: Based on wsx-c18.
- *! 07-Jan-1998 gp: Added MEM_AllocUMB and MEM_UMBFree for User Mapped Buffers
- *!                 used by WMD_CHNL.
- *! 23-Dec-1997 cr: Code review cleanup, removed dead Ring 3 code.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 01-Nov-1996 gp: Updated based on code review.
- *! 04-Sep-1996 gp: Added MEM_PageLock() and MEM_PageUnlock() services.
- *! 14-Aug-1996 mg: Added MEM_GetPhysAddr() and MEM_GetNumPages()
- *! 25-Jul-1996 gp: Added MEM_IsValidHandle() macro.
- *! 10-May-1996 gp: Added MEM_Calloc().
- *! 25-Apr-1996 gp: Added MEM_PhysicalAddress()
- *! 17-Apr-1996 gp: Added MEM_Exit function; updated to latest naming standard.
- *! 08-Apr-1996 gp: Created.
- */
-
-#ifndef MEM_
-#define MEM_
-
-#include <host_os.h>
-#include <memdefs.h>
-
-/*
- *  ======== MEM_Alloc ========
- *  Purpose:
- *      Allocate memory from the paged or non-paged pools.
- *  Parameters:
- *      cBytes: Number of bytes to allocate.
- *      type:   Type of memory to allocate; one of:
- *              MEM_PAGED: Allocate from pageable memory.
- *              MEM_NONPAGED: Allocate from page locked memory.
- *  Returns:
- *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
- *      not one of MEM_PAGED or MEM_NONPAGED.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *      The returned pointer, if not NULL, points to a valid memory block of
- *      the size requested.
- */
-	extern void *MEM_Alloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
-
-/*
- *  ======== MEM_AllocObject ========
- *  Purpose:
- *      Allocate an object, and set it's signature.
- *  Parameters:
- *      pObj:       Pointer to the new object.
- *      Obj:        Type of the object to allocate.
- *      Signature:  Magic field value.  Must be non-zero.
- *  Returns:
- *  Requires:
- *      Same requirements as MEM_Calloc(); and
- *      The object structure has a dwSignature field.  The compiler ensures
- *      this requirement.
- *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
- */
-#define MEM_AllocObject(pObj, Obj, Signature)           \
-{                                                       \
-    pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);       \
-    if (pObj) {                                         \
-	pObj->dwSignature = Signature;                  \
-    }                                                   \
-}
-
-/*  ======== MEM_AllocPhysMem ========
- *  Purpose:
- *      Allocate physically contiguous, uncached memory
- *  Parameters:
- *      cBytes:     Number of bytes to allocate.
- *      ulAlign:    Alignment Mask.
- *      pPhysicalAddress: Physical address of allocated memory.
- *  Returns:
- *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, or if cBytes == 0.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *      The returned pointer, if not NULL, points to a valid memory block of
- *      the size requested.  Returned physical address refers to physical
- *      location of memory.
- */
-	extern void *MEM_AllocPhysMem(IN u32 cBytes,
-				      IN u32 ulAlign,
-				      OUT u32 *pPhysicalAddress);
-
-/*
- *  ======== MEM_Calloc ========
- *  Purpose:
- *      Allocate zero-initialized memory from the paged or non-paged pools.
- *  Parameters:
- *      cBytes: Number of bytes to allocate.
- *      type:   Type of memory to allocate; one of:
- *              MEM_PAGED:   Allocate from pageable memory.
- *              MEM_NONPAGED: Allocate from page locked memory.
- *  Returns:
- *      Pointer to a block of zeroed memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
- *      not one of MEM_PAGED or MEM_NONPAGED.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *      The returned pointer, if not NULL, points to a valid memory block
- *      of the size requested.
- */
-	extern void *MEM_Calloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
-
-/*
- *  ======== MEM_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      MEM is initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void MEM_Exit();
-
-/*
- *  ======== MEM_FlushCache ========
- *  Purpose:
- *      Performs system cache sync with discard
- *  Parameters:
- *      pMemBuf:    Pointer to memory region to be flushed.
- *      pMemBuf:    Size of the memory region to be flushed.
- *  Returns:
- *  Requires:
- *      MEM is initialized.
- *  Ensures:
- *      Cache is synchronized
- */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
-
-/*
- *  ======== MEM_Free ========
- *  Purpose:
- *      Free the given block of system memory.
- *  Parameters:
- *      pMemBuf:    Pointer to memory allocated by MEM_Calloc/Alloc().
- *  Returns:
- *  Requires:
- *      MEM initialized.
- *      pMemBuf is a valid memory address returned by MEM_Calloc/Alloc().
- *  Ensures:
- *      pMemBuf is no longer a valid pointer to memory.
- */
-	extern void MEM_Free(IN void *pMemBuf);
-
-/*
- *  ======== MEM_FreePhysMem ========
- *  Purpose:
- *      Free the given block of physically contiguous memory.
- *  Parameters:
- *      pVirtualAddress:  Pointer to virtual memory region allocated
- *      by MEM_AllocPhysMem().
- *      pPhysicalAddress:  Pointer to physical memory region  allocated
- *      by MEM_AllocPhysMem().
- *      cBytes:  Size of the memory region allocated by MEM_AllocPhysMem().
- *  Returns:
- *  Requires:
- *      MEM initialized.
- *      pVirtualAddress is a valid memory address returned by
- *          MEM_AllocPhysMem()
- *  Ensures:
- *      pVirtualAddress is no longer a valid pointer to memory.
- */
-	extern void MEM_FreePhysMem(void *pVirtualAddress,
-				    u32 pPhysicalAddress, u32 cBytes);
-
-/*
- *  ======== MEM_FreeObject ========
- *  Purpose:
- *      Utility macro to invalidate an object's signature, and deallocate it.
- *  Parameters:
- *      pObj:   Pointer to the object to free.
- *  Returns:
- *  Requires:
- *      Same requirements as MEM_Free().
- *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will fail for this object.
- */
-#define MEM_FreeObject(pObj)    \
-{                               \
-    pObj->dwSignature = 0x00;   \
-    MEM_Free(pObj);             \
-}
-
-/*
- *  ======== MEM_GetNumPages ========
- *  Purpose:
- *      Calculate the number of pages corresponding to the supplied buffer.
- *  Parameters:
- *      pAddr:  Linear (virtual) address of the buffer.
- *      cBytes: Number of bytes in the buffer.
- *  Returns:
- *      Number of pages.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *      If cBytes > 0, number of pages returned > 0.
- */
-	extern s32 MEM_GetNumPages(IN void *pAddr, IN u32 cBytes);
-
-/*
- *  ======== MEM_Init ========
- *  Purpose:
- *      Initializes private state of MEM module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      MEM initialized.
- */
-	extern bool MEM_Init();
-
-/*
- *  ======== MEM_IsValidHandle ========
- *  Purpose:
- *      Validate the object handle.
- *  Parameters:
- *      hObj:   Handle to object created with MEM_AllocObject().
- *      Sig:    Expected signature u32.
- *  Returns:
- *      TRUE if handle is valid; FALSE otherwise.
- *  Requires:
- *      The object structure has a dwSignature field. Ensured by compiler.
- *  Ensures:
- */
-#define MEM_IsValidHandle(hObj, Sig)                \
-     ((hObj != NULL) && (hObj->dwSignature == Sig))
-
-/*
- *  ======== MEM_LinearAddress ========
- *  Purpose:
- *      Get the linear address corresponding to the given physical address.
- *  Parameters:
- *      pPhysAddr:  Physical address to be mapped.
- *      cBytes:     Number of bytes in physical range to map.
- *  Returns:
- *      The corresponding linear address, or NULL if unsuccessful.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *  Notes:
- *      If valid linear address is returned, be sure to call
- *      MEM_UnmapLinearAddress().
- */
-#define MEM_LinearAddress(pPhyAddr, cBytes) pPhyAddr
-
-/*
- *  ======== MEM_UnmapLinearAddress ========
- *  Purpose:
- *      Unmap the linear address mapped in MEM_LinearAddress.
- *  Parameters:
- *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LinearAddress()).
- *  Returns:
- *  Requires:
- *      - MEM initialized.
- *      - pBaseAddr is a valid linear address mapped in MEM_LinearAddress.
- *  Ensures:
- *      - pBaseAddr no longer points to a valid linear address.
- */
-#define MEM_UnmapLinearAddress(pBaseAddr)
-
-/*
- *  ======== MEM_ExtPhysPoolInit ========
- *  Purpose:
- *      Uses the physical memory chunk passed for internal consitent memory
- *      allocations.
- *      physical address based on the page frame address.
- *  Parameters:
- *      poolPhysBase  starting address of the physical memory pool.
- *      poolSize      size of the physical memory pool.
- *  Returns:
- *      none.
- *  Requires:
- *      - MEM initialized.
- *      - valid physical address for the base and size > 0
- */
-	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
-					IN u32 poolSize);
-
-#endif				/* MEM_ */
--- a/arch/arm/plat-omap/include/bridge/mgr.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * bridge/inc/mgr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== mgr.h ========
- *  Description:
- *      This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      MGR_Create
- *      MGR_Destroy
- *      MGR_EnumNodeInfo
- *      MGR_EnumProcessorInfo
- *      MGR_Exit
- *      MGR_GetDCDHandle
- *      MGR_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc: Removed legacy PERF definitions.
- *! 11-Jul-2001 jeh Added CFG_HDEVNODE parameter to MGR_Create().
- *! 22-Nov-2000 kc: Added MGR_GetPerfData for acquiring PERF stats.
- *! 03-Nov-2000 rr: Added MGR_GetDCDHandle. Modified after code review.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 14-Aug-2000 rr: Cleaned up.
- *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types).
- *! 20-Jun-2000 rr: Created.
- */
-
-#ifndef MGR_
-#define MGR_
-
-#include <mgrpriv.h>
-
-#define MAX_EVENTS 32
-
-/*
- *  ======== MGR_WaitForBridgeEvents ========
- *  Purpose:
- *      Block on any Bridge event(s)
- *  Parameters:
- *      aNotifications  : array of pointers to notification objects.
- *      uCount          : number of elements in above array
- *      puIndex         : index of signaled event object
- *      uTimeout        : timeout interval in milliseocnds
- *  Returns:
- *      DSP_SOK         : Success.
- *      DSP_ETIMEOUT    : Wait timed out. *puIndex is undetermined.
- *  Details:
- */
-
-	DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION
-					   **aNotifications,
-					   u32 uCount, OUT u32 *puIndex,
-					   u32 uTimeout);
-
-/*
- *  ======== MGR_Create ========
- *  Purpose:
- *      Creates the Manager Object. This is done during the driver loading.
- *      There is only one Manager Object in the DSP/BIOS Bridge.
- *  Parameters:
- *      phMgrObject:    Location to store created MGR Object handle.
- *      hDevNode:       Device object as known to Windows system.
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EMEMORY:    Failed to Create the Object
- *      DSP_EFAIL:      General Failure
- *  Requires:
- *      MGR Initialized (cRefs > 0 )
- *      phMgrObject != NULL.
- *  Ensures:
- *      DSP_SOK:        *phMgrObject is a valid MGR interface to the device.
- *                      MGR Object stores the DCD Manager Handle.
- *                      MGR Object stored in the Regsitry.
- *      !DSP_SOK:       MGR Object not created
- *  Details:
- *      DCD Dll is loaded and MGR Object stores the handle of the DLL.
- */
-	extern DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **hMgrObject,
-				     struct CFG_DEVNODE *hDevNode);
-
-/*
- *  ======== MGR_Destroy ========
- *  Purpose:
- *      Destroys the MGR object. Called upon driver unloading.
- *  Parameters:
- *      hMgrObject:     Handle to Manager object .
- *  Returns:
- *      DSP_SOK:        Success.
- *                      DCD Manager freed; MGR Object destroyed;
- *                      MGR Object deleted from the Registry.
- *      DSP_EFAIL:      Failed to destroy MGR Object
- *  Requires:
- *      MGR Initialized (cRefs > 0 )
- *      hMgrObject is a valid MGR handle .
- *  Ensures:
- *      DSP_SOK:        MGR Object destroyed and hMgrObject is Invalid MGR
- *                      Handle.
- */
-	extern DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject);
-
-/*
- *  ======== MGR_EnumNodeInfo ========
- *  Purpose:
- *      Enumerate and get configuration information about nodes configured
- *      in the node database.
- *  Parameters:
- *      uNode:              The node index (base 0).
- *      pNDBProps:          Ptr to the DSP_NDBPROPS structure for output.
- *      uNDBPropsSize:      Size of the DSP_NDBPROPS structure.
- *      puNumNodes:         Location where the number of nodes configured
- *                          in the database will be returned.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uNode is > than the number of nodes.
- *                          configutred in the system
- *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
- *                              the number of nodes configured or in the
- *                              the properties of the enumerated nodes.
- *      DSP_EFAIL:          Failed to querry the Node Data Base
- *  Requires:
- *      pNDBPROPS is not null
- *      uNDBPropsSize >= sizeof(DSP_NDBPROPS)
- *      puNumNodes is not null
- *      MGR Initialized (cRefs > 0 )
- *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumNodes > 0 OR
- *      DSP_FAILED  && *puNumNodes == 0.
- *  Details:
- */
-	extern DSP_STATUS MGR_EnumNodeInfo(u32 uNode,
-					   OUT struct DSP_NDBPROPS *pNDBProps,
-					   u32 uNDBPropsSize,
-					   OUT u32 *puNumNodes);
-
-/*
- *  ======== MGR_EnumProcessorInfo ========
- *  Purpose:
- *      Enumerate and get configuration information about available DSP
- *      processors
- *  Parameters:
- *      uProcessor:         The processor index (zero-based).
- *      pProcessorInfo:     Ptr to the DSP_PROCESSORINFO structure .
- *      uProcessorInfoSize: Size of DSP_PROCESSORINFO structure.
- *      puNumProcs:         Location where the number of DSPs configured
- *                          in the database will be returned
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uProcessor is > than the number of
- *                          DSP Processors in the system.
- *      DSP_EFAIL:          Failed to querry the Node Data Base
- *  Requires:
- *      pProcessorInfo is not null
- *      puNumProcs is not null
- *      uProcessorInfoSize >= sizeof(DSP_PROCESSORINFO)
- *      MGR Initialized (cRefs > 0 )
- *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumProcs > 0 OR
- *      DSP_FAILED && *puNumProcs == 0.
- *  Details:
- */
-	extern DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
-						OUT struct DSP_PROCESSORINFO *
-						pProcessorInfo,
-						u32 uProcessorInfoSize,
-						OUT u32 *puNumProcs);
-/*
- *  ======== MGR_Exit ========
- *  Purpose:
- *      Decrement reference count, and free resources when reference count is
- *      0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      MGR is initialized.
- *  Ensures:
- *      When reference count == 0, MGR's private resources are freed.
- */
-       extern void MGR_Exit();
-
-/*
- *  ======== MGR_GetDCDHandle ========
- *  Purpose:
- *      Retrieves the MGR handle. Accessor Function
- *  Parameters:
- *      hMGRHandle:     Handle to the Manager Object
- *      phDCDHandle:    Ptr to receive the DCD Handle.
- *  Returns:
- *      DSP_SOK:        Sucess
- *      DSP_EFAIL:      Failure to get the Handle
- *  Requires:
- *      MGR is initialized.
- *      phDCDHandle != NULL
- *  Ensures:
- *      DSP_SOK and *phDCDHandle != NULL ||
- *      DSP_EFAIL and *phDCDHandle == NULL
- */
-       extern DSP_STATUS MGR_GetDCDHandle(IN struct MGR_OBJECT
-						 *hMGRHandle,
-						 OUT u32 *phDCDHandle);
-
-/*
- *  ======== MGR_Init ========
- *  Purpose:
- *      Initialize MGR's private state, keeping a reference count on each
- *      call. Intializes the DCD.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      TRUE: A requirement for the other public MGR functions.
- */
-       extern bool MGR_Init();
-
-#endif				/* MGR_ */
--- a/arch/arm/plat-omap/include/bridge/mgrpriv.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * bridge/inc/mgrpriv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== mgrpriv.h ========
- *  Description:
- *      Global MGR constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 29-July-2001 ag: added MGR_PROCESSOREXTINFO.
- *! 05-July-2000 rr: Created
- */
-
-#ifndef MGRPRIV_
-#define MGRPRIV_
-
-/*
- * OMAP1510 specific
- */
-#define MGR_MAXTLBENTRIES  32
-
-/* RM MGR Object */
-	struct MGR_OBJECT;
-
-	struct MGR_TLBENTRY {
-		u32 ulDspVirt;	/* DSP virtual address */
-		u32 ulGppPhys;	/* GPP physical address */
-	} ;
-
-/*
- *  The DSP_PROCESSOREXTINFO structure describes additional extended
- *  capabilities of a DSP processor not exposed to user.
- */
-	struct MGR_PROCESSOREXTINFO {
-		struct DSP_PROCESSORINFO tyBasic;    /* user processor info */
-		/* private dsp mmu entries */
-		struct MGR_TLBENTRY tyTlb[MGR_MAXTLBENTRIES];
-	} ;
-
-#endif				/* MGRPRIV_ */
--- a/arch/arm/plat-omap/include/bridge/msgdefs.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * bridge/inc/msgdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== msgdefs.h ========
- *  Description:
- *      Global MSG constants and types.
- *
- *! Revision History
- *! ================
- *! 09-May-2001 jeh Removed MSG_TODSP, MSG_FROMDSP.
- *! 17-Nov-2000 jeh Added MSGMGR_SIGNATURE.
- *! 12-Sep-2000 jeh Created.
- */
-
-#ifndef MSGDEFS_
-#define MSGDEFS_
-
-#define MSGMGR_SIGNATURE    0x4d47534d	/* "MGSM" */
-
-/* MSG Objects: */
-	struct MSG_MGR;
-	struct MSG_QUEUE;
-
-/* Function prototype for callback to be called on RMS_EXIT message received */
-       typedef void(*MSG_ONEXIT) (HANDLE h, s32 nStatus);
-
-#endif				/* MSGDEFS_ */
-
--- a/arch/arm/plat-omap/include/bridge/msg.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * bridge/inc/msg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== msg.h ========
- *  Description:
- *      DSP/BIOS Bridge MSG Module.
- *
- *  Public Functions:
- *      MSG_Create
- *      MSG_Delete
- *      MSG_Exit
- *      MSG_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 17-Nov-2000 jeh     Removed MSG_Get, MSG_Put, MSG_CreateQueue,
- *!                     MSG_DeleteQueue, and MSG_RegisterNotify, since these
- *!                     are now part of mini-driver.
- *! 12-Sep-2000 jeh     Created.
- */
-
-#ifndef MSG_
-#define MSG_
-
-#include <devdefs.h>
-#include <msgdefs.h>
-
-/*
- *  ======== MSG_Create ========
- *  Purpose:
- *      Create an object to manage message queues. Only one of these objects
- *      can exist per device object. The MSG manager must be created before
- *      the IO Manager.
- *  Parameters:
- *      phMsgMgr:           Location to store MSG manager handle on output.
- *      hDevObject:         The device object.
- *      msgCallback:        Called whenever an RMS_EXIT message is received.
- *  Returns:
- *  Requires:
- *      MSG_Init() called.
- *      phMsgMgr != NULL.
- *      hDevObject != NULL.
- *      msgCallback != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     MSG_ONEXIT msgCallback);
-
-/*
- *  ======== MSG_Delete ========
- *  Purpose:
- *      Delete a MSG manager allocated in MSG_Create().
- *  Parameters:
- *      hMsgMgr:            Handle returned from MSG_Create().
- *  Returns:
- *  Requires:
- *      MSG_Init() called.
- *      Valid hMsgMgr.
- *  Ensures:
- */
-	extern void MSG_Delete(struct MSG_MGR *hMsgMgr);
-
-/*
- *  ======== MSG_Exit ========
- *  Purpose:
- *      Discontinue usage of MSG module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      MSG_Init() successfully called before.
- *  Ensures:
- *      Any resources acquired in MSG_Init() will be freed when last MSG
- *      client calls MSG_Exit().
- */
-	extern void MSG_Exit();
-
-/*
- *  ======== MSG_Init ========
- *  Purpose:
- *      Initialize the MSG module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	extern bool MSG_Init();
-
-#endif				/* MSG_ */
--- a/arch/arm/plat-omap/include/bridge/nldrdefs.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * bridge/inc/nldrdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== nldrdefs.h ========
- *  Description:
- *      Global Dynamic + static/overlay Node loader (NLDR) constants and types.
- *
- *! Revision History
- *! ================
- *! 07-Apr-2003 map     Consolidated dldrdefs.h into nldrdefs.h
- *! 05-Aug-2002 jeh     Created.
- */
-
-#ifndef NLDRDEFS_
-#define NLDRDEFS_
-
-#include <dbdcddef.h>
-#include <devdefs.h>
-
-#define NLDR_MAXPATHLENGTH       255
-/* NLDR Objects: */
-	struct  NLDR_OBJECT;
-	struct NLDR_NODEOBJECT;
-
-/*
- *  ======== NLDR_LOADTYPE ========
- *  Load types for a node. Must match values in node.h55.
- */
-	enum NLDR_LOADTYPE {
-		NLDR_STATICLOAD,	/* Linked in base image, not overlay */
-		NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
-		NLDR_OVLYLOAD	/* Linked in base image, overlay node */
-	} ;
-
-/*
- *  ======== NLDR_OVLYFXN ========
- *  Causes code or data to be copied from load address to run address. This
- *  is the "COD_WRITEFXN" that gets passed to the DBLL_Library and is used as
- *  the ZL write function.
- *
- *  Parameters:
- *      pPrivRef:       Handle to identify the node.
- *      ulDspRunAddr:   Run address of code or data.
- *      ulDspLoadAddr:  Load address of code or data.
- *      ulNumBytes:     Number of (GPP) bytes to copy.
- *      nMemSpace:      RMS_CODE or RMS_DATA.
- *  Returns:
- *      ulNumBytes:     Success.
- *      0:              Failure.
- *  Requires:
- *  Ensures:
- */
-       typedef u32(*NLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
-					     u32 ulDspLoadAddr,
-					     u32 ulNumBytes, u32 nMemSpace);
-
-/*
- *  ======== NLDR_WRITEFXN ========
- *  Write memory function. Used for dynamic load writes.
- *  Parameters:
- *      pPrivRef:       Handle to identify the node.
- *      ulDspAddr:      Address of code or data.
- *      pBuf:           Code or data to be written
- *      ulNumBytes:     Number of (GPP) bytes to write.
- *      nMemSpace:      DBLL_DATA or DBLL_CODE.
- *  Returns:
- *      ulNumBytes:     Success.
- *      0:              Failure.
- *  Requires:
- *  Ensures:
- */
-       typedef u32(*NLDR_WRITEFXN) (void *pPrivRef,
-					      u32 ulDspAddr, void *pBuf,
-					      u32 ulNumBytes, u32 nMemSpace);
-
-/*
- *  ======== NLDR_ATTRS ========
- *  Attributes passed to NLDR_Create function.
- */
-	struct NLDR_ATTRS {
-		NLDR_OVLYFXN pfnOvly;
-		NLDR_WRITEFXN pfnWrite;
-		u16 usDSPWordSize;
-		u16 usDSPMauSize;
-	} ;
-
-/*
- *  ======== NLDR_PHASE ========
- *  Indicates node create, delete, or execute phase function.
- */
-	enum NLDR_PHASE {
-		NLDR_CREATE,
-		NLDR_DELETE,
-		NLDR_EXECUTE,
-		NLDR_NOPHASE
-	} ;
-
-/*
- *  Typedefs of loader functions imported from a DLL, or defined in a
- *  function table.
- */
-
-/*
- *  ======== NLDR_Allocate ========
- *  Allocate resources to manage the loading of a node on the DSP.
- *
- *  Parameters:
- *      hNldr:          Handle of loader that will load the node.
- *      pPrivRef:       Handle to identify the node.
- *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
- *      phNldrNode:     Location to store node handle on output. This handle
- *                      will be passed to NLDR_Load/NLDR_Unload.
- *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldr.
- *      pNodeProps != NULL.
- *      phNldrNode != NULL.
- *  Ensures:
- *      DSP_SOK:        IsValidNode(*phNldrNode).
- *      error:          *phNldrNode == NULL.
- */
-	typedef DSP_STATUS(*NLDR_ALLOCATEFXN) (struct NLDR_OBJECT *hNldr,
-					       void *pPrivRef,
-					       IN CONST struct DCD_NODEPROPS
-					       *pNodeProps,
-					       OUT struct NLDR_NODEOBJECT
-					       **phNldrNode,
-					       OUT bool *pfPhaseSplit);
-
-/*
- *  ======== NLDR_Create ========
- *  Create a loader object. This object handles the loading and unloading of
- *  create, delete, and execute phase functions of nodes on the DSP target.
- *
- *  Parameters:
- *      phNldr:         Location to store loader handle on output.
- *      hDevObject:     Device for this processor.
- *      pAttrs:         Loader attributes.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *  Requires:
- *      NLDR_Init() called.
- *      phNldr != NULL.
- *      hDevObject != NULL.
- *	pAttrs != NULL.
- *  Ensures:
- *      DSP_SOK:        Valid *phNldr.
- *      error:          *phNldr == NULL.
- */
-	typedef DSP_STATUS(*NLDR_CREATEFXN) (OUT struct NLDR_OBJECT **phNldr,
-					     struct DEV_OBJECT *hDevObject,
-					     IN CONST struct NLDR_ATTRS
-					     *pAttrs);
-
-/*
- *  ======== NLDR_Delete ========
- *  Delete the NLDR loader.
- *
- *  Parameters:
- *      hNldr:          Node manager object.
- *  Returns:
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldr.
- *  Ensures:
- *	hNldr invalid
- */
-	typedef void(*NLDR_DELETEFXN) (struct NLDR_OBJECT *hNldr);
-
-/*
- *  ======== NLDR_Exit ========
- *  Discontinue usage of NLDR module.
- *
- *  Parameters:
- *  Returns:
- *  Requires:
- *      NLDR_Init() successfully called before.
- *  Ensures:
- *      Any resources acquired in NLDR_Init() will be freed when last NLDR
- *      client calls NLDR_Exit().
- */
-	typedef void(*NLDR_EXITFXN) ();
-
-/*
- *  ======== NLDR_Free ========
- *  Free resources allocated in NLDR_Allocate.
- *
- *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
- *  Returns:
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldrNode.
- *  Ensures:
- */
-	typedef void(*NLDR_FREEFXN) (struct NLDR_NODEOBJECT *hNldrNode);
-
-/*
- *  ======== NLDR_GetFxnAddr ========
- *  Get address of create, delete, or execute phase function of a node on
- *  the DSP.
- *
- *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
- *      pstrFxn:        Name of function.
- *      pulAddr:        Location to store function address.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ESYMBOL:    Address of function not found.
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldrNode.
- *      pulAddr != NULL;
- *      pstrFxn != NULL;
- *  Ensures:
- */
-	typedef DSP_STATUS(*NLDR_GETFXNADDRFXN) (struct NLDR_NODEOBJECT
-						 *hNldrNode,
-						 char *pstrFxn, u32 *pulAddr);
-
-/*
- *  ======== NLDR_Init ========
- *  Initialize the NLDR module.
- *
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	typedef bool(*NLDR_INITFXN) ();
-
-/*
- *  ======== NLDR_Load ========
- *  Load create, delete, or execute phase function of a node on the DSP.
- *
- *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
- *      phase:          Type of function to load (create, delete, or execute).
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EMEMORY:            Insufficient memory on GPP.
- *      DSP_EOVERLAYMEMORY:     Can't overlay phase because overlay memory
- *                              is already in use.
- *      DSP_EDYNLOAD:           Failure in dynamic loader library.
- *      DSP_EFWRITE:            Failed to write phase's code or date to target.
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldrNode.
- *  Ensures:
- */
-	typedef DSP_STATUS(*NLDR_LOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					   enum NLDR_PHASE phase);
-
-/*
- *  ======== NLDR_Unload ========
- *  Unload create, delete, or execute phase function of a node on the DSP.
- *
- *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
- *      phase:          Node function to unload (create, delete, or execute).
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *  Requires:
- *      NLDR_Init() called.
- *      Valid hNldrNode.
- *  Ensures:
- */
-	typedef DSP_STATUS(*NLDR_UNLOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					     enum NLDR_PHASE phase);
-
-/*
- *  ======== NLDR_FXNS ========
- */
-	struct NLDR_FXNS {
-		NLDR_ALLOCATEFXN pfnAllocate;
-		NLDR_CREATEFXN pfnCreate;
-		NLDR_DELETEFXN pfnDelete;
-		NLDR_EXITFXN pfnExit;
-		NLDR_FREEFXN pfnFree;
-		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
-		NLDR_INITFXN pfnInit;
-		NLDR_LOADFXN pfnLoad;
-		NLDR_UNLOADFXN pfnUnload;
-	} ;
-
-#endif				/* NLDRDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/nldr.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * bridge/inc/nldr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== nldr.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge dynamic loader interface. See the file dldrdefs.h
- *  for a description of these functions.
- *
- *  Public Functions:
- *      NLDR_Allocate
- *      NLDR_Create
- *      NLDR_Delete
- *      NLDR_Exit
- *      NLDR_Free
- *      NLDR_GetFxnAddr
- *      NLDR_Init
- *      NLDR_Load
- *      NLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function header comments.
- *! 17-Apr-2002 jeh     Created.
- */
-
-#include <dbdefs.h>
-#include <dbdcddef.h>
-#include <dev.h>
-#include <rmm.h>
-#include <nldrdefs.h>
-
-#ifndef NLDR_
-#define NLDR_
-
-	extern DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr,
-					void *pPrivRef,
-					IN CONST struct DCD_NODEPROPS
-					*pNodeProps,
-					OUT struct NLDR_NODEOBJECT **phNldrNode,
-					IN bool *pfPhaseSplit);
-
-	extern DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct NLDR_ATTRS *pAttrs);
-
-	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
-	extern void NLDR_Exit(void);
-	extern void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode);
-
-	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
-					  char *pstrFxn, u32 *pulAddr);
-
-	extern DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
-					     OUT struct RMM_TargetObj
-					     **phRmmMgr);
-
-	extern bool NLDR_Init(void);
-	extern DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
-	extern DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
-
-#endif				/* NLDR_ */
--- a/arch/arm/plat-omap/include/bridge/nodedefs.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * bridge/inc/nodedefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== nodedefs.h ========
- *  Description:
- *      Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 23-Apr-2001 jeh     Removed NODE_MGRATTRS.
- *! 21-Sep-2000 jeh     Removed NODE_TYPE enum.
- *! 17-Jul-2000 jeh     Changed order of node types to match rms_sh.h.
- *! 20-Jun-2000 jeh     Created.
- */
-
-#ifndef NODEDEFS_
-#define NODEDEFS_
-
-#define NODE_SUSPENDEDPRI -1
-
-/* NODE Objects: */
-	struct NODE_MGR;
-	struct NODE_OBJECT;
-
-#endif				/* NODEDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/node.h
+++ /dev/null
@@ -1,619 +0,0 @@
-/*
- * bridge/inc/node.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== node.h ========
- *  Description:
- *      DSP/BIOS Bridge Node Manager.
- *
- *  Public Functions:
- *      NODE_Allocate
- *      NODE_AllocMsgBuf
- *      NODE_ChangePriority
- *      NODE_Connect
- *      NODE_Create
- *      NODE_CreateMgr
- *      NODE_Delete
- *      NODE_DeleteMgr
- *      NODE_EnumNodes
- *      NODE_Exit
- *      NODE_FreeMsgBuf
- *      NODE_GetAttr
- *      NODE_GetMessage
- *      NODE_GetProcessor
- *      NODE_Init
- *      NODE_OnExit
- *      NODE_Pause
- *      NODE_PutMessage
- *      NODE_RegisterNotify
- *      NODE_Run
- *      NODE_Terminate
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 23-Apr-2001 jeh     Updated with code review changes.
- *! 16-Jan-2001 jeh     Added DSP_ESYMBOL, DSP_EUUID to return codes.
- *! 17-Nov-2000 jeh     Added NODE_OnExit().
- *! 27-Oct-2000 jeh     Added timeouts to NODE_GetMessage, NODE_PutMessage.
- *! 12-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Removed
- *!                     NODE_RegisterAllNodes().
- *! 07-Sep-2000 jeh     Changed type HANDLE in NODE_RegisterNotify to
- *!                     DSP_HNOTIFICATION. Added DSP_STRMATTR param to
- *!                     NODE_Connect(). Removed NODE_GetMessageStream().
- *! 17-Jul-2000 jeh     Updated function header descriptions.
- *! 19-Jun-2000 jeh     Created.
- */
-
-#ifndef NODE_
-#define NODE_
-
-#include <procpriv.h>
-
-#include <nodedefs.h>
-#include <dispdefs.h>
-#include <nldrdefs.h>
-
-/*
- *  ======== NODE_Allocate ========
- *  Purpose:
- *      Allocate GPP resources to manage a node on the DSP.
- *  Parameters:
- *      hProcessor:         Handle of processor that is allocating the node.
- *      pNodeId:            Pointer to a DSP_UUID for the node.
- *      pArgs:              Optional arguments to be passed to the node.
- *      pAttrIn:            Optional pointer to node attributes (priority,
- *                          timeout...)
- *      phNode:             Location to store node handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory on GPP.
- *      DSP_EUUID:          Node UUID has not been registered.
- *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
- *      DSP_ERANGE:         pAttrIn != NULL and pAttrIn->iPriority out of
- *                          range.
- *      DSP_EFAIL:          A failure occured, unable to allocate node.
- *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
- *  Requires:
- *      NODE_Init() called.
- *      hProcessor != NULL.
- *      pNodeId != NULL.
- *      phNode != NULL.
- *  Ensures:
- *      DSP_SOK:            IsValidNode(*phNode).
- *      error:              *phNode == NULL.
- */
-	extern DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
-					IN CONST struct DSP_UUID *pNodeId,
-					OPTIONAL IN CONST struct DSP_CBDATA
-					*pArgs,
-					OPTIONAL IN CONST struct DSP_NODEATTRIN
-					*pAttrIn,
-					OUT struct NODE_OBJECT **phNode);
-
-/*
- *  ======== NODE_AllocMsgBuf ========
- *  Purpose:
- *      Allocate and Prepare a buffer whose descriptor will be passed to a
- *      Node within a (DSP_MSG)message
- *  Parameters:
- *      hNode:          The node handle.
- *      uSize:          The size of the buffer to be allocated.
- *      pAttr:          Pointer to a DSP_BUFFERATTR structure.
- *      pBuffer:        Location to store the address of the allocated
- *                      buffer on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid node handle.
- *      DSP_EMEMORY:    Insufficent memory.
- *      DSP_EFAIL:      General Failure.
- *      DSP_ESIZE:      Invalid Size.
- *  Requires:
- *      NODE_Init() called.
- *      pBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_AllocMsgBuf(struct NODE_OBJECT *hNode,
-					   u32 uSize,
-					   OPTIONAL struct DSP_BUFFERATTR
-					   *pAttr,
-					   OUT u8 **pBuffer);
-
-/*
- *  ======== NODE_ChangePriority ========
- *  Purpose:
- *      Change the priority of an allocated node.
- *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate.
- *      nPriority:          New priority level to set node's priority to.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ERANGE:         nPriority is out of range.
- *      DSP_ENODETYPE:      The specified node is not a task node.
- *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,
- *                          or NODE_RUNNING state.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_ERESTART:       A critical error has occurred and the DSP is
- *                          being restarted.
- *      DSP_EFAIL:          Unable to change node's runtime priority level.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- *      DSP_SOK && (Node's current priority == nPriority)
- */
-	extern DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode,
-					      s32 nPriority);
-
-/*
- *  ======== NODE_CloseOrphans ========
- *  Purpose:
- *      Delete all nodes whose owning processor is being destroyed.
- *  Parameters:
- *      hNodeMgr:       Node manager object.
- *      hProc:          Handle to processor object being destroyed.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
- *  Requires:
- *      Valid hNodeMgr.
- *      hProc != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_CloseOrphans(struct NODE_MGR *hNodeMgr,
-					    struct PROC_OBJECT *hProc);
-
-/*
- *  ======== NODE_Connect ========
- *  Purpose:
- *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
- *      case that the connnection is being made between a node on the DSP and
- *      the GPP, one of the node handles (either hNode1 or hNode2) must be
- *      the constant NODE_HGPPNODE.
- *  Parameters:
- *      hNode1:         Handle of first node to connect to second node. If
- *                      this is a connection from the GPP to hNode2, hNode1
- *                      must be the constant NODE_HGPPNODE. Otherwise, hNode1
- *                      must be a node handle returned from a successful call
- *                      to Node_Allocate().
- *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
- *                      if this is a connection from DSP node to GPP, or a
- *                      node handle returned from a successful call to
- *                      NODE_Allocate().
- *      uStream1:       Output stream index on first node, to be connected
- *                      to second node's input stream. Value must range from
- *                      0 <= uStream1 < number of output streams.
- *      uStream2:       Input stream index on second node. Value must range
- *                      from 0 <= uStream2 < number of input streams.
- *      pAttrs:         Stream attributes (NULL ==> use defaults).
- *      pConnParam:     A pointer to a DSP_CBDATA structure that defines
- *                      connection parameter for device nodes to pass to DSP
- *                      side.
- *                      If the value of this parameter is NULL, then this API
- *                      behaves like DSPNode_Connect. This parameter will have
- *                      length of the string and the null terminated string in
- *                      DSP_CBDATA struct. This can be extended in future tp
- *                      pass binary data.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            Invalid hNode1 or hNode2.
- *      DSP_EMEMORY:            Insufficient host memory.
- *      DSP_EVALUE:             A stream index parameter is invalid.
- *      DSP_EALREADYCONNECTED:  A connection already exists for one of the
- *                              indices uStream1 or uStream2.
- *      DSP_EWRONGSTATE:        Either hNode1 or hNode2 is not in the
- *                              NODE_ALLOCATED state.
- *      DSP_ENOMORECONNECTIONS: No more connections available.
- *      DSP_EFAIL:              Attempt to make an illegal connection (eg,
- *                              Device node to device node, or device node to
- *                              GPP), the two nodes are on different DSPs.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1,
-				       u32 uStream1,
-				       struct NODE_OBJECT *hNode2,
-				       u32 uStream2,
-				       OPTIONAL IN struct DSP_STRMATTR *pAttrs,
-				       OPTIONAL IN struct DSP_CBDATA
-				       *pConnParam);
-
-/*
- *  ======== NODE_Create ========
- *  Purpose:
- *      Create a node on the DSP by remotely calling the node's create
- *      function. If necessary, load code that contains the node's create
- *      function.
- *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ESYMBOL:        Create function not found in the COFF file.
- *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
- *      DSP_EMEMORY:        Memory allocation failure on the DSP.
- *      DSP_ETASK:          Unable to create node's task or process on the DSP.
- *      DSP_ESTREAM:        Stream creation failure on the DSP.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
- *      DSP_EFAIL:          A failure occurred, unable to create node.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== NODE_CreateMgr ========
- *  Purpose:
- *      Create a NODE Manager object. This object handles the creation,
- *      deletion, and execution of nodes on the DSP target. The NODE Manager
- *      also maintains a pipe map of used and available node connections.
- *      Each DEV object should have exactly one NODE Manager object.
- *
- *  Parameters:
- *      phNodeMgr:      Location to store node manager handle on output.
- *      hDevObject:     Device for this processor.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      NODE_Init() called.
- *      phNodeMgr != NULL.
- *      hDevObject != NULL.
- *  Ensures:
- *      DSP_SOK:        Valide *phNodeMgr.
- *      error:          *phNodeMgr == NULL.
- */
-	extern DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
-					 struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== NODE_Delete ========
- *  Purpose:
- *      Delete resources allocated in NODE_Allocate(). If the node was
- *      created, delete the node on the DSP by remotely calling the node's
- *      delete function. Loads the node's delete function if necessary.
- *      GPP side resources are freed after node's delete function returns.
- *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_EDELETE:        A deletion failure occurred.
- *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
- *      DSP_EFAIL:          A failure occurred in deleting the node.
- *      DSP_ESYMBOL:        Delete function not found in the COFF file.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- *      DSP_SOK:            hNode is invalid.
- */
-	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== NODE_DeleteMgr ========
- *  Purpose:
- *      Delete the NODE Manager.
- *  Parameters:
- *      hNodeMgr:       Node manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *  Requires:
- *      NODE_Init() called.
- *      Valid hNodeMgr.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr);
-
-/*
- *  ======== NODE_EnumNodes ========
- *  Purpose:
- *      Enumerate the nodes currently allocated for the DSP.
- *  Parameters:
- *      hNodeMgr:       Node manager returned from NODE_CreateMgr().
- *      aNodeTab:       Array to copy node handles into.
- *      uNodeTabSize:   Number of handles that can be written to aNodeTab.
- *      puNumNodes:     Location where number of node handles written to
- *                      aNodeTab will be written.
- *      puAllocated:    Location to write total number of allocated nodes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ESIZE:      aNodeTab is too small to hold all node handles.
- *  Requires:
- *      Valid hNodeMgr.
- *      aNodeTab != NULL || uNodeTabSize == 0.
- *      puNumNodes != NULL.
- *      puAllocated != NULL.
- *  Ensures:
- *      - (DSP_ESIZE && *puNumNodes == 0)
- *      - || (DSP_SOK && *puNumNodes <= uNodeTabSize)  &&
- *        (*puAllocated == *puNumNodes)
- */
-	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
-					 IN DSP_HNODE *aNodeTab,
-					 u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
-
-/*
- *  ======== NODE_Exit ========
- *  Purpose:
- *      Discontinue usage of NODE module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      NODE_Init() successfully called before.
- *  Ensures:
- *      Any resources acquired in NODE_Init() will be freed when last NODE
- *      client calls NODE_Exit().
- */
-	extern void NODE_Exit();
-
-/*
- *  ======== NODE_FreeMsgBuf ========
- *  Purpose:
- *      Free a message buffer previously allocated with NODE_AllocMsgBuf.
- *  Parameters:
- *      hNode:          The node handle.
- *      pBuffer:        (Address) Buffer allocated by NODE_AllocMsgBuf.
- *      pAttr:          Same buffer attributes passed to NODE_AllocMsgBuf.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid node handle.
- *      DSP_EFAIL:      Failure to free the buffer.
- *  Requires:
- *      NODE_Init() called.
- *      pBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode,
-					  IN u8 *pBuffer,
-					  OPTIONAL struct DSP_BUFFERATTR
-					  *pAttr);
-
-/*
- *  ======== NODE_GetAttr ========
- *  Purpose:
- *      Copy the current attributes of the specified node into a DSP_NODEATTR
- *      structure.
- *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      pAttr:          Pointer to DSP_NODEATTR structure to copy node's
- *                      attributes.
- *      uAttrSize:      Size of pAttr.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *  Requires:
- *      NODE_Init() called.
- *      pAttr != NULL.
- *  Ensures:
- *      DSP_SOK:        *pAttrs contains the node's current attributes.
- */
-	extern DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
-				       OUT struct DSP_NODEATTR *pAttr,
-				       u32 uAttrSize);
-
-/*
- *  ======== NODE_GetMessage ========
- *  Purpose:
- *      Retrieve a message from a node on the DSP. The node must be either a
- *      message node, task node, or XDAIS socket node.
- *      If a message is not available, this function will block until a
- *      message is available, or the node's timeout value is reached.
- *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      pMessage:       Pointer to DSP_MSG structure to copy the
- *                      message into.
- *      uTimeout:       Timeout in milliseconds to wait for message.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
- *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
- *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
- *  Requires:
- *      NODE_Init() called.
- *      pMessage != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode,
-					  OUT struct DSP_MSG *pMessage,
-					  u32 uTimeout);
-
-/*
- *  ======== NODE_GetNldrObj ========
- *  Purpose:
- *      Retrieve the Nldr manager
- *  Parameters:
- *      hNodeMgr:       Node Manager
- *      phNldrObj:      Pointer to a Nldr manager handle
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
-					  OUT struct NLDR_OBJECT **phNldrObj);
-
-/*
- *  ======== NODE_Init ========
- *  Purpose:
- *      Initialize the NODE module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	extern bool NODE_Init();
-
-/*
- *  ======== NODE_OnExit ========
- *  Purpose:
- *      Gets called when RMS_EXIT is received for a node. PROC needs to pass
- *      this function as a parameter to MSG_Create(). This function then gets
- *      called by the mini-driver when an exit message for a node is received.
- *  Parameters:
- *      hNode:      Handle of the node that the exit message is for.
- *      nStatus:    Return status of the node's execute phase.
- *  Returns:
- *  Ensures:
- */
-	void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus);
-
-/*
- *  ======== NODE_Pause ========
- *  Purpose:
- *      Suspend execution of a node currently running on the DSP.
- *  Parameters:
- *      hNode:              Node object representing a node currently
- *                          running on the DSP.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ENODETYPE:      Node is not a task or socket node.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
- *      DSP_EFAIL:          Failed to pause node.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== NODE_PutMessage ========
- *  Purpose:
- *      Send a message to a message node, task node, or XDAIS socket node.
- *      This function will block until the message stream can accommodate
- *      the message, or a timeout occurs. The message will be copied, so Msg
- *      can be re-used immediately after return.
- *  Parameters:
- *      hNode:              Node handle returned by NODE_Allocate().
- *      pMsg:               Location of message to be sent to the node.
- *      uTimeout:           Timeout in msecs to wait.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
- *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
- *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
- *      DSP_EFAIL:          Unable to send message.
- *  Requires:
- *      NODE_Init() called.
- *      pMsg != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
-					  IN CONST struct DSP_MSG *pMsg,
-					  u32 uTimeout);
-
-/*
- *  ======== NODE_RegisterNotify ========
- *  Purpose:
- *      Register to be notified on specific events for this node.
- *  Parameters:
- *      hNode:          Node handle returned by NODE_Allocate().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
- *                      supported.
- *  Requires:
- *      NODE_Init() called.
- *      hNotification != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
-
-/*
- *  ======== NODE_Run ========
- *  Purpose:
- *      Start execution of a node's execute phase, or resume execution of
- *      a node that has been suspended (via NODE_Pause()) on the DSP. Load
- *      the node's execute function if necessary.
- *  Parameters:
- *      hNode:              Node object representing a node currently
- *                          running on the DSP.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ENODETYPE:      hNode doesn't represent a message, task or dais
- *                          socket node.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
- *      DSP_EFAIL:          Unable to start or resume execution.
- *      DSP_ESYMBOL:        Execute function not found in the COFF file.
- *  Requires:
- *      NODE_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== NODE_Terminate ========
- *  Purpose:
- *      Signal a node running on the DSP that it should exit its execute
- *      phase function.
- *  Parameters:
- *      hNode:              Node object representing a node currently
- *                          running on the DSP.
- *      pStatus:            Location to store execute-phase function return
- *                          value (DSP_EUSER1-16).
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
- *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
- *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
- *      DSP_EFAIL:          Unable to terminate the node.
- *  Requires:
- *      NODE_Init() called.
- *      pStatus != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode,
-					 OUT DSP_STATUS *pStatus);
-
-
-
-/*
- *  ======== NODE_GetUUIDProps ========
- *  Purpose:
- *      Fetch Node properties given the UUID
- *  Parameters:
- *
- */
-	extern DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
-					    IN CONST struct DSP_UUID *pNodeId,
-					    OUT struct DSP_NDBPROPS
-					    *pNodeProps);
-
-#endif				/* NODE_ */
--- a/arch/arm/plat-omap/include/bridge/nodepriv.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * bridge/inc/nodepriv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== nodepriv.h ========
- *  Description:
- *      Private node header shared by NODE and DISP.
- *
- *  Public Functions:
- *      NODE_GetChannelId
- *      NODE_GetStrmMgr
- *      NODE_GetTimeout
- *      NODE_GetType
- *      NODE_GetLoadType
- *
- *! Revision History
- *! ================
- *! 19-Nov-2002 map     Added NODE_GetLoadType
- *! 13-Feb-2002 jeh     Added uSysStackSize to NODE_TASKARGS.
- *! 23-Apr-2001 jeh     Removed unused typedefs, defines.
- *! 10-Oct-2000 jeh     Added alignment to NODE_STRMDEF.
- *! 20-Jun-2000 jeh     Created.
- */
-
-#ifndef NODEPRIV_
-#define NODEPRIV_
-
-#include <strmdefs.h>
-#include <nodedefs.h>
-#include <nldrdefs.h>
-
-/* DSP address of node environment structure */
-	typedef u32 NODE_ENV;
-
-/*
- *  Node create structures
- */
-
-/* Message node */
-	struct NODE_MSGARGS {
-		u32 uMaxMessages; /* Max # of simultaneous messages for node */
-		u32 uSegid;	/* Segment for allocating message buffers */
-		u32 uNotifyType;  /* Notify type (SEM_post, SWI_post, etc.) */
-		u32 uArgLength;  /* Length in 32-bit words of arg data block */
-		u8 *pData;	/* Argument data for node */
-	} ;
-
-	struct NODE_STRMDEF {
-		u32 uBufsize;	/* Size of buffers for SIO stream */
-		u32 uNumBufs;	/* max # of buffers in SIO stream at once */
-		u32 uSegid;	/* Memory segment id to allocate buffers */
-		u32 uTimeout;	/* Timeout for blocking SIO calls */
-		u32 uAlignment;	/* Buffer alignment */
-		char *szDevice;	/* Device name for stream */
-	} ;
-
-/* Task node */
-	struct NODE_TASKARGS {
-		struct NODE_MSGARGS msgArgs;
-		s32 nPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uDSPHeapResAddr;	/* DSP virtual heap address */
-		u32 uDSPHeapAddr;	/* DSP virtual heap address */
-		u32 uHeapSize;	/* Heap size */
-		u32 uGPPHeapAddr;	/* GPP virtual heap address */
-		u32 uProfileID;	/* Profile ID */
-		u32 uNumInputs;
-		u32 uNumOutputs;
-		u32 ulDaisArg;	/* Address of iAlg object */
-		struct NODE_STRMDEF *strmInDef;
-		struct NODE_STRMDEF *strmOutDef;
-	} ;
-
-/*
- *  ======== NODE_CREATEARGS ========
- */
-	struct NODE_CREATEARGS {
-		union {
-			struct NODE_MSGARGS msgArgs;
-			struct NODE_TASKARGS taskArgs;
-		} asa;
-	} ;
-
-/*
- *  Node types: Message node, task node, xDAIS socket node, and
- *  device node. _NODE_GPP is used when defining a stream connection
- *  between a task or socket node and the GPP.
- *
- *  ~~~~~~~~~~~~~~
- *  TO DO:
- *  Clean up when Node Manager uses only one critical section.
- *  ~~~~~~~~~~~~~~
- */
-	enum NODE_TYPE {
-		_NODE_DEVICE = NODE_DEVICE,
-		_NODE_TASK = NODE_TASK,
-		_NODE_DAISSOCKET = NODE_DAISSOCKET,
-		_NODE_MESSAGE = NODE_MESSAGE,
-		NODE_GPP
-	} ;
-
-/*
- *  ======== NODE_STATE ========
- *  Internal node states.
- */
-	enum NODE_STATE {
-		_NODE_ALLOCATED = NODE_ALLOCATED,
-		_NODE_CREATED = NODE_CREATED,
-		_NODE_RUNNING = NODE_RUNNING,
-		_NODE_PAUSED = NODE_PAUSED,
-		_NODE_DONE = NODE_DONE,
-		NODE_CREATING,
-		NODE_STARTING,
-		NODE_PAUSING,
-		NODE_TERMINATING,
-		NODE_DELETING,
-	} ;
-
-/*
- *  ======== NODE_GetChannelId ========
- *  Purpose:
- *      Get the channel index reserved for a stream connection between the
- *      host and a node. This index is reserved when NODE_Connect() is called
- *      to connect the node with the host. This index should be passed to
- *      the CHNL_Open function when the stream is actually opened.
- *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      uDir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
- *      uIndex:         Stream index.
- *      pulId:          Location to store channel index.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_ENODETYPE:  Not a task or DAIS socket node.
- *      DSP_EVALUE:     The node's stream corresponding to uIndex and uDir
- *                      is not a stream to or from the host.
- *  Requires:
- *      NODE_Init() called.
- *      Valid uDir.
- *      pulId != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode,
-					    u32 uDir,
-					    u32 uIndex, OUT u32 *pulId);
-
-/*
- *  ======== NODE_GetStrmMgr ========
- *  Purpose:
- *      Get the STRM manager for a node.
- *  Parameters:
- *      hNode:          Node allocated with NODE_Allocate().
- *      phStrmMgr:      Location to store STRM manager on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *  Requires:
- *      phStrmMgr != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
-					  struct STRM_MGR **phStrmMgr);
-
-/*
- *  ======== NODE_GetTimeout ========
- *  Purpose:
- *      Get the timeout value of a node.
- *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
- *  Returns:
- *      Node's timeout value.
- *  Requires:
- *      Valid hNode.
- *  Ensures:
- */
-	extern u32 NODE_GetTimeout(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== NODE_GetType ========
- *  Purpose:
- *      Get the type (device, message, task, or XDAIS socket) of a node.
- *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
- *  Returns:
- *      Node type:  NODE_DEVICE, NODE_TASK, NODE_XDAIS, or NODE_GPP.
- *  Requires:
- *      Valid hNode.
- *  Ensures:
- */
-	extern enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode);
-
-/*
- *  ======== GetNodeInfo ========
- *  Purpose:
- *      Get node information without holding semaphore.
- *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
- *  Returns:
- *      Node info:  priority, device owner, no. of streams, execution state
- *                  NDB properties.
- *  Requires:
- *      Valid hNode.
- *  Ensures:
- */
-	extern void GetNodeInfo(struct NODE_OBJECT *hNode,
-				struct DSP_NODEINFO *pNodeInfo);
-
-/*
- *  ======== NODE_GetLoadType ========
- *  Purpose:
- *      Get the load type (dynamic, overlay, static) of a node.
- *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
- *  Returns:
- *      Node type:  NLDR_DYNAMICLOAD, NLDR_OVLYLOAD, NLDR_STATICLOAD
- *  Requires:
- *      Valid hNode.
- *  Ensures:
- */
-	extern enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode);
-
-#endif				/* NODEPRIV_ */
--- a/arch/arm/plat-omap/include/bridge/ntfy.h
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * bridge/inc/ntfy.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== ntfy.h ========
- *  Purpose:
- *      Manage lists of notification events.
- *
- *  Public Functions:
- *      NTFY_Create
- *      NTFY_Delete
- *      NTFY_Exit
- *      NTFY_Init
- *      NTFY_Notify
- *      NTFY_Register
- *
- *! Revision History:
- *! =================
- *! 05-Nov-2001 kc: Updated NTFY_Register.
- *! 07-Sep-2000 jeh Created.
- */
-
-#ifndef NTFY_
-#define NTFY_
-
-	struct NTFY_OBJECT;
-
-/*
- *  ======== NTFY_Create ========
- *  Purpose:
- *      Create an empty list of notifications.
- *  Parameters:
- *      phNtfy:         Location to store handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
- *  Requires:
- *      NTFY_Init() called.
- *      phNtfy != NULL.
- *  Ensures:
- *      DSP_SUCCEEDED(status) <==>  IsValid(*phNtfy).
- */
-	extern DSP_STATUS NTFY_Create(OUT struct NTFY_OBJECT **phNtfy);
-
-/*
- *  ======== NTFY_Delete ========
- *  Purpose:
- *      Free resources allocated in NTFY_Create.
- *  Parameters:
- *      hNtfy:  Handle returned from NTFY_Create().
- *  Returns:
- *  Requires:
- *      NTFY_Init() called.
- *      IsValid(hNtfy).
- *  Ensures:
- */
-	extern void NTFY_Delete(IN struct NTFY_OBJECT *hNtfy);
-
-/*
- *  ======== NTFY_Exit ========
- *  Purpose:
- *      Discontinue usage of NTFY module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      NTFY_Init() successfully called before.
- *  Ensures:
- */
-	extern void NTFY_Exit();
-
-/*
- *  ======== NTFY_Init ========
- *  Purpose:
- *      Initialize the NTFY module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Ensures:
- */
-	extern bool NTFY_Init();
-
-/*
- *  ======== NTFY_Notify ========
- *  Purpose:
- *      Execute notify function (signal event or post message) for every
- *      element in the notification list that is to be notified about the
- *      event specified in uEventMask.
- *  Parameters:
- *      hNtfy:      Handle returned from NTFY_Create().
- *      uEventMask: The type of event that has occurred.
- *  Returns:
- *  Requires:
- *      NTFY_Init() called.
- *      IsValid(hNtfy).
- *  Ensures:
- */
-	extern void NTFY_Notify(IN struct NTFY_OBJECT *hNtfy,
-				IN u32 uEventMask);
-
-/*
- *  ======== NTFY_Register ========
- *  Purpose:
- *      Add a notification element to the list. If the notification is already
- *      registered, and uEventMask != 0, the notification will get posted for
- *      events specified in the new event mask. If the notification is already
- *      registered and uEventMask == 0, the notification will be unregistered.
- *  Parameters:
- *      hNtfy:              Handle returned from NTFY_Create().
- *      hNotification:      Handle to a DSP_NOTIFICATION object.
- *      uEventMask:         Events to be notified about.
- *      uNotifyType:        Type of notification: DSP_SIGNALEVENT.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
- *      DSP_EVALUE:         uEventMask is 0 and hNotification was not
- *                          previously registered.
- *      DSP_EHANDLE:        NULL hNotification, hNotification event name
- *                          too long, or hNotification event name NULL.
- *  Requires:
- *      NTFY_Init() called.
- *      IsValid(hNtfy).
- *      hNotification != NULL.
- *      uNotifyType is DSP_SIGNALEVENT
- *  Ensures:
- */
-	extern DSP_STATUS NTFY_Register(IN struct NTFY_OBJECT *hNtfy,
-					IN struct DSP_NOTIFICATION
-					*hNotification,
-					IN u32 uEventMask,
-					IN u32 uNotifyType);
-
-#endif				/* NTFY_ */
--- a/arch/arm/plat-omap/include/bridge/proc.h
+++ /dev/null
@@ -1,648 +0,0 @@
-/*
- * bridge/inc/proc.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== proc.h ========
- *  Description:
- *	This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      PROC_Attach
- *      PROC_Create
- *      PROC_Ctrl	       (OEM-function)
- *      PROC_Destroy
- *      PROC_Detach
- *      PROC_EnumNodes
- *      PROC_Exit
- *      PROC_FlushMemory
- *      PROC_GetDevObject       (OEM-function)
- *      PROC_GetResourceInfo
- *      PROC_GetState
- *      PROC_GetProcessorId
- *      PROC_GetTrace	   (OEM-function)
- *      PROC_Init
- *      PROC_Load	       (OEM-function)
- *      PROC_Map
- *      PROC_NotifyAllclients
- *      PROC_NotifyClients      (OEM-function)
- *      PROC_RegisterNotify
- *      PROC_ReserveMemory
- *      PROC_Start	      (OEM-function)
- *      PROC_UnMap
- *      PROC_UnReserveMemory
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
- *! 09-Feb-2003 vp: Added PROC_GetProcessorID function
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 28-Sep-2000 rr: Updated to Version 0.9.
- *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types). GetTrace added.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
-#ifndef PROC_
-#define PROC_
-
-#include <cfgdefs.h>
-#include <devdefs.h>
-
-/*
- *  ======== PROC_Attach ========
- *  Purpose:
- *      Prepare for communication with a particular DSP processor, and return
- *      a handle to the processor object. The PROC Object gets created
- *  Parameters:
- *      uProcessor  :	   The processor index (zero-based).
- *      hMgrObject  :	   Handle to the Manager Object
- *      pAttrIn     :	   Ptr to the DSP_PROCESSORATTRIN structure.
- *			      A NULL value means use default values.
- *      phProcessor :	   Ptr to location to store processor handle.
- *  Returns:
- *      DSP_SOK     :	   Success.
- *      DSP_EFAIL   :	   General failure.
- *      DSP_EHANDLE :	   Invalid processor handle.
- *      DSP_SALREADYATTACHED:   Success; Processor already attached.
- *  Requires:
- *      phProcessor != NULL.
- *      PROC Initialized.
- *  Ensures:
- *      DSP_EFAIL, and *phProcessor == NULL, OR
- *      Success and *phProcessor is a Valid Processor handle OR
- *      DSP_SALREADYATTACHED and *phProcessor is a Valid Processor.
- *  Details:
- *      When pAttrIn is NULL, the default timeout value is 10 seconds.
- */
-	extern DSP_STATUS PROC_Attach(u32 uProcessor,
-				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
-				      *pAttrIn,
-				      OUT DSP_HPROCESSOR *phProcessor);
-
-/*
- *  ======== PROC_AutoStart =========
- *  Purpose:
- *      A Particular device gets loaded with the default image
- *      if the AutoStart flag is set.
- *  Parameters:
- *      hDevObject  :   Handle to the Device
- *  Returns:
- *      DSP_SOK     :   On Successful Loading
- *      DSP_EFILE   :   No DSP exec file found.
- *      DSP_EFAIL   :   General Failure
- *  Requires:
- *      hDevObject != NULL.
- *      hDevNode != NULL.
- *      PROC Initialized.
- *  Ensures:
- */
-	extern DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
-					 struct DEV_OBJECT *hDevObject);
-
-/*
- *  ======== PROC_Ctrl ========
- *  Purpose:
- *      Pass control information to the GPP device driver managing the DSP
- *      processor. This will be an OEM-only function, and not part of the
- *      'Bridge application developer's API.
- *  Parameters:
- *      hProcessor  :       The processor handle.
- *      dwCmd       :       Private driver IOCTL cmd ID.
- *      pArgs       :       Ptr to an driver defined argument structure.
- *  Returns:
- *      DSP_SOK     :       SUCCESS
- *      DSP_EHANDLE :       Invalid processor handle.
- *      DSP_ETIMEOUT:       A Timeout Occured before the Control information
- *			  could be sent.
- *      DSP_EACCESSDENIED:  Client does not have the access rights required
- *			  to call this function.
- *      DSP_ERESTART:       A Critical error has occured and the DSP is being
- *			  restarted.
- *      DSP_EFAIL   :       General Failure.
- *  Requires:
- *      PROC Initialized.
- *  Ensures
- *  Details:
- *      This function Calls WMD_BRD_Ioctl.
- */
-	extern DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor,
-				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
-
-/*
- *  ======== PROC_Detach ========
- *  Purpose:
- *      Close a DSP processor and de-allocate all (GPP) resources reserved
- *      for it. The Processor Object is deleted.
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   InValid Handle.
- *      DSP_EFAIL   :   General failure.
- *  Requires:
- *      PROC Initialized.
- *  Ensures:
- *      PROC Object is destroyed.
- */
-	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor);
-
-/*
- *  ======== PROC_EnumNodes ========
- *  Purpose:
- *      Enumerate the nodes currently allocated on a processor.
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *      aNodeTab    :   The first Location of an array allocated for node
- *		      handles.
- *      uNodeTabSize:   The number of (DSP_HNODE) handles that can be held
- *		      to the memory the client has allocated for aNodeTab
- *      puNumNodes  :   Location where DSPProcessor_EnumNodes will return
- *		      the number of valid handles written to aNodeTab
- *      puAllocated :   Location where DSPProcessor_EnumNodes will return
- *		      the number of nodes that are allocated on the DSP.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_ESIZE   :   The amount of memory allocated for aNodeTab is
- *		      insufficent. That is the number of nodes actually
- *		      allocated on the DSP is greater than the value
- *		      specified for uNodeTabSize.
- *      DSP_EFAIL   :   Unable to get Resource Information.
- *  Details:
- *  Requires
- *      puNumNodes is not NULL.
- *      puAllocated is not NULL.
- *      aNodeTab is not NULL.
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor,
-					 IN DSP_HNODE *aNodeTab,
-					 IN u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
-
-/*
- *  ======== PROC_GetResourceInfo ========
- *  Purpose:
- *      Enumerate the resources currently available on a processor.
- *  Parameters:
- *      hProcessor  :       The processor handle.
- *      uResourceType:      Type of resource .
- *      pResourceInfo:      Ptr to the DSP_RESOURCEINFO structure.
- *      uResourceInfoSize:  Size of the structure.
- *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EHANDLE :       Invalid processor handle.
- *      DSP_EWRONGSTATE:    The processor is not in the PROC_RUNNING state.
- *      DSP_ETIMEOUT:       A timeout occured before the DSP responded to the
- *			  querry.
- *      DSP_ERESTART:       A Critical error has occured and the DSP is being
- *			  restarted.
- *      DSP_EFAIL   :       Unable to get Resource Information
- *  Requires:
- *      pResourceInfo is not NULL.
- *      Parameter uResourceType is Valid.[TBD]
- *      uResourceInfoSize is >= sizeof DSP_RESOURCEINFO struct.
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- *      This function currently returns
- *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
- */
-	extern DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor,
-					       u32 uResourceType,
-					       OUT struct DSP_RESOURCEINFO *
-					       pResourceInfo,
-					       u32 uResourceInfoSize);
-
-/*
- *  ======== PROC_Exit ========
- *  Purpose:
- *      Decrement reference count, and free resources when reference count is
- *      0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      PROC is initialized.
- *  Ensures:
- *      When reference count == 0, PROC's private resources are freed.
- */
-       extern void PROC_Exit();
-
-/*
- * ======== PROC_GetDevObject =========
- *  Purpose:
- *      Returns the DEV Hanlde for a given Processor handle
- *  Parameters:
- *      hProcessor  :   Processor Handle
- *      phDevObject :   Location to store the DEV Handle.
- *  Returns:
- *      DSP_SOK     :   Success; *phDevObject has Dev handle
- *      DSP_EFAIL   :   Failure; *phDevObject is zero.
- *  Requires:
- *      phDevObject is not NULL
- *      PROC Initialized.
- *  Ensures:
- *      DSP_SOK     :   *phDevObject is not NULL
- *      DSP_EFAIL   :   *phDevObject is NULL.
- */
-	extern DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
-					    struct DEV_OBJECT **phDevObject);
-
-/*
- *  ======== PROC_Init ========
- *  Purpose:
- *      Initialize PROC's private state, keeping a reference count on each
- *      call.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      TRUE: A requirement for the other public PROC functions.
- */
-       extern bool PROC_Init();
-
-/*
- *  ======== PROC_GetState ========
- *  Purpose:
- *      Report the state of the specified DSP processor.
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pProcStatus :   Ptr to location to store the DSP_PROCESSORSTATE
- *		      structure.
- *      uStateInfoSize: Size of DSP_PROCESSORSTATE.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while querying processor state.
- *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
-					OUT struct DSP_PROCESSORSTATE
-					*pProcStatus,
-					u32 uStateInfoSize);
-
-/*
- *  ======== PROC_GetProcessorID ========
- *  Purpose:
- *      Report the state of the specified DSP processor.
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *      procID      :   Processor ID
- *
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while querying processor state.
- *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProcessor,
-					      u32 *procID);
-
-/*
- *  ======== PROC_GetTrace ========
- *  Purpose:
- *      Retrieve the trace buffer from the specified DSP processor.
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pBuf	:   Ptr to buffer to hold trace output.
- *      uMaxSize    :   Maximum size of the output buffer.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while retireving processor trace
- *		      Buffer.
- *  Requires:
- *      pBuf is not NULL
- *      uMaxSize is > 0.
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf,
-					u32 uMaxSize);
-
-/*
- *  ======== PROC_Load ========
- *  Purpose:
- *      Reset a processor and load a new base program image.
- *      This will be an OEM-only function.
- *  Parameters:
- *      hProcessor  :       The processor handle.
- *      iArgc       :       The number of Arguments(strings)in the aArgV[]
- *      aArgv       :       An Array of Arguments(Unicode Strings)
- *      aEnvp       :       An Array of Environment settings(Unicode Strings)
- *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EFILE   :       The DSP Execuetable was not found.
- *      DSP_EHANDLE :       Invalid processor handle.
- *      DSP_ECORRUTFILE:    Unable to Parse the DSP Execuetable
- *      DSP_EATTACHED:      Abort because a GPP Client is attached to the
- *			  specified Processor
- *      DSP_EACCESSDENIED:  Client does not have the required access rights
- *			  to reset and load the Processor
- *      DSP_EFAIL   :       Unable to Load the Processor
- *  Requires:
- *      aArgv is not NULL
- *      iArgc is > 0
- *      PROC Initialized.
- *  Ensures:
- *      Success and ProcState == PROC_LOADED
- *      or DSP_FAILED status.
- *  Details:
- *      Does not implement access rights to control which GPP application
- *      can load the processor.
- */
-	extern DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor,
-				    IN CONST s32 iArgc, IN CONST char **aArgv,
-				    IN CONST char **aEnvp);
-
-/*
- *  ======== PROC_RegisterNotify ========
- *  Purpose:
- *      Register to be notified of specific processor events
- *  Parameters:
- *      hProcessor  :   The processor handle.
- *      uEventMask  :   Mask of types of events to be notified about.
- *      uNotifyType :   Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle or hNotification.
- *      DSP_EVALUE  :   Parameter uEventMask is Invalid
- *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
- *		      is not supported.
- *      DSP_EFAIL   :   Unable to register for notification.
- *  Requires:
- *      hNotification is not NULL
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
-
-/*
- *  ======== PROC_NotifyClients ========
- *  Purpose:
- *      Notify the Processor Clients
- *  Parameters:
- *      hProc       :   The processor handle.
- *      uEvents     :   Event to be notified about.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   Failure to Set or Reset the Event
- *  Requires:
- *      uEvents is Supported or Valid type of Event
- *      hProc is a valid handle
- *      PROC Initialized.
- *  Ensures:
- */
-	extern DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc,
-					     u32 uEvents);
-
-/*
- *  ======== PROC_NotifyAllClients ========
- *  Purpose:
- *      Notify the Processor Clients
- *  Parameters:
- *      hProc       :   The processor handle.
- *      uEvents     :   Event to be notified about.
- *  Returns:
- *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   Failure to Set or Reset the Event
- *  Requires:
- *      uEvents is Supported or Valid type of Event
- *      hProc is a valid handle
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- *      NODE And STRM would use this function to notify their clients
- *      about the state changes in NODE or STRM.
- */
-	extern DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc,
-						u32 uEvents);
-
-/*
- *  ======== PROC_Start ========
- *  Purpose:
- *      Start a processor running.
- *      Processor must be in PROC_LOADED state.
- *      This will be an OEM-only function, and not part of the 'Bridge
- *      application developer's API.
- *  Parameters:
- *      hProcessor  :       The processor handle.
- *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EHANDLE :       Invalid processor handle.
- *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
- *      DSP_EFAIL   :       Unable to start the processor.
- *  Requires:
- *      PROC Initialized.
- *  Ensures:
- *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
- *  Details:
- */
-	extern DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor);
-
-/*
- *  ======== PROC_Stop ========
- *  Purpose:
- *      Start a processor running.
- *      Processor must be in PROC_LOADED state.
- *      This will be an OEM-only function, and not part of the 'Bridge
- *      application developer's API.
- *  Parameters:
- *      hProcessor  :       The processor handle.
- *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EHANDLE :       Invalid processor handle.
- *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
- *      DSP_EFAIL   :       Unable to start the processor.
- *  Requires:
- *      PROC Initialized.
- *  Ensures:
- *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
- *  Details:
- */
-	extern DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor);
-
-/*
- *  ======== PROC_FlushMemory ========
- *  Purpose:
- *      Flushes a buffer from the MPU data cache.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
- *      ulFlags	 :   Reserved.
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *  Requires:
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- *      All the arguments are currently ignored.
- */
-	extern DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize, u32 ulFlags);
-
-
-/*
- *  ======== PROC_InvalidateMemory ========
- *  Purpose:
- *      Invalidates a buffer from the MPU data cache.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *  Requires:
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- *      All the arguments are currently ignored.
- */
-	extern DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize);
-
-/*
- *  ======== PROC_Map ========
- *  Purpose:
- *      Maps a MPU buffer to DSP address space.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Starting address of the memory region to map.
- *      ulSize	  :   Size of the memory region to map.
- *      pReqAddr	:   Requested DSP start address. Offset-adjusted actual
- *			  mapped address is in the last argument.
- *      ppMapAddr       :   Ptr to DSP side mapped u8 address.
- *      ulMapAttr       :   Optional endianness attributes, virt to phys flag.
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *      DSP_EMEMORY     :   MPU side memory allocation error.
- *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
- *		      :   address.
- *  Requires:
- *      pMpuAddr is not NULL
- *      ulSize is not zero
- *      ppMapAddr is not NULL
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor,
-				   void *pMpuAddr,
-				   u32 ulSize,
-				   void *pReqAddr,
-				   void **ppMapAddr, u32 ulMapAttr);
-
-/*
- *  ======== PROC_ReserveMemory ========
- *  Purpose:
- *      Reserve a virtually contiguous region of DSP address space.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      ulSize	  :   Size of the address space to reserve.
- *      ppRsvAddr       :   Ptr to DSP side reserved u8 address.
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
- *  Requires:
- *      ppRsvAddr is not NULL
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor,
-					     u32 ulSize, void **ppRsvAddr);
-
-/*
- *  ======== PROC_UnMap ========
- *  Purpose:
- *      Removes a MPU buffer mapping from the DSP address space.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMapAddr	:   Starting address of the mapped memory region.
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
- *		      :   address.
- *  Requires:
- *      pMapAddr is not NULL
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr);
-
-/*
- *  ======== PROC_UnReserveMemory ========
- *  Purpose:
- *      Frees a previously reserved region of DSP address space.
- *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pRsvAddr	:   Ptr to DSP side reservedBYTE address.
- *  Returns:
- *      DSP_SOK	 :   Success.
- *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
- *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
- *		      :   address.
- *  Requires:
- *      pRsvAddr is not NULL
- *      PROC Initialized.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor,
-					       void *pRsvAddr);
-
-#endif				/* PROC_ */
--- a/arch/arm/plat-omap/include/bridge/procpriv.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/procpriv.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== procpriv.h ========
- *  Description:
- *      Global PROC constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 05-July-2000 rr: Created
- */
-
-#ifndef PROCPRIV_
-#define PROCPRIV_
-
-/* RM PROC Object */
-	struct PROC_OBJECT;
-
-#endif				/* PROCPRIV_ */
-
--- a/arch/arm/plat-omap/include/bridge/pwr.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/pwr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== pwr.h ========
- *
- *  Public Functions:
- *
- *      PWR_SleepDSP
- *      PWR_WakeDSP
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 06-Jun-2002 sg  Replaced dspdefs.h with includes of dbdefs.h and errbase.h.
- *! 13-May-2002 sg  Added DSP_SAREADYASLEEP and DSP_SALREADYAWAKE.
- *! 09-May-2002 sg  Updated, added timeouts.
- *! 02-May-2002 sg  Initial.
- */
-
-#ifndef PWR_
-#define PWR_
-
-#include <dbdefs.h>
-#include <errbase.h>
-#include <pwr_sh.h>
-
-/*
- *  ======== PWR_SleepDSP ========
- *      Signal the DSP to go to sleep.
- *
- *  Parameters:
- *      sleepCode:          New sleep state for DSP.  (Initially, valid codes
- *                          are PWR_DEEPSLEEP or PWR_EMERGENCYDEEPSLEEP; both of
- *                          these codes will simply put the DSP in deep sleep.)
- *
- *	timeout:            Maximum time (msec) that PWR should wait for
- *                          confirmation that the DSP sleep state has been
- *                          reached.  If PWR should simply send the command to
- *                          the DSP to go to sleep and then return (i.e.,
- *                          asynchrounous sleep), the timeout should be
- *                          specified as zero.
- *
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_SALREADYASLEEP: Success, but the DSP was already asleep.
- *      DSP_EINVALIDARG:    The specified sleepCode is not supported.
- *      DSP_ETIMEOUT:       A timeout occured while waiting for DSP sleep
- *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send sleep command to
- *                          the DSP.
- */
-	extern DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode,
-				       IN CONST u32 timeout);
-
-/*
- *  ======== PWR_WakeDSP ========
- *    Signal the DSP to wake from sleep.
- *
- *  Parameters:
- *	timeout:            Maximum time (msec) that PWR should wait for
- *                          confirmation that the DSP is awake.  If PWR should
- *                          simply send a command to the DSP to wake and then
- *                          return (i.e., asynchrounous wake), timeout should
- *                          be specified as zero.
- *
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
- *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
- *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
- *                          the DSP.
- */
-	extern DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout);
-
-/*
- *  ======== PWR_PM_PreScale ========
- *    Prescale notification to DSP.
- *
- *  Parameters:
- *	voltage_domain:   The voltage domain for which notification is sent
- *    level:			The level of voltage domain
- *
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
- *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
- *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
- *                          the DSP.
- */
-	extern DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level);
-
-/*
- *  ======== PWR_PM_PostScale ========
- *    PostScale notification to DSP.
- *
- *  Parameters:
- *	voltage_domain:   The voltage domain for which notification is sent
- *    level:			The level of voltage domain
- *
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
- *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
- *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
- *                          the DSP.
- */
-	extern DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain,
-					   u32 level);
-
-#endif				/* PWR_ */
--- a/arch/arm/plat-omap/include/bridge/pwr_sh.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/pwr_sh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== pwr_sh.h ========
- *
- *  Power Manager shared definitions (used on both GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 17-Apr-2002 sg: Initial.
- */
-
-#ifndef PWR_SH_
-#define PWR_SH_
-
-#include <mbx_sh.h>
-
-/* valid sleep command codes that can be sent by GPP via mailbox: */
-#define PWR_DEEPSLEEP           MBX_PM_DSPIDLE
-#define PWR_EMERGENCYDEEPSLEEP  MBX_PM_EMERGENCYSLEEP
-#define PWR_SLEEPUNTILRESTART   MBX_PM_SLEEPUNTILRESTART
-#define PWR_WAKEUP              MBX_PM_DSPWAKEUP
-#define PWR_AUTOENABLE          MBX_PM_PWRENABLE
-#define PWR_AUTODISABLE         MBX_PM_PWRDISABLE
-#define PWR_RETENTION             MBX_PM_DSPRETN
-
-#endif				/* PWR_SH_ */
--- a/arch/arm/plat-omap/include/bridge/reg.h
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/reg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== reg.h ========
- *  Purpose:
- *      Provide registry functions.
- *
- *  Public Functions:
- *      REG_DeleteValue
- *      REG_EnumKey
- *      REG_EnumValue
- *      REG_Exit
- *      REG_GetValue
- *      REG_Init
- *      REG_SetValue
- *
- *! Revision History:
- *! =================
- *! 30-Oct-2000 kc: Updated REG_SetValue & REG_GetValue; renamed
- *!                 REG_DeleteEntry to REG_DeleteValue.
- *! 29-Sep-2000 kc: Updated a REG functions for code review.
- *! 12-Aug-2000 kc: Renamed REG_EnumValue to REG_EnumKey. Re-implemented
- *!                 REG_EnumValue.
- *! 03-Feb-2000 rr: REG_EnumValue Fxn Added
- *! 13-Dec-1999 rr: windows.h removed
- *! 02-Dec-1999 rr: windows.h included for retail build
- *! 22-Nov-1999 kc: Changes from code review.
- *! 29-Dec-1997 cr: Changes from code review.
- *! 27-Oct-1997 cr: Added REG_DeleteValue.
- *! 20-Oct-1997 cr: Added ability to pass bValue = NULL to REG_GetValue
- *!                 and return size of reg entry in pdwValueSize.
- *! 29-Sep-1997 cr: Added REG_SetValue
- *! 29-Aug-1997 cr: Created.
- */
-
-#ifndef _REG_H
-#define _REG_H
-
-#include <linux/types.h>
-
-/*  ------------------------- Defines, Data Structures, Typedefs for Linux */
-#ifndef UNDER_CE
-
-#ifndef REG_SZ
-#define REG_SZ          1
-#endif
-
-#ifndef REG_BINARY
-#define REG_BINARY      3
-#endif
-
-#ifndef REG_DWORD
-#define REG_DWORD       4
-#endif
-
-#endif				/* UNDER_CE */
-
-#define REG_MAXREGPATHLENGTH    255
-
-/*
- *  ======== REG_DeleteValue ========
- *  Purpose:
- *      Deletes a registry entry. NOTE: A registry entry is not the same as
- *      a registry key.
- *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrSubkey: Path to key to open.
- *      pstrValue:  Name of entry to delete.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrSubkey & pstrValue are non-NULL values.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
- *      - length of pstrValue < REG_MAXREGPATHLENGTH.
- *  Ensures:
- *  Details:
- */
-	extern DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey,
-					  IN CONST char *pstrSubkey,
-					  IN CONST char *pstrValue);
-
-/*
- *  ======== REG_EnumKey ========
- *  Purpose:
- *      Enumerates subkeys of the specified path to the  registry key
- *      Retrieves the  name of the subkey(given the index) and
- *      appends with the orignal path to form the full path.
- *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrKey     The name of the registry key to be enumerated.
- *      dwIndex     Specifies the index of the subkey to retrieve.
- *      pstrSubkey: Pointer to buffer that receives full path name of the
- *                  specified key + the sub-key
- *      pdwValueSize:   Specifies bytes of memory pstrSubkey points to on input,
- *                      on output, specifies actual memory bytes written into.
- *                      If there is no sub key,pdwValueSize returns NULL.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrKey is non-NULL value.
- *      - pdwValueSize is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrKey < REG_MAXREGPATHLENGTH.
- *  Ensures:
- *      - strlen(pstrSubkey) is > strlen(pstrKey) &&
- *      - strlen(pstrSubkey) is < REG_MAXREGPATHLENGTH
- */
-	extern DSP_STATUS REG_EnumKey(OPTIONAL IN HANDLE *phKey,
-				      IN u32 dwIndex, IN CONST char *pstrKey,
-				      IN OUT char *pstrSubkey,
-				      IN OUT u32 *pdwValueSize);
-
-/*
- *  ======== REG_EnumValue ========
- *  Purpose:
- *      Enumerates values of a specified key. Retrieves each value name and
- *      the data associated with the value.
- *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
- *      dwIndex:        Specifies the index of the value to retrieve.
- *      pstrKey:        The name of the registry key to be enumerated.
- *      pstrValue:      Pointer to buffer that receives the name of the value.
- *      pdwValueSize:   Specifies bytes of memory pstrValue points to on input,
- *                      On output, specifies actual memory bytes written into.
- *                      If there is no value, pdwValueSize returns NULL
- *      pstrData:       Pointer to buffer that receives the data of a value.
- *      pdwDataSize:    Specifies bytes of memory in pstrData on input and
- *                      bytes of memory written into pstrData on output.
- *                      If there is no data, pdwDataSize returns NULL.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      REG initialized.
- *      phKey is NULL.
- *      pstrKey is a non-NULL value.
- *      pstrValue, pstrData, pdwValueSize and pdwDataSize are valid pointers.
- *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
- *  Ensures:
- */
-	extern DSP_STATUS REG_EnumValue(IN HANDLE *phKey,
-					IN u32 dwIndex,
-					IN CONST char *pstrKey,
-					IN OUT char *pstrValue,
-					IN OUT u32 *pdwValueSize,
-					IN OUT char *pstrData,
-					IN OUT u32 *pdwDataSize);
-
-/*
- *  ======== REG_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      REG initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void REG_Exit();
-
-/*
- *  ======== REG_GetValue ========
- *  Purpose:
- *      Retrieve a value from the registry.
- *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
- *      pstrSubkey:     Path to key to open.
- *      pstrEntry:      Name of entry to retrieve.
- *      pbValue:        Upon return, points to retrieved value.
- *      pdwValueSize:   Specifies bytes of memory pbValue points to on input,
- *                      on output, specifies actual memory bytes written into.
- *                      If pbValue is NULL, pdwValueSize reports the size of
- *                      the entry in pstrEntry.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
- *      - pbValue is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
- *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
- *  Ensures:
- */
-	extern DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubkey,
-				       IN CONST char *pstrEntry,
-				       OUT u8 *pbValue,
-				       IN OUT u32 *pdwValueSize);
-
-/*
- *  ======== REG_Init ========
- *  Purpose:
- *      Initializes private state of REG module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      REG initialized.
- */
-	extern bool REG_Init();
-
-/*
- *  ======== REG_SetValue ========
- *  Purpose:
- *      Set a value in the registry.
- *  Parameters:
- *      phKey:          Handle to open reg key, or NULL if pSubkey is full path.
- *      pstrSubkey:     Path to key to open, could be based on phKey.
- *      pstrEntry:      Name of entry to set.
- *      dwType:         Data type of new registry value.
- *      pbValue:        Points to buffer containing new data.
- *      dwValueSize:    Specifies bytes of memory bValue points to.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
- *      - pbValue is a valid pointer.
- *      - phKey is NULL.
- *      - dwValuSize > 0.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
- *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
- *  Ensures:
- */
-	extern DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubKey,
-				       IN CONST char *pstrEntry,
-				       IN CONST u32 dwType,
-				       IN u8 *pbValue, IN u32 dwValueSize);
-
-#endif				/* _REG_H */
--- a/arch/arm/plat-omap/include/bridge/resourcecleanup.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/resourcecleanup.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef RES_CLEANUP_DISABLE
-
-#include <nodepriv.h>
-#include <drv.h>
-
-
-extern DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
-				struct DRV_OBJECT *hDrvObject);
-
-extern DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject,
-					HANDLE hPCtxt);
-
-extern DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE pCtxt);
-
-extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcUpdatestate(HANDLE pCtxt,
-				      enum GPP_PROC_RES_STATE resState);
-
-extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
-
-extern DSP_STATUS DRV_GetProcContext(u32 phProcess,
-				struct DRV_OBJECT *hDrvObject,
-				HANDLE hPCtxt, DSP_HNODE hNode,
-				u32 pMapAddr);
-
-extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
-
-extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE hPCtxt, HANDLE hProcess);
-
-extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					HANDLE pCtxt);
-
-extern DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					    HANDLE pCtxt);
-
-extern void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status);
-
-extern DSP_STATUS DRV_RemoveNodeResElement(HANDLE nodeRes, HANDLE status);
-
-extern void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status);
-
-extern DSP_STATUS DRV_UpdateDMMResElement(HANDLE dmmRes, u32 pMpuAddr,
-					  u32 ulSize, u32 pReqAddr,
-					  u32 ppMapAddr, HANDLE hProcesso);
-
-extern DSP_STATUS DRV_InsertDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
-
-extern DSP_STATUS DRV_GetDMMResElement(u32 pMapAddr, HANDLE dmmRes,
-				       HANDLE pCtxt);
-
-extern DSP_STATUS DRV_RemoveDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes,
-					HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-						HANDLE pPctxt);
-
-extern DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-					HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcRemoveSTRMResElement(HANDLE STRMRes, HANDLE pCtxt);
-
-extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf, u32 *pSize);
-
-extern enum NODE_STATE NODE_GetState(HANDLE hNode);
-
-#endif
--- a/arch/arm/plat-omap/include/bridge/rmm.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/rmm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== rmm.h ========
- *
- *  This memory manager provides general heap management and arbitrary
- *  alignment for any number of memory segments, and management of overlay
- *  memory.
- *
- *  Public functions:
- *      RMM_alloc
- *      RMM_create
- *      RMM_delete
- *      RMM_exit
- *      RMM_free
- *      RMM_init
- *
- *! Revision History
- *! ================
- *! 25-Jun-2002 jeh     Added RMM_Addr. Removed RMM_reserve, RMM_stat.
- *! 15-Oct-2001 jeh     Based on rm.h in gen tree.
- */
-
-#ifndef RMM_
-#define RMM_
-
-/*
- *  ======== RMM_Addr ========
- *  DSP address + segid
- */
-struct RMM_Addr {
-	u32 addr;
-	s32 segid;
-} ;
-
-/*
- *  ======== RMM_Segment ========
- *  Memory segment on the DSP available for remote allocations.
- */
-struct RMM_Segment {
-	u32 base;		/* Base of the segment */
-	u32 length;		/* Size of the segment (target MAUs) */
-	s32 space;		/* Code or data */
-	u32 number;		/* Number of Allocated Blocks */
-} ;
-
-/*
- *  ======== RMM_Target ========
- */
-struct RMM_TargetObj;
-
-/*
- *  ======== RMM_alloc ========
- *
- *  RMM_alloc is used to remotely allocate or reserve memory on the DSP.
- *
- *  Parameters:
- *      target          - Target returned from RMM_create().
- *      segid           - Memory segment to allocate from.
- *      size            - Size (target MAUS) to allocate.
- *      align           - alignment.
- *      dspAddr         - If reserve is FALSE, the location to store allocated
- *                        address on output, otherwise, the DSP address to
- *                        reserve.
- *      reserve         - If TRUE, reserve the memory specified by dspAddr.
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EMEMORY:            Memory allocation on GPP failed.
- *      DSP_EOVERLAYMEMORY:     Cannot "allocate" overlay memory because it's
- *                              already in use.
- *  Requires:
- *      RMM initialized.
- *      Valid target.
- *      dspAddr != NULL.
- *      size > 0
- *      reserve || target->numSegs > 0.
- *  Ensures:
- */
-extern DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
-			    u32 align, u32 *dspAdr, bool reserve);
-
-/*
- *  ======== RMM_create ========
- *  Create a target object with memory segments for remote allocation. If
- *  segTab == NULL or numSegs == 0, memory can only be reserved through
- *  RMM_alloc().
- *
- *  Parameters:
- *      pTarget:        - Location to store target on output.
- *      segTab:         - Table of memory segments.
- *      numSegs:        - Number of memory segments.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      RMM initialized.
- *      pTarget != NULL.
- *      numSegs == 0 || segTab != NULL.
- *  Ensures:
- *      Success:        Valid *pTarget.
- *      Failure:        *pTarget == NULL.
- */
-extern DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
-			     struct RMM_Segment segTab[], u32 numSegs);
-
-/*
- *  ======== RMM_delete ========
- *  Delete target allocated in RMM_create().
- *
- *  Parameters:
- *      target          - Target returned from RMM_create().
- *  Returns:
- *  Requires:
- *      RMM initialized.
- *      Valid target.
- *  Ensures:
- */
-extern void RMM_delete(struct RMM_TargetObj *target);
-
-/*
- *  ======== RMM_exit ========
- *  Exit the RMM module
- *
- *  Parameters:
- *  Returns:
- *  Requires:
- *      RMM_init successfully called.
- *  Ensures:
- */
-extern void RMM_exit(void);
-
-/*
- *  ======== RMM_free ========
- *  Free or unreserve memory allocated through RMM_alloc().
- *
- *  Parameters:
- *      target:         - Target returned from RMM_create().
- *      segid:          - Segment of memory to free.
- *      dspAddr:        - Address to free or unreserve.
- *      size:           - Size of memory to free or unreserve.
- *      reserved:       - TRUE if memory was reserved only, otherwise FALSE.
- *  Returns:
- *  Requires:
- *      RMM initialized.
- *      Valid target.
- *      reserved || segid < target->numSegs.
- *      reserve || [dspAddr, dspAddr + size] is a valid memory range.
- *  Ensures:
- */
-extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
-		     u32 size, bool reserved);
-
-/*
- *  ======== RMM_init ========
- *  Initialize the RMM module
- *
- *  Parameters:
- *  Returns:
- *      TRUE:   Success.
- *      FALSE:  Failure.
- *  Requires:
- *  Ensures:
- */
-extern bool RMM_init(void);
-
-/*
- *  ======== RMM_stat ========
- *  Obtain  memory segment status
- *
- *  Parameters:
- *      segid:       Segment ID of the dynamic loading segment.
- *      pMemStatBuf: Pointer to allocated buffer into which memory stats are
- *                   placed.
- *  Returns:
- *      TRUE:   Success.
- *      FALSE:  Failure.
- *  Requires:
- *      segid < target->numSegs
- *  Ensures:
- */
-extern bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
-		     struct DSP_MEMSTAT *pMemStatBuf);
-
-#endif				/* RMM_ */
--- a/arch/arm/plat-omap/include/bridge/rms_sh.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/rms_sh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== rms_sh.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
- *  GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 24-Mar-2003 vp  Merged updates required for CCS2.2 transition.
- *! 24-Feb-2003 kc  Rearranged order of node types to temporarily support
- *!		    legacy message node code
- *! 23-Nov-2002 gp  Converted tabs -> spaces, to fix formatting.
- *! 13-Feb-2002 jeh Added sysstacksize element to RMS_MoreTaskArgs.
- *! 11-Dec-2000 sg  Added 'misc' element to RMS_MoreTaskArgs.
- *! 04-Dec-2000 ag  Added RMS_BUFDESC command code.
- *!                 C/R code value changed to allow ORing of system/user codes.
- *! 10-Oct-2000 sg  Added 'align' field to RMS_StrmDef.
- *! 09-Oct-2000 sg  Moved pre-defined message codes here from rmsdefs.h.
- *! 02-Oct-2000 sg  Changed ticks to msec.
- *! 24-Aug-2000 sg  Moved definitions that will be exposed to app developers
- *!  		    to a separate file, rmsdefs.h.
- *! 10-Aug-2000 sg  Added RMS_COMMANDBUFSIZE and RMS_RESPONSEBUFSIZE; added
- *!		    pre-defined command/response codes; more comments.
- *! 09-Aug-2000 sg  Added RMS_ETASK.
- *! 08-Aug-2000 jeh Define RMS_WORD for GPP, rename DSP_MSG to RMS_DSPMSG.
- *!                 Added RMS_MsgArgs, RMS_MoreTaskArgs.
- *! 25-Jul-2000 sg: Changed SIO to STRM.
- *! 30-Jun-2000 sg: Initial.
- */
-
-#ifndef RMS_SH_
-#define RMS_SH_
-
-#include <rmstypes.h>
-
-/* Node Types: */
-#define RMS_TASK                1	/* Task node */
-#define RMS_DAIS                2	/* xDAIS socket node */
-#define RMS_MSG                 3	/* Message node */
-
-/* Memory Types: */
-#define RMS_CODE                0	/* Program space */
-#define RMS_DATA                1	/* Data space */
-#define RMS_IO                	2	/* I/O space */
-
-/* RM Server Command and Response Buffer Sizes: */
-#define RMS_COMMANDBUFSIZE     256	/* Size of command buffer */
-#define RMS_RESPONSEBUFSIZE    16	/* Size of response buffer */
-
-/* Pre-Defined Command/Response Codes: */
-#define RMS_EXIT                0x80000000   /* GPP->Node: shutdown */
-#define RMS_EXITACK             0x40000000   /* Node->GPP: ack shutdown */
-#define RMS_BUFDESC             0x20000000   /* Arg1 SM buf, Arg2 is SM size */
-#define RMS_KILLTASK            0x10000000  /* GPP->Node: Kill Task */
-#define RMS_USER                0x0	/* Start of user-defined msg codes */
-#define RMS_MAXUSERCODES        0xfff	/* Maximum user defined C/R Codes */
-
-
-/* RM Server RPC Command Structure: */
-	struct RMS_Command {
-		RMS_WORD fxn;	/* Server function address */
-		RMS_WORD arg1;	/* First argument */
-		RMS_WORD arg2;	/* Second argument */
-		RMS_WORD data;	/* Function-specific data array */
-	} ;
-
-/*
- *  The RMS_StrmDef structure defines the parameters for both input and output
- *  streams, and is passed to a node's create function.
- */
-	struct RMS_StrmDef {
-		RMS_WORD bufsize;	/* Buffer size (in DSP words) */
-		RMS_WORD nbufs;	/* Max number of bufs in stream */
-		RMS_WORD segid;	/* Segment to allocate buffers */
-		RMS_WORD align;	/* Alignment for allocated buffers */
-		RMS_WORD timeout;	/* Timeout (msec) for blocking calls */
-		RMS_CHAR name[1];	/* Device Name (terminated by '\0') */
-	} ;
-
-/* Message node create args structure: */
-	struct RMS_MsgArgs {
-		RMS_WORD maxMessages;	/* Max # simultaneous msgs to node */
-		RMS_WORD segid;	/* Mem segment for NODE_allocMsgBuf */
-		RMS_WORD notifyType;	/* Type of message notification */
-		RMS_WORD argLength;	/* Length (in DSP chars) of arg data */
-		RMS_WORD argData;	/* Arg data for node */
-	} ;
-
-/* Partial task create args structure */
-	struct RMS_MoreTaskArgs {
-		RMS_WORD priority;	/* Task's runtime priority level */
-		RMS_WORD stackSize;	/* Task's stack size */
-		RMS_WORD sysstackSize;	/* Task's system stack size (55x) */
-		RMS_WORD stackSeg;	/* Memory segment for task's stack */
-		RMS_WORD heapAddr;   /* base address of the node memory heap in
-				      * external memory (DSP virtual address) */
-		RMS_WORD heapSize;   /* size in MAUs of the node memory heap in
-				      * external memory */
-		RMS_WORD misc;	/* Misc field.  Not used for 'normal'
-				 * task nodes; for xDAIS socket nodes
-				 * specifies the IALG_Fxn pointer.
-				 */
-		/* # input STRM definition structures */
-		RMS_WORD numInputStreams;
-	} ;
-
-#endif				/* RMS_SH_ */
-
--- a/arch/arm/plat-omap/include/bridge/rmstypes.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/rmstypes.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== rmstypes.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared data type definitions.
- *
- *! Revision History
- *! ================
- *! 06-Oct-2000 sg  Added LgFxn type.
- *! 05-Oct-2000 sg  Changed RMS_STATUS to LgUns.
- *! 31-Aug-2000 sg  Added RMS_DSPMSG.
- *! 25-Aug-2000 sg  Initial.
- */
-
-#ifndef RMSTYPES_
-#define RMSTYPES_
-#include <linux/types.h>
-/*
- *  DSP-side definitions.
- */
-#include <std.h>
-typedef u32 RMS_WORD;
-typedef char RMS_CHAR;
-
-#endif				/* RMSTYPES_ */
--- a/arch/arm/plat-omap/include/bridge/services.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/services.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== services.h ========
- *  Purpose:
- *      Provide loading and unloading of SERVICES modules.
- *
- *  Public Functions:
- *      SERVICES_Exit()
- *      SERVICES_Init()
- *
- *! Revision History:
- *! ================
- *! 01-Feb-2000 kc: Created.
- */
-
-#ifndef SERVICES_
-#define SERVICES_
-
-#include <host_os.h>
-/*
- *  ======== SERVICES_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      SERVICES initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void SERVICES_Exit();
-
-/*
- *  ======== SERVICES_Init ========
- *  Purpose:
- *      Initializes SERVICES modules.
- *  Parameters:
- *  Returns:
- *      TRUE if all modules initialized; otherwise FALSE.
- *  Requires:
- *  Ensures:
- *      SERVICES modules initialized.
- */
-	extern bool SERVICES_Init();
-
-#endif				/* SERVICES_ */
--- a/arch/arm/plat-omap/include/bridge/std.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/std.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== std.h ========
- *
- *! Revision History
- *! ================
- *! 16-Feb-2004 vp	GNU compiler 3.x defines inline keyword. Added
- *!			appropriate macros not to redefine inline keyword in
- *!			this file.
- *! 24-Oct-2002	ashu	defined _TI_ and _FIXED_ symbols for 28x.
- *! 24-Oct-2002	ashu	defined _TI_ for 24x.
- *! 01-Mar-2002 kln	changed LARGE_MODEL and Arg definition for 28x
- *! 01-Feb-2002 kln	added definitions for 28x
- *! 08-Dec-2000 kw:	added 'ArgToInt' and 'ArgToPtr' macros
- *! 30-Nov-2000 mf:	Added _64_, _6x_; removed _7d_
- *! 30-May-2000 srid:	Added   __TMS320C55X__ for 55x; Arg is void * for 55 .
- *! 18-Jun-1999 dr:	Added '_TI_', fixed __inline for SUN4, added inline
- *! 10-Feb-1999 rt:	Added '55' support, changed 54's symbol to _TMS320C5XX
- *! 29-Aug-1998 mf: 	fixed typo, removed obsolete targets
- *! 08-Jun-1998 mf: 	_67_ is synonym for _7d_
- *! 10-Oct-1997 rt;	added _7d_ for Raytheon C7DSP triggered by _TMS320C6700
- *! 04-Aug-1997 cc:	added _29_ for _TMS320C2XX
- *! 11-Jul-1997 dlr:	_5t_, and STD_SPOXTASK keyword for Tasking
- *! 12-Jun-1997 mf: 	_TMS320C60 -> _TMS320C6200
- *! 13-Feb-1997 mf:	_62_, with 32-bit LgInt
- *! 26-Nov-1996 kw: 	merged bios-c00's and wsx-a27's <std.h> changes
- *!			*and* revision history
- *! 12-Sep-1996 kw: 	added C54x #ifdef's
- *! 21-Aug-1996 mf: 	removed #define main smain for _21_
- *! 14-May-1996 gp:     def'd out INT, FLOAT, and COMPLEX defines for WSX.
- *! 11-Apr-1996 kw:     define _W32_ based on _WIN32 (defined by MS compiler)
- *! 07-Mar-1996 mg:     added Win32 support
- *! 06-Sep-1995 dh:	added _77_ dynamic stack support via fxns77.h
- *! 27-Jun-1995 dh:	added _77_ support
- *! 16-Mar-1995 mf: 	for _21_: #define main smain
- *! 01-Mar-1995 mf: 	set _20_ and _60_ (as well as _21_ for both)
- *! 22-Feb-1995 mf: 	Float is float for _SUN_ and _80_
- *! 22-Dec-1994 mf: 	Added _80_ definition, for PP or MP.
- *! 09-Dec-1994 mf: 	Added _53_ definition.
- *!			Added definitions of _30_, etc.
- *! 23-Aug-1994 dh	removed _21_ special case (kw)
- *! 17-Aug-1994 dh	added _51_ support
- *! 03-Aug-1994 kw	updated _80_ support
- *! 30-Jun-1994 kw	added _80_ support
- *! 05-Apr-1994 kw:	Added _SUN_ to _FLOAT_ definition
- *! 01-Mar-1994 kw: 	Made Bool an int (was u16) for _56_ (more efficient).
- *!			Added _53_ support.
- */
-
-#ifndef STD_
-#define STD_
-
-#include <linux/types.h>
-
-/*
- *  ======== _TI_ ========
- *  _TI_ is defined for all TI targets
- */
-#if defined(_29_) || defined(_30_) || defined(_40_) || defined(_50_) || \
-    defined(_54_) || defined(_55_) || defined(_6x_) || defined(_80_) || \
-    defined(_28_) || defined(_24_)
-#define _TI_	1
-#endif
-
-/*
- *  ======== _FLOAT_ ========
- *  _FLOAT_ is defined for all targets that natively support floating point
- */
-#if defined(_SUN_) || defined(_30_) || defined(_40_) || defined(_67_) || \
-    defined(_80_)
-#define _FLOAT_	1
-#endif
-
-/*
- *  ======== _FIXED_ ========
- *  _FIXED_ is defined for all fixed point target architectures
- */
-#if defined(_29_) || defined(_50_) || defined(_54_) || defined(_55_) || \
-    defined(_62_) || defined(_64_) || defined(_28_)
-#define _FIXED_	1
-#endif
-
-/*
- *  ======== _TARGET_ ========
- *  _TARGET_ is defined for all target architectures (as opposed to
- *  host-side software)
- */
-#if defined(_FIXED_) || defined(_FLOAT_)
-#define _TARGET_ 1
-#endif
-
-/*
- *  8, 16, 32-bit type definitions
- *
- *  Sm*	- 8-bit type
- *  Md* - 16-bit type
- *  Lg* - 32-bit type
- *
- *  *s32 - signed type
- *  *u32 - unsigned type
- *  *Bits - unsigned type (bit-maps)
- */
-
-/*
- *  Aliases for standard C types
- */
-
-typedef s32(*Fxn) ();		/* generic function type */
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-
-/*
- * These macros are used to cast 'Arg' types to 's32' or 'Ptr'.
- * These macros were added for the 55x since Arg is not the same
- * size as s32 and Ptr in 55x large model.
- */
-#if defined(_28l_) || defined(_55l_)
-#define ArgToInt(A)	((s32)((long)(A) & 0xffff))
-#define ArgToPtr(A)	((Ptr)(A))
-#else
-#define ArgToInt(A)	((s32)(A))
-#define ArgToPtr(A)	((Ptr)(A))
-#endif
-
-#endif				/* STD_ */
--- a/arch/arm/plat-omap/include/bridge/strmdefs.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/strmdefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== strmdefs.h ========
- *  Purpose:
- *      Global STRM constants and types.
- *
- *! Revision History
- *! ================
- *! 19-Nov-2001 ag      Added STRM_INFO..
- *! 25-Sep-2000 jeh     Created.
- */
-
-#ifndef STRMDEFS_
-#define STRMDEFS_
-
-#define STRM_MAXEVTNAMELEN      32
-
-	struct STRM_MGR;
-
-	struct STRM_OBJECT;
-
-	struct STRM_ATTR {
-		HANDLE hUserEvent;
-		char *pstrEventName;
-		void *pVirtBase;	/* Process virtual base address of
-					 * mapped SM */
-		u32 ulVirtSize;	/* Size of virtual space in bytes */
-		struct DSP_STREAMATTRIN *pStreamAttrIn;
-	} ;
-
-	struct STRM_INFO {
-		enum DSP_STRMMODE lMode;	/* transport mode of
-					 * stream(DMA, ZEROCOPY..) */
-		u32 uSegment;	/* Segment strm allocs from. 0 is local mem */
-		void *pVirtBase;	/* "      " Stream'process virt base */
-		struct DSP_STREAMINFO *pUser;	/* User's stream information
-						 * returned */
-	} ;
-
-#endif				/* STRMDEFS_ */
-
--- a/arch/arm/plat-omap/include/bridge/strm.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/strm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== strm.h ========
- *  Description:
- *      DSPBridge Stream Manager.
- *
- *  Public Functions:
- *      STRM_AllocateBuffer
- *      STRM_Close
- *      STRM_Create
- *      STRM_Delete
- *      STRM_Exit
- *      STRM_FreeBuffer
- *      STRM_GetEventHandle
- *      STRM_GetInfo
- *      STRM_Idle
- *      STRM_Init
- *      STRM_Issue
- *      STRM_Open
- *      STRM_PrepareBuffer
- *      STRM_Reclaim
- *      STRM_RegisterNotify
- *      STRM_Select
- *      STRM_UnprepareBuffer
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 15-Nov-2001 ag  Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
- *!                 Added DSP_ESIZE error to STRM_AllocateBuffer().
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 10-May-2001 jeh Code review cleanup.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 06-Feb-2001 kc  Updated DBC_Ensure for STRM_Select().
- *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open().
- *! 25-Sep-2000 jeh Created.
- */
-
-#ifndef STRM_
-#define STRM_
-
-#include <dev.h>
-
-#include <strmdefs.h>
-
-/*
- *  ======== STRM_AllocateBuffer ========
- *  Purpose:
- *      Allocate data buffer(s) for use with a stream.
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer(s).
- *      uNumBufs:       Number of buffers to allocate.
- *      apBuffer:       Array to hold buffer addresses.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
- *      DSP_ESIZE:      uSize must be > 0 bytes.
- *  Requires:
- *      STRM_Init() called.
- *      apBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
-					      u32 uSize,
-					      OUT u8 **apBuffer,
-					      u32 uNumBufs);
-
-/*
- *  ======== STRM_Close ========
- *  Purpose:
- *      Close a stream opened with STRM_Open().
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EPENDING:   Some data buffers issued to the stream have not
- *                      been reclaimed.
- *      DSP_EFAIL:      Failure to close stream.
- *  Requires:
- *      STRM_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm);
-
-/*
- *  ======== STRM_Create ========
- *  Purpose:
- *      Create a STRM manager object. This object holds information about the
- *      device needed to open streams.
- *  Parameters:
- *      phStrmMgr:      Location to store handle to STRM manager object on
- *                      output.
- *      hDev:           Device for this processor.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      General failure.
- *  Requires:
- *      STRM_Init() called.
- *      phStrmMgr != NULL.
- *      hDev != NULL.
- *  Ensures:
- *      DSP_SOK:        Valid *phStrmMgr.
- *      error:          *phStrmMgr == NULL.
- */
-	extern DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr,
-				      struct DEV_OBJECT *hDev);
-
-/*
- *  ======== STRM_Delete ========
- *  Purpose:
- *      Delete the STRM Object.
- *  Parameters:
- *      hStrmMgr:       Handle to STRM manager object from STRM_Create.
- *  Returns:
- *  Requires:
- *      STRM_Init() called.
- *      Valid hStrmMgr.
- *  Ensures:
- *      hStrmMgr is not valid.
- */
-	extern void STRM_Delete(struct STRM_MGR *hStrmMgr);
-
-/*
- *  ======== STRM_Exit ========
- *  Purpose:
- *      Discontinue usage of STRM module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      STRM_Init() successfully called before.
- *  Ensures:
- */
-	extern void STRM_Exit();
-
-/*
- *  ======== STRM_FreeBuffer ========
- *  Purpose:
- *      Free buffer(s) allocated with STRM_AllocateBuffer.
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      apBuffer:       Array containing buffer addresses.
- *      uNumBufs:       Number of buffers to be freed.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid stream handle.
- *      DSP_EFAIL:      Failure occurred, unable to free buffers.
- *  Requires:
- *      STRM_Init() called.
- *      apBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
-					  u8 **apBuffer, u32 uNumBufs);
-
-/*
- *  ======== STRM_GetEventHandle ========
- *  Purpose:
- *      Get stream's user event handle. This function is used when closing
- *      a stream, so the event can be closed.
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      phEvent:        Location to store event handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *  Requires:
- *      STRM_Init() called.
- *      phEvent != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_GetEventHandle(struct STRM_OBJECT *hStrm,
-					      OUT HANDLE *phEvent);
-
-/*
- *  ======== STRM_GetInfo ========
- *  Purpose:
- *      Get information about a stream. User's DSP_STREAMINFO is contained
- *      in STRM_INFO struct. STRM_INFO also contains Bridge private info.
- *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pStreamInfo:        Location to store stream info on output.
- *      uSteamInfoSize:     Size of user's DSP_STREAMINFO structure.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hStrm.
- *      DSP_ESIZE:          uStreamInfoSize < sizeof(DSP_STREAMINFO).
- *      DSP_EFAIL:          Unable to get stream info.
- *  Requires:
- *      STRM_Init() called.
- *      pStreamInfo != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
-				       OUT struct STRM_INFO *pStreamInfo,
-				       u32 uStreamInfoSize);
-
-/*
- *  ======== STRM_Idle ========
- *  Purpose:
- *      Idle a stream and optionally flush output data buffers.
- *      If this is an output stream and fFlush is TRUE, all data currently
- *      enqueued will be discarded.
- *      If this is an output stream and fFlush is FALSE, this function
- *      will block until all currently buffered data is output, or the timeout
- *      specified has been reached.
- *      After a successful call to STRM_Idle(), all buffers can immediately
- *      be reclaimed.
- *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      fFlush:         If TRUE, discard output buffers.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_ETIMEOUT:   A timeout occurred before the stream could be idled.
- *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
- *      DSP_EFAIL:      Unable to idle stream.
- *  Requires:
- *      STRM_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush);
-
-/*
- *  ======== STRM_Init ========
- *  Purpose:
- *      Initialize the STRM module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialization succeeded, FALSE otherwise.
- *  Requires:
- *  Ensures:
- */
-	extern bool STRM_Init();
-
-/*
- *  ======== STRM_Issue ========
- *  Purpose:
- *      Send a buffer of data to a stream.
- *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pBuf:               Pointer to buffer of data to be sent to the stream.
- *      ulBytes:            Number of bytes of data in the buffer.
- *      ulBufSize:          Actual buffer size in bytes.
- *      dwArg:              A user argument that travels with the buffer.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hStrm.
- *      DSP_ESTREAMFULL:    The stream is full.
- *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
- *  Requires:
- *      STRM_Init() called.
- *      pBuf != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf,
-				     u32 ulBytes, u32 ulBufSize,
-				     IN u32 dwArg);
-
-/*
- *  ======== STRM_Open ========
- *  Purpose:
- *      Open a stream for sending/receiving data buffers to/from a task of
- *      DAIS socket node on the DSP.
- *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      uDir:           DSP_TONODE or DSP_FROMNODE.
- *      uIndex:         Stream index.
- *      pAttr:          Pointer to structure containing attributes to be
- *                      applied to stream. Cannot be NULL.
- *      phStrm:         Location to store stream handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_EDIRECTION: Invalid uDir.
- *      DSP_EVALUE:     Invalid uIndex.
- *      DSP_ENODETYPE:  hNode is not a task or DAIS socket node.
- *      DSP_EFAIL:      Unable to open stream.
- *  Requires:
- *      STRM_Init() called.
- *      phStrm != NULL.
- *      pAttr != NULL.
- *  Ensures:
- *      DSP_SOK:        *phStrm is valid.
- *      error:          *phStrm == NULL.
- */
-	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
-				    u32 uIndex, IN struct STRM_ATTR *pAttr,
-				    OUT struct STRM_OBJECT **phStrm);
-
-/*
- *  ======== STRM_PrepareBuffer ========
- *  Purpose:
- *      Prepare a data buffer not allocated by DSPStream_AllocateBuffers()
- *      for use with a stream.
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
- *  Requires:
- *      STRM_Init() called.
- *      pBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_PrepareBuffer(struct STRM_OBJECT *hStrm,
-					     u32 uSize,
-					     u8 *pBuffer);
-
-/*
- *  ======== STRM_Reclaim ========
- *  Purpose:
- *      Request a buffer back from a stream.
- *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      pBufPtr:        Location to store pointer to reclaimed buffer.
- *      pulBytes:       Location where number of bytes of data in the
- *                      buffer will be written.
- *      pulBufSize:     Location where actual buffer size will be written.
- *      pdwArg:         Location where user argument that travels with
- *                      the buffer will be written.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_ETIMEOUT:   A timeout occurred before a buffer could be
- *                      retrieved.
- *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
- *  Requires:
- *      STRM_Init() called.
- *      pBufPtr != NULL.
- *      pulBytes != NULL.
- *      pdwArg != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm,
-				       OUT u8 **pBufPtr, u32 *pulBytes,
-				       u32 *pulBufSize, u32 *pdwArg);
-
-/*
- *  ======== STRM_RegisterNotify ========
- *  Purpose:
- *      Register to be notified on specific events for this stream.
- *  Parameters:
- *      hStrm:          Stream handle returned by STRM_Open().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
- *                      supported.
- *  Requires:
- *      STRM_Init() called.
- *      hNotification != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
-
-/*
- *  ======== STRM_Select ========
- *  Purpose:
- *      Select a ready stream.
- *  Parameters:
- *      aStrmTab:       Array of stream handles returned from STRM_Open().
- *      nStrms:         Number of stream handles in array.
- *      pMask:          Location to store mask of ready streams on output.
- *      uTimeout:       Timeout value (milliseconds).
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ERANGE:     nStrms out of range.
-
- *      DSP_EHANDLE:    Invalid stream handle in array.
- *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
- *      DSP_EFAIL:      Failure occurred, unable to select a stream.
- *  Requires:
- *      STRM_Init() called.
- *      aStrmTab != NULL.
- *      nStrms > 0.
- *      pMask != NULL.
- *  Ensures:
- *      DSP_SOK:        *pMask != 0 || uTimeout == 0.
- *      Error:          *pMask == 0.
- */
-	extern DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab,
-				      u32 nStrms,
-				      OUT u32 *pMask, u32 uTimeout);
-
-/*
- *  ======== STRM_UnprepareBuffer ========
- *  Purpose:
- *      Unprepare a data buffer that was previously prepared for a stream
- *      with DSPStream_PrepareBuffer(), and that will no longer be used with
- *      the stream.
- *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
- *  Requires:
- *      STRM_Init() called.
- *      pBuffer != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS STRM_UnprepareBuffer(struct STRM_OBJECT *hStrm,
-					       u32 uSize,
-					       u8 *pBuffer);
-
-#endif				/* STRM_ */
--- a/arch/arm/plat-omap/include/bridge/sync.h
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/sync.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== sync.h ========
- *  Purpose:
- *      Provide synchronization services.
- *
- *  Public Functions:
- *      SYNC_CloseEvent
- *      SYNC_DeleteCS
- *      SYNC_EnterCS
- *      SYNC_Exit
- *      SYNC_Init
- *      SYNC_InitializeCS
- *      SYNC_LeaveCS
- *      SYNC_OpenEvent
- *      SYNC_PostMessage
- *      SYNC_ResetEvent
- *      SYNC_SetEvent
- *      SYNC_WaitOnEvent
- *      SYNC_WaitOnMultipleEvents
- *
- *! Revision History:
- *! ================
- *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
- *! 01-Dec-1999 ag: Added #define SYNC_MAXNAMELENGTH.
- *! 04-Nov-1999 kc: Added critical section functions and objects to SYNC.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 24-Sep-1999 kc: Added WinCE notes.
- *! 20-Oct-1997 gp: Removed unused SYNC_ critical section and must complete fxns
- *!                 Added SYNC_HOBJECT, SYNC_ATTRS, and object validation, and
- *!                 merged SYNC_DestroyEvent into SYNC_CloseEvent, and merged
- *!                 SYNC_CreateEvent into SYNC_OpenEvent.
- *! 07-Oct-1997 gp: Added SYNC_Create/DestroyEvent (for NT testing).
- *! 06-Oct-1997 gp: Added SYNC_OpenEvent.
- *! 03-Jun-1997 gp: Added SYNC_{Begin|End}CritSection() functions.
- *! 03-Jan-1997 gp: Added SYNC_INFINITE define.
- *! 05-Aug-1996 gp: Created.
- */
-
-#ifndef _SYNC_H
-#define _SYNC_H
-
-/* Special timeout value indicating an infinite wait: */
-#define SYNC_INFINITE  0xffffffff
-
-/* Maximum string length of a named event */
-#define SYNC_MAXNAMELENGTH 32
-
-/* Generic SYNC object: */
-	struct SYNC_OBJECT;
-	/*typedef struct SYNC_OBJECT *SYNC_HOBJECT;*/
-
-/* Generic SYNC CS object: */
-	struct SYNC_CSOBJECT;
-	/*typedef struct SYNC_CSOBJECT *SYNC_HCSOBJECT;*/
-
-/* Used SYNC_CSOBJECT instead of SYNC_DPCCSOBJECT to avoid warnings */
-	/*typedef struct SYNC_CSOBJECT *SYNC_HDPCCSOBJECT;*/
-
-/* SYNC object attributes: */
-	struct SYNC_ATTRS {
-		HANDLE hUserEvent;    /* Platform's User Mode synch. object. */
-		HANDLE hKernelEvent;  /* Platform's Kernel Mode sync. object. */
-		u32 dwReserved1;	/* For future expansion.   */
-		u32 dwReserved2;	/* For future expansion.   */
-	} ;
-
-/*
- *  ======== SYNC_CloseEvent ========
- *  Purpose:
- *      Close this event handle, freeing resources allocated in SYNC_OpenEvent
- *      if necessary.
- *  Parameters:
- *      hEvent: Handle to a synchronization event, created/opened in
- *              SYNC_OpenEvent.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EFAIL:      Failed to close event handle.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- *      Any subsequent usage of hEvent would be invalid.
- */
-	extern DSP_STATUS SYNC_CloseEvent(IN struct SYNC_OBJECT *hEvent);
-
-/*
- *  ======== SYNC_DeleteCS ========
- *  Purpose:
- *      Delete a critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_DeleteCS(IN struct SYNC_CSOBJECT *hCSObj);
-
-/*
- *  ======== SYNC_EnterCS ========
- *  Purpose:
- *      Enter the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_EnterCS(IN struct SYNC_CSOBJECT *hCSObj);
-
-/*
- *  ======== SYNC_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void SYNC_Exit();
-
-/*
- *  ======== SYNC_Init ========
- *  Purpose:
- *      Initializes private state of SYNC module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      SYNC initialized.
- */
-	extern bool SYNC_Init();
-
-/*
- *  ======== SYNC_InitializeCS ========
- *  Purpose:
- *      Initialize the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Out of memory.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj);
-
-/*
- *  ======== SYNC_InitializeDPCCS ========
- *  Purpose:
- *      Initialize the critical section between process context and DPC.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Out of memory.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT
-					       **phCSObj);
-
-/*
- *  ======== SYNC_LeaveCS ========
- *  Purpose:
- *      Leave the critical section.
- *  Parameters:
- *      hCSObj: critical section handle.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_LeaveCS(IN struct SYNC_CSOBJECT *hCSObj);
-
-/*
- *  ======== SYNC_OpenEvent ========
- *  Purpose:
- *      Create/open and initialize an event object for thread synchronization,
- *      which is initially in the non-signalled state.
- *  Parameters:
- *      phEvent:    Pointer to location to receive the event object handle.
- *      pAttrs:     Pointer to SYNC_ATTRS object containing initial SYNC
- *                  SYNC_OBJECT attributes.  If this pointer is NULL, then
- *                  SYNC_OpenEvent will create and manage an OS specific
- *                  syncronization object.
- *          pAttrs->hUserEvent:  Platform's User Mode synchronization object.
- *
- *      The behaviour of the SYNC methods depend on the value of
- *      the hUserEvent attr:
- *
- *      1. (hUserEvent == NULL):
- *          A user mode event is created.
- *      2. (hUserEvent != NULL):
- *          A user mode event is supplied by the caller of SYNC_OpenEvent().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to create user mode event.
- *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EINVALIDARG SYNC_ATTRS values are invalid.
- *  Requires:
- *      - SYNC initialized.
- *      - phEvent != NULL.
- *  Ensures:
- *      If function succeeded, pEvent->hEvent must be a valid event handle.
- */
-	extern DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
-					 IN OPTIONAL struct SYNC_ATTRS
-					 *pAttrs);
-
-/*
- * ========= SYNC_PostMessage ========
- *  Purpose:
- *      To post a windows message
- *  Parameters:
- *      hWindow:    Handle to the window
- *      uMsg:       Message to be posted
- *  Returns:
- *      DSP_SOK:        Success
- *      DSP_EFAIL:      Post message failed
- *      DSP_EHANDLE:    Invalid Window handle
- *  Requires:
- *      SYNC initialized
- *  Ensures
- */
-	extern DSP_STATUS SYNC_PostMessage(IN HANDLE hWindow, IN u32 uMsg);
-
-/*
- *  ======== SYNC_ResetEvent ========
- *  Purpose:
- *      Reset a syncronization event object state to non-signalled.
- *  Parameters:
- *      hEvent:         Handle to a sync event.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EFAIL:      Failed to reset event.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_ResetEvent(IN struct SYNC_OBJECT *hEvent);
-
-/*
- *  ======== SYNC_SetEvent ========
- *  Purpose:
- *      Signal the event.  Will unblock one waiting thread.
- *  Parameters:
- *      hEvent:         Handle to an event object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to signal event.
- *      DSP_EHANDLE:    Invalid handle.
- *  Requires:
- *      SYNC initialized.
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_SetEvent(IN struct SYNC_OBJECT *hEvent);
-
-/*
- *  ======== SYNC_WaitOnEvent ========
- *  Purpose:
- *      Wait for an event to be signalled, up to the specified timeout.
- *  Parameters:
- *      hEvent:         Handle to an event object.
- *      dwTimeOut:      The time-out interval, in milliseconds.
- *                      The function returns if the interval elapses, even if
- *                      the object's state is nonsignaled.
- *                      If zero, the function tests the object's state and
- *                      returns immediately.
- *                      If SYNC_INFINITE, the function's time-out interval
- *                      never elapses.
- *  Returns:
- *      DSP_SOK:        The object was signalled.
- *      DSP_EHANDLE:    Invalid handle.
- *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
- *      SYNC_E_TIMEOUT: Timeout expired while waiting for event to be signalled.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_WaitOnEvent(IN struct SYNC_OBJECT *hEvent,
-					   IN u32 dwTimeOut);
-
-/*
- *  ======== SYNC_WaitOnMultipleEvents ========
- *  Purpose:
- *      Wait for any of an array of events to be signalled, up to the
- *      specified timeout.
- *      Note: dwTimeOut must be SYNC_INFINITE to signal infinite wait.
- *  Parameters:
- *      hSyncEvents:    Array of handles to event objects.
- *      uCount:         Number of event handles.
- *      dwTimeOut:      The time-out interval, in milliseconds.
- *                      The function returns if the interval elapses, even if
- *                      no event is signalled.
- *                      If zero, the function tests the object's state and
- *                      returns immediately.
- *                      If SYNC_INFINITE, the function's time-out interval
- *                      never elapses.
- *      puIndex:        Location to store index of event that was signalled.
- *  Returns:
- *      DSP_SOK:        The object was signalled.
- *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
- *      SYNC_E_TIMEOUT: Timeout expired before event was signalled.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *  Ensures:
- */
-	extern DSP_STATUS SYNC_WaitOnMultipleEvents(IN struct SYNC_OBJECT
-						    **hSyncEvents,
-						    IN u32 uCount,
-						    IN u32 dwTimeout,
-						    OUT u32 *puIndex);
-
-#endif				/* _SYNC_H */
--- a/arch/arm/plat-omap/include/bridge/utildefs.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/utildefs.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== utildefs.h ========
- *  Purpose:
- *      Global UTIL constants and types, shared between WCD and DSPSYS.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* entries from UTIL_HOSTCONFIG.
- *! 12-Aug-2000 ag  Added UTIL_SYSINFO typedef.
- *! 08-Oct-1999 rr  Adopted for WinCE where test fxns will be added in util.h
- *! 26-Dec-1996 cr  Created.
- */
-
-#ifndef UTILDEFS_
-#define UTILDEFS_
-
-/* constants taken from configmg.h */
-#define UTIL_MAXMEMREGS     9
-#define UTIL_MAXIOPORTS     20
-#define UTIL_MAXIRQS        7
-#define UTIL_MAXDMACHNLS    7
-
-/* misc. constants */
-#define UTIL_MAXARGVS       10
-
-/* Platform specific important info */
-	struct UTIL_SYSINFO {
-		/* Granularity of page protection; usually 1k or 4k */
-		u32 dwPageSize;
-		u32 dwAllocationGranularity; /* VM granularity, usually 64K */
-		u32 dwNumberOfProcessors;	/* Used as sanity check */
-	} ;
-
-#endif				/* UTILDEFS_ */
--- a/arch/arm/plat-omap/include/bridge/util.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/util.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== util.h ========
- *  Purpose:
- *      Provide general purpose utility functions.
- *
- *  Public Functions:
- *      UTIL_CDTestDll
- *      UTIL_CmdLineToArgs
- *      UTIL_Exit
- *      UTIL_GetSysInfo
- *      UTIL_Init
- *      UTIL_Wait
- *
- *  Private Functions:
- *      isspace
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 12-Aug-2000 ag: Added UTIL_GetSysInfo().
- *! 31-Jan-2000 rr: Comments modifed for UTIL_Wait fxn.
- *! 17-Jan-2000 rr: UTIL_Wait fxn added. Busy waits x number of micro seconds.
- *! 12-Nov-1999 kc: Modified UTIL_CmdLineToArgs for use by different tests.
- *! 02-Nov-1999 kc: Removed parameter from UTIL_CDTestDll.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 08-Oct-1999 kc: Renamed UTIL_TestDllExec to UTIL_CDTestDll; added
- *!                 UTIL_CmdLineToArgs(); added isspace private func.
- *! 26-Dec-1996 cr: Created from misc pieces of wcd95.c, ktest.c.
- *
- */
-
-#ifndef _UTIL_H
-#define _UTIL_H
-
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include <utildefs.h>
-
-/*
- *  ======== UTIL_CDTestDll ========
- *  Purpose:
- *      Provides test entry point in class driver context.
- *  Parameters:
- *      cArgc:  test module command line input count.
- *      ppArgv: test module command line args.
- *  Returns:
- *      0 if successful, a negative value otherwise.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern u32 UTIL_CDTestDll(IN s32 cArgc, IN char **ppArgv);
-
-/*
- *  ======== UTIL_CmdLineToArgs ========
- *  Purpose:
- *      This function re-creates C-style cmd line argc & argv from WinMain()
- *      cmd line args.
- *  Parameters:
- *      s8 *pszProgName   - The name of the program currently being executed.
- *      s8 *argv[]        - The argument vector.
- *      s8 *pCmdLine      - The pointer to the command line.
- *      bool fHasProgName   - Indicats whether a program name is supplied.
- *  Returns:
- *      Returns the number of arguments found.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern s32 UTIL_CmdLineToArgs(IN char *pszProgName,
-				      IN char *argv[UTIL_MAXARGVS],
-				      IN char *pCmdLine, IN bool fHasProgName);
-
-/*
- *  ======== UTIL_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern inline void UTIL_Exit(void)
-	{
-	}
-/*
- *  ======== UTIL_GetSysInfo ========
- *  Purpose:
- *      This function return platform specific system information.
- *
- *  Parameters:
- *      pSysInfo  - address to store the system information.
- *  Returns:
- *      DSP_SOK
- *      S_FAIL
- *  Requires:
- *      UTIL initialized.
- *      pSysInfo != NULL
- *  Ensures:
- */
-	extern DSP_STATUS UTIL_GetSysInfo(OUT struct UTIL_SYSINFO *pSysInfo);
-
-/*
- *  ======== UTIL_Init ========
- *  Purpose:
- *      Initializes private state of UTIL module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      UTIL initialized.
- */
-	extern inline bool UTIL_Init(void)
-	{
-		return true;
-	}
-
-/*
- *  ======== UTIL_Wait ========
- *  Purpose:
- *      This fucntion busy waits given a certain number of micro seconds
- *      independent of the processor speed. This is acheived by the
- *      OEM functions QueryPerformanceCounter and QueryPerformanceFrequency.
- *  Parameters:
- *      u32   Number of Micro seconds to busy wait
- *  Returns:
- *          Nothing
- *  Requires:
- *          UTIL_Initalized.
- *  Ensures:
- *      Busy waits x Micro seconds or Sleeps X milli seconds; in that
- *      case, it is a blocking call there will be a context switching
- *      hence it may not represent the absolute busy wait time.
- */
-	extern inline void UTIL_Wait(IN u32 dwMicroSeconds)
-	{
-		if (dwMicroSeconds / 1000 <= 1) {
-			/* <= 1 millisecond delay */
-			udelay(dwMicroSeconds);
-		} else if (dwMicroSeconds * HZ / 1000000 <= 1) {
-			/* <= 10 millisecond delay */
-			mdelay(dwMicroSeconds / 1000);
-		} else {
-			/* > 10 millisecond delay */
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(dwMicroSeconds * HZ / 1000000);
-		}
-	}
-
-#endif				/* _UTIL_H */
--- a/arch/arm/plat-omap/include/bridge/uuidutil.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/uuidutil.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== uuidutil.h ========
- *  Description:
- *      This file contains the specification of UUID helper functions.
- *
- *! Revision History
- *! ================
- *! 09-Nov-2000 kc: Modified description of UUID utility functions.
- *! 29-Sep-2000 kc: Appended "UUID_" prefix to UUID helper functions.
- *! 10-Aug-2000 kc: Created.
- *!
- */
-
-#ifndef UUIDUTIL_
-#define UUIDUTIL_
-
-#define MAXUUIDLEN  37
-
-/*
- *  ======== UUID_UuidToString ========
- *  Purpose:
- *      Converts a DSP_UUID to an ANSI string.
- *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID object.
- *      pszUuid:    Pointer to a buffer to receive a NULL-terminated UUID
- *                  string.
- *      size:	    Maximum size of the pszUuid string.
- *  Returns:
- *  Requires:
- *      pUuid & pszUuid are non-NULL values.
- *  Ensures:
- *      Lenghth of pszUuid is less than MAXUUIDLEN.
- *  Details:
- *      UUID string limit currently set at MAXUUIDLEN.
- */
-	void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
-			       s32 size);
-
-/*
- *  ======== UUID_UuidFromString ========
- *  Purpose:
- *      Converts an ANSI string to a DSP_UUID.
- *  Parameters:
- *      pszUuid:    Pointer to a string that represents a DSP_UUID object.
- *      pUuid:      Pointer to a DSP_UUID object.
- *  Returns:
- *  Requires:
- *      pUuid & pszUuid are non-NULL values.
- *  Ensures:
- *  Details:
- *      We assume the string representation of a UUID has the following format:
- *      "12345678_1234_1234_1234_123456789abc".
- */
-	extern void UUID_UuidFromString(IN char *pszUuid,
-					OUT struct DSP_UUID *pUuid);
-
-#endif				/* UUIDUTIL_ */
--- a/arch/arm/plat-omap/include/bridge/wcd.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wcd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wcd.h ========
- *  Description:
- *      'Bridge class driver library functions, object definitions, and
- *      return error/status codes.  To be included by 'Bridge mini drivers.
- *
- *  Public Functions:
- *      See mem.h and dbg.h.
- *
- *  Notes:
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.  WMD's must not call module Init/Exit
- *      functions.
- *
- *      To ensure WMD binary compatibility across different platforms,
- *      for the same processor, a WMD must restrict its usage of system
- *      services to those exported by the 'Bridge class library.
- *
- *! Revision History:
- *! ================
- *! 07-Jun-2000 jeh Added dev.h
- *! 01-Nov-1999 ag: #WINCE# WCD_MAJOR_VERSION=8 & WCD_MINOR_VERSION=0 to match
- *!		    dll stamps.
- *!                 0.80 - 0.89 Alpha, 0.90 - 0.99 Beta, 1.00 - 1.10 FCS.
- *! 17-Sep-1997 gp: Changed size of CFG_HOSTRES structure; and ISR_Install API;
- *!                 Changed WCD_MINOR_VERSION 3 -> 4.
- *! 15-Sep-1997 gp: Moved WCD_(Un)registerMinidriver to drv.
- *! 25-Jul-1997 cr: Added WCD_UnregisterMinidriver.
- *! 22-Jul-1997 cr: Added WCD_RegisterMinidriver, WCD_MINOR_VERSION 2 -> 3.
- *! 12-Nov-1996 gp: Defined port io macros.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 16-Jul-1996 gp: Added CHNL fxns; updated WCD lib version to 2.
- *! 10-May-1996 gp: Separated WMD def.s' into wmd.h.
- *! 03-May-1996 gp: Created.
- */
-
-#ifndef WCD_
-#define WCD_
-
-/* This WCD Library Version:  */
-#define WCD_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
-#define WCD_MINOR_VERSION   (u32)0
-
-#endif				/* WCD_ */
--- a/arch/arm/plat-omap/include/bridge/wcdioctl.h
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wcdioctl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wcdioctl.h ========
- *  Purpose:
- *      Contains structures and commands that are used for interaction
- *      between the DDSP API and class driver.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping structs & offsets
- *! 15-Oct-2002 kc  Updated definitions for private PERF module.
- *! 16-Aug-2002 map Added ARGS_MGR_REGISTEROBJECT & ARGS_MGR_UNREGISTEROBJECT
- *!		 Added CMD_MGR_REGISTEROBJECT_OFFSET &
- *!		 CMD_MGR_UNREGISTEROBJECT_OFFSET
- *! 15-Jan-2002 ag  Added actaul bufSize to ARGS_STRM_[RECLAIM][ISSUE].
- *! 15-Nov-2001 ag  change to STRMINFO in ARGS_STRM_GETINFO.
- *! 11-Sep-2001 ag  ARGS_CMM_GETHANDLE defn uses DSP_HPROCESSOR.
- *! 23-Apr-2001 jeh Added pStatus to NODE_TERMINATE args.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 22-Nov-2000 kc: Added CMD_MGR_GETPERF_DATA_OFFSET for acquiring PERF stats.
- *! 27-Oct-2000 jeh Added timeouts to NODE_GETMESSAGE, NODE_PUTMESSAGE args.
- *!		 Removed NODE_GETMESSAGESTRM args.
- *! 11-Oct-2000 ag: Added SM mgr(CMM) args.
- *! 27-Sep-2000 jeh Removed struct DSP_BUFFERATTR param from
- *!		    ARGS_STRM_ALLOCATEBUFFER.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 07-Sep-2000 jeh Changed HANDLE to DSP_HNOTIFICATION in RegisterNotify args.
- *!		 Added DSP_STRMATTR to DSPNode_Connect args.
- *! 04-Aug-2000 rr: MEM and UTIL added to RM.
- *! 27-Jul-2000 rr: NODE, MGR,STRM and PROC added
- *! 27-Jun-2000 rr: Modifed to Use either PM or DSP/BIOS Bridge
- *!		 IFDEF to build for PM or DSP/BIOS Bridge
- *! 28-Jan-2000 rr: NT_CMD_FROM_OFFSET moved out to dsptrap.h
- *! 24-Jan-2000 rr: Merged with Scott's code.
- *! 21-Jan-2000 sg: In ARGS_CHNL_GETMODE changed mode to be u32 to be
- *!		 consistent with chnldefs.h.
- *! 11-Jan-2000 rr: CMD_CFG_GETCDVERSION_OFFSET added.
- *! 12-Nov-1999 rr: CMD_BRD_MONITOR_OFFSET added
- *! 09-Nov-1999 kc: Added MEMRY and enabled CMD_BRD_IOCTL_OFFSET.
- *! 05-Nov-1999 ag: Added CHNL.
- *! 02-Nov-1999 kc: Removed field from ARGS_UTIL_TESTDLL.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 08-Oct-1999 rr: Util control offsets added.
- *! 13-Sep-1999 kc: Added ARGS_UTIL_TESTDLL for PM test infrastructure.
- *! 19-Aug-1999 rr: Created from WSX. Minimal Implementaion of BRD_Start and BRD
- *!		 and BRD_Stop. IOCTL Offsets and CTRL Code.
- */
-
-#ifndef WCDIOCTL_
-#define WCDIOCTL_
-
-#include <mem.h>
-#include <cmm.h>
-#include <strmdefs.h>
-#include <dbdcd.h>
-
-union Trapped_Args {
-
-	/* MGR Module */
-	struct {
-		u32 uNode;
-		struct DSP_NDBPROPS __user *pNDBProps;
-		u32 uNDBPropsSize;
-		u32 __user *puNumNodes;
-	} ARGS_MGR_ENUMNODE_INFO;
-
-	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORINFO __user *pProcessorInfo;
-		u32 uProcessorInfoSize;
-		u32 __user *puNumProcs;
-	} ARGS_MGR_ENUMPROC_INFO;
-
-	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-		char *pszPathName;
-	} ARGS_MGR_REGISTEROBJECT;
-
-	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-	} ARGS_MGR_UNREGISTEROBJECT;
-
-	struct {
-		struct DSP_NOTIFICATION  __user*__user *aNotifications;
-		u32 uCount;
-		u32 __user *puIndex;
-		u32 uTimeout;
-	} ARGS_MGR_WAIT;
-
-	/* PROC Module */
-	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORATTRIN __user *pAttrIn;
-		DSP_HPROCESSOR __user *phProcessor;
-	} ARGS_PROC_ATTACH;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 dwCmd;
-		struct DSP_CBDATA __user *pArgs;
-	} ARGS_PROC_CTRL;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_DETACH;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		DSP_HNODE __user *aNodeTab;
-		u32 uNodeTabSize;
-		u32 __user *puNumNodes;
-		u32 __user *puAllocated;
-	} ARGS_PROC_ENUMNODE_INFO;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 uResourceType;
-		struct DSP_RESOURCEINFO *pResourceInfo;
-		u32 uResourceInfoSize;
-	} ARGS_PROC_ENUMRESOURCES;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_PROCESSORSTATE __user *pProcStatus;
-		u32 uStateInfoSize;
-	} ARGS_PROC_GETSTATE;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u8 __user *pBuf;
-
-	#ifndef RES_CLEANUP_DISABLE
-	    u8 __user *pSize;
-    #endif
-		u32 uMaxSize;
-	} ARGS_PROC_GETTRACE;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		s32 iArgc;
-		char __user*__user *aArgv;
-		char *__user *aEnvp;
-	} ARGS_PROC_LOAD;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_PROC_REGISTER_NOTIFY;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_START;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *__user *ppRsvAddr;
-	} ARGS_PROC_RSVMEM;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *pRsvAddr;
-	} ARGS_PROC_UNRSVMEM;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		void *pReqAddr;
-		void *__user *ppMapAddr;
-		u32 ulMapAttr;
-	} ARGS_PROC_MAPMEM;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *pMapAddr;
-	} ARGS_PROC_UNMAPMEM;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		u32 ulFlags;
-	} ARGS_PROC_FLUSHMEMORY;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_STOP;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-	} ARGS_PROC_INVALIDATEMEMORY;
-
-
-	/* NODE Module */
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_CBDATA __user *pArgs;
-		struct DSP_NODEATTRIN __user *pAttrIn;
-		DSP_HNODE __user *phNode;
-	} ARGS_NODE_ALLOCATE;
-
-	struct {
-		DSP_HNODE hNode;
-		u32 uSize;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *__user *pBuffer;
-	} ARGS_NODE_ALLOCMSGBUF;
-
-	struct {
-		DSP_HNODE hNode;
-		s32 iPriority;
-	} ARGS_NODE_CHANGEPRIORITY;
-
-	struct {
-		DSP_HNODE hNode;
-		u32 uStream;
-		DSP_HNODE hOtherNode;
-		u32 uOtherStream;
-		struct DSP_STRMATTR __user *pAttrs;
-		struct DSP_CBDATA __user *pConnParam;
-	} ARGS_NODE_CONNECT;
-
-	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_CREATE;
-
-	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_DELETE;
-
-	struct {
-		DSP_HNODE hNode;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *pBuffer;
-	} ARGS_NODE_FREEMSGBUF;
-
-	struct {
-		DSP_HNODE hNode;
-		struct DSP_NODEATTR __user *pAttr;
-		u32 uAttrSize;
-	} ARGS_NODE_GETATTR;
-
-	struct {
-		DSP_HNODE hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_GETMESSAGE;
-
-	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_PAUSE;
-
-	struct {
-		DSP_HNODE hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_PUTMESSAGE;
-
-	struct {
-		DSP_HNODE hNode;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_NODE_REGISTERNOTIFY;
-
-	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_RUN;
-
-	struct {
-		DSP_HNODE hNode;
-		DSP_STATUS __user *pStatus;
-	} ARGS_NODE_TERMINATE;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_NDBPROPS __user *pNodeProps;
-	} ARGS_NODE_GETUUIDPROPS;
-
-	/* STRM module */
-
-	struct {
-		DSP_HSTREAM hStream;
-		u32 uSize;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_ALLOCATEBUFFER;
-
-	struct {
-		DSP_HSTREAM hStream;
-	} ARGS_STRM_CLOSE;
-
-	struct {
-		DSP_HSTREAM hStream;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_FREEBUFFER;
-
-	struct {
-		DSP_HSTREAM hStream;
-		HANDLE *phEvent;
-	} ARGS_STRM_GETEVENTHANDLE;
-
-	struct {
-		DSP_HSTREAM hStream;
-		struct STRM_INFO __user *pStreamInfo;
-		u32 uStreamInfoSize;
-	} ARGS_STRM_GETINFO;
-
-	struct {
-		DSP_HSTREAM hStream;
-		bool bFlush;
-	} ARGS_STRM_IDLE;
-
-	struct {
-		DSP_HSTREAM hStream;
-		u8 *pBuffer;
-		u32 dwBytes;
-		u32 dwBufSize;
-		u32 dwArg;
-	} ARGS_STRM_ISSUE;
-
-	struct {
-		DSP_HNODE hNode;
-		u32 uDirection;
-		u32 uIndex;
-		struct STRM_ATTR __user *pAttrIn;
-		DSP_HSTREAM __user *phStream;
-	} ARGS_STRM_OPEN;
-
-	struct {
-		DSP_HSTREAM hStream;
-		u8 *__user *pBufPtr;
-		u32 __user *pBytes;
-		u32 __user *pBufSize;
-		u32 __user *pdwArg;
-	} ARGS_STRM_RECLAIM;
-
-	struct {
-		DSP_HSTREAM hStream;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_STRM_REGISTERNOTIFY;
-
-	struct {
-		DSP_HSTREAM __user *aStreamTab;
-		u32 nStreams;
-		u32 __user *pMask;
-		u32 uTimeout;
-	} ARGS_STRM_SELECT;
-
-	/* CMM Module */
-	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		u32 uSize;
-		struct CMM_ATTRS *pAttrs;
-		OUT void **ppBufVA;
-	} ARGS_CMM_ALLOCBUF;
-
-	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		void *pBufPA;
-		u32 ulSegId;
-	} ARGS_CMM_FREEBUF;
-
-	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct CMM_OBJECT *__user *phCmmMgr;
-	} ARGS_CMM_GETHANDLE;
-
-	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		struct CMM_INFO __user *pCmmInfo;
-	} ARGS_CMM_GETINFO;
-
-	/* MEM Module */
-	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_ALLOC;
-
-	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_CALLOC;
-
-	struct {
-		void *pMem;
-	} ARGS_MEM_FREE;
-
-	struct {
-		void *pBuffer;
-		u32 cSize;
-		void *pLockedBuffer;
-	} ARGS_MEM_PAGELOCK;
-
-	struct {
-		void *pBuffer;
-		u32 cSize;
-	} ARGS_MEM_PAGEUNLOCK;
-
-	/* UTIL module */
-	struct {
-		s32 cArgc;
-		char **ppArgv;
-	} ARGS_UTIL_TESTDLL;
-} ;
-
-#define CMD_BASE		    1
-
-/* MGR module offsets */
-#define CMD_MGR_BASE_OFFSET	     CMD_BASE
-#define CMD_MGR_ENUMNODE_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 0)
-#define CMD_MGR_ENUMPROC_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 1)
-#define CMD_MGR_REGISTEROBJECT_OFFSET   (CMD_MGR_BASE_OFFSET + 2)
-#define CMD_MGR_UNREGISTEROBJECT_OFFSET (CMD_MGR_BASE_OFFSET + 3)
-#define CMD_MGR_WAIT_OFFSET	     (CMD_MGR_BASE_OFFSET + 4)
-
-#ifndef RES_CLEANUP_DISABLE
-#define CMD_MGR_RESOUCES_OFFSET	 (CMD_MGR_BASE_OFFSET + 5)
-#define CMD_MGR_END_OFFSET	      CMD_MGR_RESOUCES_OFFSET
-#else
-#define CMD_MGR_END_OFFSET	      CMD_MGR_WAIT_OFFSET
-#endif
-
-#define CMD_PROC_BASE_OFFSET	    (CMD_MGR_END_OFFSET + 1)
-#define CMD_PROC_ATTACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 0)
-#define CMD_PROC_CTRL_OFFSET	    (CMD_PROC_BASE_OFFSET + 1)
-#define CMD_PROC_DETACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 2)
-#define CMD_PROC_ENUMNODE_OFFSET	(CMD_PROC_BASE_OFFSET + 3)
-#define CMD_PROC_ENUMRESOURCES_OFFSET   (CMD_PROC_BASE_OFFSET + 4)
-#define CMD_PROC_GETSTATE_OFFSET	(CMD_PROC_BASE_OFFSET + 5)
-#define CMD_PROC_GETTRACE_OFFSET	(CMD_PROC_BASE_OFFSET + 6)
-#define CMD_PROC_LOAD_OFFSET	    (CMD_PROC_BASE_OFFSET + 7)
-#define CMD_PROC_REGISTERNOTIFY_OFFSET  (CMD_PROC_BASE_OFFSET + 8)
-#define CMD_PROC_START_OFFSET	   (CMD_PROC_BASE_OFFSET + 9)
-#define CMD_PROC_RSVMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 10)
-#define CMD_PROC_UNRSVMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 11)
-#define CMD_PROC_MAPMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 12)
-#define CMD_PROC_UNMAPMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 13)
-#define CMD_PROC_FLUSHMEMORY_OFFSET      (CMD_PROC_BASE_OFFSET + 14)
-#define CMD_PROC_STOP_OFFSET	    (CMD_PROC_BASE_OFFSET + 15)
-#define CMD_PROC_INVALIDATEMEMORY_OFFSET (CMD_PROC_BASE_OFFSET + 16)
-#define CMD_PROC_END_OFFSET	     CMD_PROC_INVALIDATEMEMORY_OFFSET
-
-
-#define CMD_NODE_BASE_OFFSET	    (CMD_PROC_END_OFFSET + 1)
-#define CMD_NODE_ALLOCATE_OFFSET	(CMD_NODE_BASE_OFFSET + 0)
-#define CMD_NODE_ALLOCMSGBUF_OFFSET     (CMD_NODE_BASE_OFFSET + 1)
-#define CMD_NODE_CHANGEPRIORITY_OFFSET  (CMD_NODE_BASE_OFFSET + 2)
-#define CMD_NODE_CONNECT_OFFSET	 (CMD_NODE_BASE_OFFSET + 3)
-#define CMD_NODE_CREATE_OFFSET	  (CMD_NODE_BASE_OFFSET + 4)
-#define CMD_NODE_DELETE_OFFSET	  (CMD_NODE_BASE_OFFSET + 5)
-#define CMD_NODE_FREEMSGBUF_OFFSET      (CMD_NODE_BASE_OFFSET + 6)
-#define CMD_NODE_GETATTR_OFFSET	 (CMD_NODE_BASE_OFFSET + 7)
-#define CMD_NODE_GETMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 8)
-#define CMD_NODE_PAUSE_OFFSET	   (CMD_NODE_BASE_OFFSET + 9)
-#define CMD_NODE_PUTMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 10)
-#define CMD_NODE_REGISTERNOTIFY_OFFSET  (CMD_NODE_BASE_OFFSET + 11)
-#define CMD_NODE_RUN_OFFSET	     (CMD_NODE_BASE_OFFSET + 12)
-#define CMD_NODE_TERMINATE_OFFSET       (CMD_NODE_BASE_OFFSET + 13)
-#define CMD_NODE_GETUUIDPROPS_OFFSET    (CMD_NODE_BASE_OFFSET + 14)
-#define CMD_NODE_END_OFFSET	     CMD_NODE_GETUUIDPROPS_OFFSET
-
-#define CMD_STRM_BASE_OFFSET	    (CMD_NODE_END_OFFSET + 1)
-#define CMD_STRM_ALLOCATEBUFFER_OFFSET  (CMD_STRM_BASE_OFFSET + 0)
-#define CMD_STRM_CLOSE_OFFSET	   (CMD_STRM_BASE_OFFSET + 1)
-#define CMD_STRM_FREEBUFFER_OFFSET      (CMD_STRM_BASE_OFFSET + 2)
-#define CMD_STRM_GETEVENTHANDLE_OFFSET  (CMD_STRM_BASE_OFFSET + 3)
-#define CMD_STRM_GETINFO_OFFSET	 (CMD_STRM_BASE_OFFSET + 4)
-#define CMD_STRM_IDLE_OFFSET	    (CMD_STRM_BASE_OFFSET + 5)
-#define CMD_STRM_ISSUE_OFFSET	   (CMD_STRM_BASE_OFFSET + 6)
-#define CMD_STRM_OPEN_OFFSET	    (CMD_STRM_BASE_OFFSET + 7)
-#define CMD_STRM_RECLAIM_OFFSET	 (CMD_STRM_BASE_OFFSET + 8)
-#define CMD_STRM_REGISTERNOTIFY_OFFSET  (CMD_STRM_BASE_OFFSET + 9)
-#define CMD_STRM_SELECT_OFFSET	  (CMD_STRM_BASE_OFFSET + 10)
-#define CMD_STRM_END_OFFSET	     CMD_STRM_SELECT_OFFSET
-
-/* Communication Memory Manager (UCMM) */
-#define CMD_CMM_BASE_OFFSET	     (CMD_STRM_END_OFFSET + 1)
-#define CMD_CMM_ALLOCBUF_OFFSET	 (CMD_CMM_BASE_OFFSET + 0)
-#define CMD_CMM_FREEBUF_OFFSET	  (CMD_CMM_BASE_OFFSET + 1)
-#define CMD_CMM_GETHANDLE_OFFSET	(CMD_CMM_BASE_OFFSET + 2)
-#define CMD_CMM_GETINFO_OFFSET	  (CMD_CMM_BASE_OFFSET + 3)
-#define CMD_CMM_END_OFFSET	      CMD_CMM_GETINFO_OFFSET
-
-#define CMD_BASE_END_OFFSET	CMD_CMM_END_OFFSET
-#endif				/* WCDIOCTL_ */
--- a/arch/arm/plat-omap/include/bridge/wmdchnl.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmdchnl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmdchnl.h ========
- *  Description:
- *      Declares the upper edge channel class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are implemented
- *      by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      The function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
- *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream
- *!                 support.
- *! 11-Jul-1996 gp: Created.
- */
-
-#ifndef WMDCHNL_
-#define WMDCHNL_
-
-	extern DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-					  struct DEV_OBJECT *hDevObject,
-					  IN CONST struct CHNL_MGRATTRS
-					  *pMgrAttrs);
-
-	extern DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
-
-	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-					struct CHNL_MGR *hChnlMgr,
-					CHNL_MODE uMode,
-					u32 uChnlId,
-					CONST IN OPTIONAL struct CHNL_ATTRS
-					*pAttrs);
-
-	extern DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl);
-
-	extern DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
-					    void *pHostBuf,
-					    u32 cBytes, u32 cBufSize,
-					    OPTIONAL u32 dwDspAddr,
-					    u32 dwArg);
-
-	extern DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl,
-					  u32 dwTimeOut,
-					  OUT struct CHNL_IOC *pIOC);
-
-	extern DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
-
-	extern DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
-					   u32 dwTimeOut);
-
-	extern DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
-					   OUT struct CHNL_INFO *pInfo);
-
-	extern DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr,
-					      u32 uChnlID,
-					      OUT struct CHNL_MGRINFO
-					      *pMgrInfo);
-
-	extern DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl,
-					u32 dwTimeOut, bool fFlush);
-
-	extern DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl,
-						  u32 uEventMask,
-						  u32 uNotifyType,
-						  struct DSP_NOTIFICATION
-						  *hNotification);
-
-#endif				/* WMDCHNL_ */
--- a/arch/arm/plat-omap/include/bridge/wmddeh.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmddeh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmddeh.h ========
- *  Description:
- *      Defines upper edge DEH functions required by all WMD/WCD driver
- *      interface tables.
- *
- *  Public Functions:
- *      WMD_DEH_Create
- *      IVA_DEH_Create
- *      WMD_DEH_Destroy
- *      WMD_DEH_GetInfo
- *      WMD_DEH_RegisterNotify
- *      WMD_DEH_Notify
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: added IVA_DEH_Create.
- *! 13-Sep-2001 kc: created.
- */
-
-#ifndef WMDDEH_
-#define WMDDEH_
-
-#include <devdefs.h>
-
-#include <dehdefs.h>
-
-	extern DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
-					 struct DEV_OBJECT *hDevObject);
-
-	extern DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr);
-
-	extern DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
-					  struct DSP_ERRORINFO *pErrInfo);
-
-	extern DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
-
-	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
-				   u32 ulEventMask, u32 dwErrInfo);
-#endif				/* WMDDEH_ */
--- a/arch/arm/plat-omap/include/bridge/wmd.h
+++ /dev/null
@@ -1,1193 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmd.h ========
- *  Purpose:
- *      'Bridge mini driver entry point and interface function declarations.
- *
- *  Public Functions:
- *      WMD_DRV_Entry
- *
- *  Notes:
- *      The 'Bridge class driver obtains it's function interface to
- *      the 'Bridge mini driver via a call to WMD_DRV_Entry().
- *
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.
- *
- *      WMD function DBC Requires and Ensures are also made by the WCD on
- *      behalf of the WMD, to simplify the WMD code.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs - WMD_BRD_MemMap/UnMap
- *! 01-Mar-2004 vp  Added filename argument to WMD_DRV_Entry function.
- *! 29-Aug-2002 map Added WMD_BRD_MemWrite()
- *! 26-Aug-2002 map Added WMD_BRD_MemCopy()
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 05-Nov-2001 kc: Added error handling DEH functions.
- *! 06-Dec-2000 jeh Added uEventMask to WMD_MSG_RegisterNotify().
- *! 17-Nov-2000 jeh Added WMD_MSG and WMD_IO definitions.
- *! 01-Nov-2000 jeh Added more error codes to WMD_CHNL_RegisterNotify().
- *! 13-Oct-2000 jeh Added dwArg to WMD_CHNL_AddIOReq(), added WMD_CHNL_IDLE
- *!                 and WMD_CHNL_RegisterNotify for DSPStream support.
- *! 17-Jan-2000 rr: WMD_BRD_SETSTATE Added.
- *! 30-Jul-1997 gp: Split wmd IOCTL space into reserved and private.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 18-Oct-1996 gp: Added WMD_E_HARDWARE return code from WMD_BRD_Monitor.
- *! 09-Sep-1996 gp: Subtly altered the semantics of WMD_CHNL_GetInfo().
- *! 02-Aug-1996 gp: Ensured on BRD_Start that interrupts to the PC are enabled.
- *! 11-Jul-1996 gp: Added CHNL interface. Note stronger DBC_Require conditions.
- *! 29-May-1996 gp: Removed WCD_ prefix from functions imported from WCD.LIB.
- *! 29-May-1996 gp: Made OUT param first in WMD_DEV_Create().
- *! 09-May-1996 gp: Created.
- */
-
-#ifndef WMD_
-#define WMD_
-
-#include <brddefs.h>
-#include <cfgdefs.h>
-#include <chnlpriv.h>
-#include <dehdefs.h>
-#include <devdefs.h>
-#include <iodefs.h>
-#include <msgdefs.h>
-
-/*
- *  Any IOCTLS at or above this value are reserved for standard WMD
- *  interfaces.
- */
-#define WMD_RESERVEDIOCTLBASE   0x8000
-
-/* Handle to mini-driver's private device context.  */
-	struct WMD_DEV_CONTEXT;
-
-/*---------------------------------------------------------------------------*/
-/* 'Bridge MINI DRIVER FUNCTION TYPES                                        */
-/*---------------------------------------------------------------------------*/
-
-/*
- *  ======== WMD_BRD_Monitor ========
- *  Purpose:
- *      Bring the board to the BRD_IDLE (monitor) state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_IDLE state;
- *      else:           Board state is indeterminate.
- */
-       typedef DSP_STATUS(
-			   *WMD_BRD_MONITOR) (struct WMD_DEV_CONTEXT
-			   *hDevContext);
-
-/*
- *  ======== WMD_BRD_SETSTATE ========
- *  Purpose:
- *      Sets the Mini driver state
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ulBrdState:     Board state
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      ulBrdState  <= BRD_LASTSTATE.
- *  Ensures:
- *      ulBrdState  <= BRD_LASTSTATE.
- *  Update the Board state to the specified state.
- */
-       typedef DSP_STATUS(
-			   *WMD_BRD_SETSTATE) (struct WMD_DEV_CONTEXT
-			   *hDevContext, u32 ulBrdState);
-
-/*
- *  ======== WMD_BRD_Start ========
- *  Purpose:
- *      Bring board to the BRD_RUNNING (start) state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *      dwDSPAddr:      DSP address at which to start execution.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *      Board is in monitor (BRD_IDLE) state.
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_RUNNING state.
- *                      Interrupts to the PC are enabled.
- *      else:           Board state is indeterminate.
- */
-       typedef DSP_STATUS(*WMD_BRD_START) (struct WMD_DEV_CONTEXT
-						*hDevContext, u32 dwDSPAddr);
-
-/*
- *  ======== WMD_BRD_MemCopy ========
- *  Purpose:
- *  Copy memory from one DSP address to another
- *  Parameters:
- *      pDevContext:    Pointer to context handle
- *  ulDspDestAddr:  DSP address to copy to
- *  ulDspSrcAddr:   DSP address to copy from
- *  ulNumBytes: Number of bytes to copy
- *  ulMemType:  What section of memory to copy to
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      pDevContext != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_RUNNING state.
- *                      Interrupts to the PC are enabled.
- *      else:           Board state is indeterminate.
- */
-       typedef DSP_STATUS(*WMD_BRD_MEMCOPY) (struct WMD_DEV_CONTEXT
-					     *hDevContext,
-					     u32 ulDspDestAddr,
-					     u32 ulDspSrcAddr,
-					     u32 ulNumBytes, u32 ulMemType);
-/*
- *  ======== WMD_BRD_MemWrite ========
- *  Purpose:
- *      Write a block of host memory into a DSP address, into a given memory
- *      space.  Unlike WMD_BRD_Write, this API does reset the DSP
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP to which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_BRD_MEMWRITE) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					IN u8 *pHostBuf,
-					u32 dwDSPAddr, u32 ulNumBytes,
-					u32 ulMemType);
-
-/*
- *  ======== WMD_BRD_MemMap ========
- *  Purpose:
- *      Map a MPU memory region to a DSP/IVA memory space
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ulMpuAddr:      MPU memory region start address.
- *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to map.
- *      mapAttrs:       Mapping attributes (e.g. endianness).
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_BRD_MEMMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext, u32 ulMpuAddr,
-					u32 ulVirtAddr, u32 ulNumBytes,
-					u32 ulMapAttrs);
-
-/*
- *  ======== WMD_BRD_MemUnMap ========
- *  Purpose:
- *      UnMap an MPU memory region from DSP/IVA memory space
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to unmap.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_BRD_MEMUNMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					u32 ulVirtAddr,
-					u32 ulNumBytes);
-
-/*
- *  ======== WMD_BRD_Stop ========
- *  Purpose:
- *      Bring board to the BRD_STOPPED state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_STOPPED (stop) state;
- *                      Interrupts to the PC are disabled.
- *      else:           Board state is indeterminate.
- */
-       typedef DSP_STATUS(*WMD_BRD_STOP) (struct WMD_DEV_CONTEXT
-					*hDevContext);
-
-/*
- *  ======== WMD_BRD_Status ========
- *  Purpose:
- *      Report the current state of the board.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *      pdwState:       Ptr to BRD status variable.
- *  Returns:
- *      DSP_SOK:
- *  Requires:
- *      pdwState != NULL;
- *      hDevContext != NULL
- *  Ensures:
- *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
- */
-       typedef DSP_STATUS(*
-			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
-					    OUT BRD_STATUS * pdwState);
-
-/*
- *  ======== WMD_BRD_Read ========
- *  Purpose:
- *      Read a block of DSP memory, from a given memory space, into a host
- *      buffer.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Destination).
- *      dwDSPAddr:      Address on DSP board (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP from which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- *  Will not write more than ulNumBytes bytes into pHostBuf.
- */
-typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
-						  OUT u8 *pHostBuf,
-						  u32 dwDSPAddr,
-						  u32 ulNumBytes,
-						  u32 ulMemType);
-
-/*
- *  ======== WMD_BRD_Write ========
- *  Purpose:
- *      Write a block of host memory into a DSP address, into a given memory
- *      space.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP to which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- */
-typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
-						   IN u8 *pHostBuf,
-						   u32 dwDSPAddr,
-						   u32 ulNumBytes,
-						   u32 ulMemType);
-
-/*
- *  ======== WMD_CHNL_Create ========
- *  Purpose:
- *      Create a channel manager object, responsible for opening new channels
- *      and closing old ones for a given 'Bridge board.
- *  Parameters:
- *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
- *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels: Max channels
- *      pMgrAttrs->bIRQ:      Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:   TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize: DSP Word size in equivalent PC bytes..
- *      pMgrAttrs->dwSMBase:  Base physical address of shared memory, if any.
- *      pMgrAttrs->uSMLength: Bytes of shared memory block.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EMEMORY:        Insufficient memory for requested resources.
- *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
- *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
- *  Requires:
- *      phChnlMgr != NULL.
- *      pMgrAttrs != NULL
- *      pMgrAttrs field are all valid:
- *          0 < cChannels <= CHNL_MAXCHANNELS.
- *          bIRQ <= 15.
- *          uWordSize > 0.
- *      IsValidHandle(hDevObject)
- *      No channel manager exists for this board.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_CHNL_CREATE)(OUT struct CHNL_MGR
-						    **phChnlMgr,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct
-						    CHNL_MGRATTRS *pMgrAttrs);
-
-/*
- *  ======== WMD_CHNL_Destroy ========
- *  Purpose:
- *      Close all open channels, and destroy the channel manager.
- *  Parameters:
- *      hChnlMgr:       Channel manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hChnlMgr was invalid.
- *  Requires:
- *  Ensures:
- *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
- *          CHNL_Create may subsequently be called for the same device.
- */
-       typedef DSP_STATUS(*WMD_CHNL_DESTROY) (struct CHNL_MGR
-						      *hChnlMgr);
-/*
- *  ======== WMD_DEH_Notify ========
- *  Purpose:
- *      When notified of DSP error, take appropriate action.
- *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
- *      ulEventMask:  Indicate the type of exception
- *      dwErrInfo:     Error information
- *  Returns:
- *
- *  Requires:
- *      hDehMgr != NULL;
- *     ulEventMask with a valid exception
- *  Ensures:
- */
-       typedef void (*WMD_DEH_NOTIFY)(struct DEH_MGR *hDehMgr,
-					u32 ulEventMask, u32 dwErrInfo);
-
-
-/*
- *  ======== WMD_CHNL_Open ========
- *  Purpose:
- *      Open a new half-duplex channel to the DSP board.
- *  Parameters:
- *      phChnl:         Location to store a channel object handle.
- *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
- *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
- *                      direction of data transfer.
- *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
- *                      select a free channel id (default);
- *                      otherwise this field specifies the id of the channel.
- *      pAttrs:         Channel attributes.  Attribute fields are as follows:
- *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
- *                      be pending at any given time. All request packets are
- *                      preallocated when the channel is opened.
- *      pAttrs->hEvent: This field allows the user to supply an auto reset
- *                      event object for channel I/O completion notifications.
- *                      It is the responsibility of the user to destroy this
- *                      object AFTER closing the channel.
- *                      This channel event object can be retrieved using
- *                      CHNL_GetEventHandle().
- *      pAttrs->hReserved: The kernel mode handle of this event object.
- *
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            hChnlMgr is invalid.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      DSP_EINVALIDARG:        Invalid number of IOReqs.
- *      CHNL_E_OUTOFSTREAMS:    No free channels available.
- *      CHNL_E_BADCHANID:       Channel ID is out of range.
- *      CHNL_E_CHANBUSY:        Channel is in use.
- *      CHNL_E_NOIORPS:         No free IO request packets available for
- *                              queuing.
- *  Requires:
- *      phChnl != NULL.
- *      pAttrs != NULL.
- *      pAttrs->hEvent is a valid event handle.
- *      pAttrs->hReserved is the kernel mode handle for pAttrs->hEvent.
- *  Ensures:
- *      DSP_SOK:                *phChnl is a valid channel.
- *      else:                   *phChnl is set to NULL if (phChnl != NULL);
- */
-       typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
-						   **phChnl,
-						   struct CHNL_MGR *hChnlMgr,
-						   CHNL_MODE uMode,
-						   u32 uChnlId,
-						   CONST IN OPTIONAL struct
-						   CHNL_ATTRS *pAttrs);
-
-/*
- *  ======== WMD_CHNL_Close ========
- *  Purpose:
- *      Ensures all pending I/O on this channel is cancelled, discards all
- *      queued I/O completion notifications, then frees the resources allocated
- *      for this channel, and makes the corresponding logical channel id
- *      available for subsequent use.
- *  Parameters:
- *      hChnl:          Handle to a channel object.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *  Requires:
- *      No thread must be blocked on this channel's I/O completion event.
- *  Ensures:
- *      DSP_SOK:        hChnl is no longer valid.
- */
-       typedef DSP_STATUS(*WMD_CHNL_CLOSE) (struct CHNL_OBJECT *hChnl);
-
-/*
- *  ======== WMD_CHNL_AddIOReq ========
- *  Purpose:
- *      Enqueue an I/O request for data transfer on a channel to the DSP.
- *      The direction (mode) is specified in the channel object. Note the DSP
- *      address is specified for channels opened in direct I/O mode.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      pHostBuf:       Host buffer address source.
- *      cBytes:         Number of PC bytes to transfer. A zero value indicates
- *                      that this buffer is the last in the output channel.
- *                      A zero value is invalid for an input channel.
- *!     cBufSize:       Actual buffer size in host bytes.
- *      dwDspAddr:      DSP address for transfer.  (Currently ignored).
- *      dwArg:          A user argument that travels with the buffer.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pHostBuf is invalid.
- *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
- *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
- *                      I/O is allowed.
- *      CHNL_E_EOS:     End of stream was already marked on a previous
- *                      IORequest on this channel.  No further I/O is expected.
- *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
- *                      the size of the physical shared memory output window.
- *  Requires:
- *  Ensures:
- *      DSP_SOK: The buffer will be transferred if the channel is ready;
- *          otherwise, will be queued for transfer when the channel becomes
- *          ready.  In any case, notifications of I/O completion are
- *          asynchronous.
- *          If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's
- *          on this channel will fail with error code CHNL_E_EOS.  The
- *          corresponding IOC for this I/O request will have its status flag
- *          set to CHNL_IOCSTATEOS.
- */
-       typedef DSP_STATUS(*WMD_CHNL_ADDIOREQ) (struct CHNL_OBJECT
-						       *hChnl,
-						       void *pHostBuf,
-						       u32 cBytes,
-						       u32 cBufSize,
-						       OPTIONAL u32 dwDspAddr,
-						       u32 dwArg);
-
-/*
- *  ======== WMD_CHNL_GetIOC ========
- *  Purpose:
- *      Dequeue an I/O completion record, which contains information about the
- *      completed I/O request.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
- *                      first available IOC.
- *      pIOC:           On output, contains host buffer address, bytes
- *                      transferred, and status of I/O completion.
- *      pIOC->status:   See chnldefs.h.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pIOC is invalid.
- *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
- *                      yet no I/O completions were queued.
- *  Requires:
- *      dwTimeOut == CHNL_IOCNOWAIT.
- *  Ensures:
- *      DSP_SOK: if there are any remaining IOC's queued before this call
- *          returns, the channel event object will be left in a signalled
- *          state.
- */
-       typedef DSP_STATUS(*WMD_CHNL_GETIOC) (struct CHNL_OBJECT *hChnl,
-						     u32 dwTimeOut,
-						     OUT struct CHNL_IOC *pIOC);
-
-/*
- *  ======== WMD_CHNL_CancelIO ========
- *  Purpose:
- *      Return all I/O requests to the client which have not yet been
- *      transferred.  The channel's I/O completion object is
- *      signalled, and all the I/O requests are queued as IOC's, with the
- *      status field set to CHNL_IOCSTATCANCEL.
- *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
- *  Parameters:
- *      hChnl:          Channel object handle.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *  Requires:
- *  Ensures:
- *      Subsequent I/O requests to this channel will not be accepted.
- */
-       typedef DSP_STATUS(*WMD_CHNL_CANCELIO) (struct CHNL_OBJECT
-						       *hChnl);
-
-/*
- *  ======== WMD_CHNL_FlushIO ========
- *  Purpose:
- *      For an output stream (to the DSP), indicates if any IO requests are in
- *      the output request queue.  For input streams (from the DSP), will
- *      cancel all pending IO requests.
- *  Parameters:
- *      hChnl:              Channel object handle.
- *      dwTimeOut:          Timeout value for flush operation.
- *  Returns:
- *      DSP_SOK:            Success;
- *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
- *      DSP_EHANDLE:        Invalid hChnl.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:            No I/O requests will be pending on this channel.
- */
-       typedef DSP_STATUS(*WMD_CHNL_FLUSHIO) (struct CHNL_OBJECT *hChnl,
-						      u32 dwTimeOut);
-
-/*
- *  ======== WMD_CHNL_GetInfo ========
- *  Purpose:
- *      Retrieve information related to a channel.
- *  Parameters:
- *      hChnl:          Handle to a valid channel object, or NULL.
- *      pInfo:          Location to store channel info.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pInfo == NULL.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:        pInfo points to a filled in CHNL_INFO struct,
- *                      if (pInfo != NULL).
- */
-       typedef DSP_STATUS(*WMD_CHNL_GETINFO) (struct CHNL_OBJECT *hChnl,
-						      OUT struct CHNL_INFO
-						      *pChnlInfo);
-
-/*
- *  ======== WMD_CHNL_GetMgrInfo ========
- *  Purpose:
- *      Retrieve information related to the channel manager.
- *  Parameters:
- *      hChnlMgr:           Handle to a valid channel manager, or NULL.
- *      uChnlID:            Channel ID.
- *      pMgrInfo:           Location to store channel manager info.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnlMgr.
- *      DSP_EPOINTER:       pMgrInfo == NULL.
- *      CHNL_E_BADCHANID:   Invalid channel ID.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:            pMgrInfo points to a filled in CHNL_MGRINFO
- *                          struct, if (pMgrInfo != NULL).
- */
-       typedef DSP_STATUS(*WMD_CHNL_GETMGRINFO) (struct CHNL_MGR
-							 *hChnlMgr,
-							 u32 uChnlID,
-							 OUT struct CHNL_MGRINFO
-							 *pMgrInfo);
-
-/*
- *  ======== WMD_CHNL_Idle ========
- *  Purpose:
- *      Idle a channel. If this is an input channel, or if this is an output
- *      channel and fFlush is TRUE, all currently enqueued buffers will be
- *      dequeued (data discarded for output channel).
- *      If this is an output channel and fFlush is FALSE, this function
- *      will block until all currently buffered data is output, or the timeout
- *      specified has been reached.
- *
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
- *                      to wait for buffers to be output. (Not used for
- *                      input channel).
- *      fFlush:         If output channel and fFlush is TRUE, discard any
- *                      currently buffered data. If FALSE, wait for currently
- *                      buffered data to be output, or timeout, whichever
- *                      occurs first. fFlush is ignored for input channel.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
- *  Requires:
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_CHNL_IDLE) (struct CHNL_OBJECT *hChnl,
-						   u32 dwTimeOut,
-						   bool fFlush);
-
-/*
- *  ======== WMD_CHNL_RegisterNotify ========
- *  Purpose:
- *      Register for notification of events on a channel.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      uEventMask:     Type of events to be notified about: IO completion
- *                      (DSP_STREAMIOCOMPLETION) or end of stream
- *                      (DSP_STREAMDONE).
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of a DSP_NOTIFICATION object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EVALUE:     uEventMask is 0 and hNotification was not
- *                      previously registered.
- *      DSP_EHANDLE:    NULL hNotification, hNotification event name
- *                      too long, or hNotification event name NULL.
- *  Requires:
- *      Valid hChnl.
- *      hNotification != NULL.
- *      (uEventMask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
- *      uNotifyType == DSP_SIGNALEVENT.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_CHNL_REGISTERNOTIFY)
-				(struct CHNL_OBJECT *hChnl,
-				u32 uEventMask,
-				u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
-
-/*
- *  ======== WMD_DEV_Create ========
- *  Purpose:
- *      Complete creation of the device object for this board.
- *  Parameters:
- *      phDevContext:   Ptr to location to store a WMD device context.
- *      hDevObject:     Handle to a Device Object, created and managed by WCD.
- *      pConfig:        Ptr to configuration parameters provided by the Windows
- *                      Configuration Manager during device loading.
- *      pDspConfig:     DSP resources, as specified in the registry key for this
- *                      device.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Unable to allocate memory for device context.
- *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
- *                          parameters did not satisfy hardware assumptions
- *                          made by this WMD.
- *  Requires:
- *      phDevContext != NULL;
- *      hDevObject != NULL;
- *      pConfig != NULL;
- *      pDspConfig != NULL;
- *      Fields in pConfig and pDspConfig contain valid values.
- *  Ensures:
- *      DSP_SOK:        All mini-driver specific DSP resource and other
- *                      board context has been allocated.
- *      DSP_EMEMORY:    WMD failed to allocate resources.
- *                      Any acquired resources have been freed.  The WCD will
- *                      not call WMD_DEV_Destroy() if WMD_DEV_Create() fails.
- *  Details:
- *      Called during the CONFIGMG's Device_Init phase. Based on host and
- *      DSP configuration information, create a board context, a handle to
- *      which is passed into other WMD BRD and CHNL functions.  The
- *      board context contains state information for the device. Since the
- *      addresses of all IN pointer parameters may be invalid when this
- *      function returns, they must not be stored into the device context
- *      structure.
- */
-       typedef DSP_STATUS(*WMD_DEV_CREATE) (OUT struct WMD_DEV_CONTEXT
-						    **phDevContext,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct CFG_HOSTRES
-						    *pConfig,
-						    IN CONST struct CFG_DSPRES
-						    *pDspConfig);
-
-/*
- *  ======== WMD_DEV_Ctrl ========
- *  Purpose:
- *      Mini-driver specific interface.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwCmd:          WMD defined command code.
- *      pArgs:          Pointer to an arbitrary argument structure.
- *  Returns:
- *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
- *      in the pArgs structure, and are defined by the WMD implementor.
- *  Requires:
- *      All calls are currently assumed to be synchronous.  There are no
- *      IOCTL completion routines provided.
- *  Ensures:
- */
-typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
-					u32 dwCmd,
-					IN OUT void *pArgs);
-
-/*
- *  ======== WMD_DEV_Destroy ========
- *  Purpose:
- *      Deallocate WMD device extension structures and all other resources
- *      acquired by the mini-driver.
- *      No calls to other mini driver functions may subsequently
- *      occur, except for WMD_DEV_Create().
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device information.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to release a resource previously acquired.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- *      DSP_SOK: Device context is freed.
- */
-       typedef DSP_STATUS(*WMD_DEV_DESTROY) (struct WMD_DEV_CONTEXT
-					     *hDevContext);
-
-/*
- *  ======== WMD_DEH_Create ========
- *  Purpose:
- *      Create an object that manages DSP exceptions from the GPP.
- *  Parameters:
- *      phDehMgr:       Location to store DEH manager on output.
- *      hDevObject:     Handle to DEV object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
- *  Requires:
- *      hDevObject != NULL;
- *      phDehMgr != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_DEH_CREATE) (OUT struct DEH_MGR
-						    **phDehMgr,
-						    struct DEV_OBJECT
-						    *hDevObject);
-
-/*
- *  ======== WMD_DEH_Destroy ========
- *  Purpose:
- *      Destroy the DEH object.
- *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Destroy failed.
- *  Requires:
- *      hDehMgr != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_DEH_DESTROY) (struct DEH_MGR *hDehMgr);
-
-/*
- *  ======== WMD_DEH_RegisterNotify ========
- *  Purpose:
- *      Register for DEH event notification.
- *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Destroy failed.
- *  Requires:
- *      hDehMgr != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_DEH_REGISTERNOTIFY)
-				(struct DEH_MGR *hDehMgr,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
-
-/*
- *  ======== WMD_DEH_GetInfo ========
- *  Purpose:
- *      Get DSP exception info.
- *  Parameters:
- *      phDehMgr:       Location to store DEH manager on output.
- *      pErrInfo:       Ptr to error info structure.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Creation failed.
- *  Requires:
- *      phDehMgr != NULL;
- *      pErrorInfo != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_DEH_GETINFO) (struct DEH_MGR *phDehMgr,
-					struct DSP_ERRORINFO *pErrInfo);
-
-/*
- *  ======== WMD_IO_Create ========
- *  Purpose:
- *      Create an object that manages I/O between CHNL and MSG.
- *  Parameters:
- *      phIOMgr:        Location to store IO manager on output.
- *      hChnlMgr:       Handle to channel manager.
- *      hMsgMgr:        Handle to message manager.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
- *  Requires:
- *      hDevObject != NULL;
- *      Channel manager already created;
- *      Message manager already created;
- *      pMgrAttrs != NULL;
- *      phIOMgr != NULL;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_IO_CREATE) (OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
-
-/*
- *  ======== WMD_IO_Destroy ========
- *  Purpose:
- *      Destroy object created in WMD_IO_Create.
- *  Parameters:
- *      hIOMgr:         IO Manager.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
- *  Requires:
- *      Valid hIOMgr;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_IO_DESTROY) (struct IO_MGR *hIOMgr);
-
-/*
- *  ======== WMD_IO_OnLoaded ========
- *  Purpose:
- *      Called whenever a program is loaded to update internal data. For
- *      example, if shared memory is used, this function would update the
- *      shared memory location and address.
- *  Parameters:
- *      hIOMgr:     IO Manager.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Internal failure occurred.
- *  Requires:
- *      Valid hIOMgr;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_IO_ONLOADED) (struct IO_MGR *hIOMgr);
-
-/*
- *  ======== WMD_IO_GETPROCLOAD ========
- *  Purpose:
- *      Called to get the Processor's current and predicted load
- *  Parameters:
- *      hIOMgr:     IO Manager.
- *      pProcLoadStat   Processor Load statistics
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Internal failure occurred.
- *  Requires:
- *      Valid hIOMgr;
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_IO_GETPROCLOAD)(struct IO_MGR *hIOMgr,
-			   struct DSP_PROCLOADSTAT *pProcLoadStat);
-
-/*
- *  ======== WMD_MSG_Create ========
- *  Purpose:
- *      Create an object to manage message queues. Only one of these objects
- *      can exist per device object.
- *  Parameters:
- *      phMsgMgr:           Location to store MSG manager on output.
- *      hDevObject:         Handle to a device object.
- *      msgCallback:        Called whenever an RMS_EXIT message is received.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
- *  Requires:
- *      phMsgMgr != NULL.
- *      msgCallback != NULL.
- *      hDevObject != NULL.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_MSG_CREATE)
-				(OUT struct MSG_MGR **phMsgMgr,
-				struct DEV_OBJECT *hDevObject,
-				MSG_ONEXIT msgCallback);
-
-/*
- *  ======== WMD_MSG_CreateQueue ========
- *  Purpose:
- *      Create a MSG queue for sending or receiving messages from a Message
- *      node on the DSP.
- *  Parameters:
- *      hMsgMgr:            MSG queue manager handle returned from
- *                          WMD_MSG_Create.
- *      phMsgQueue:         Location to store MSG queue on output.
- *      dwId:               Identifier for messages (node environment pointer).
- *      uMaxMsgs:           Max number of simultaneous messages for the node.
- *      h:                  Handle passed to hMsgMgr->msgCallback().
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
- *  Requires:
- *      phMsgQueue != NULL.
- *      h != NULL.
- *      uMaxMsgs > 0.
- *  Ensures:
- *      phMsgQueue !=NULL <==> DSP_SOK.
- */
-       typedef DSP_STATUS(*WMD_MSG_CREATEQUEUE)
-				(struct MSG_MGR *hMsgMgr,
-				OUT struct MSG_QUEUE **phMsgQueue,
-				u32 dwId, u32 uMaxMsgs, HANDLE h);
-
-/*
- *  ======== WMD_MSG_Delete ========
- *  Purpose:
- *      Delete a MSG manager allocated in WMD_MSG_Create().
- *  Parameters:
- *      hMsgMgr:    Handle returned from WMD_MSG_Create().
- *  Returns:
- *  Requires:
- *      Valid hMsgMgr.
- *  Ensures:
- */
-       typedef void(*WMD_MSG_DELETE) (struct MSG_MGR *hMsgMgr);
-
-/*
- *  ======== WMD_MSG_DeleteQueue ========
- *  Purpose:
- *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
- *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
- *  Returns:
- *  Requires:
- *      Valid hMsgQueue.
- *  Ensures:
- */
-       typedef void(*WMD_MSG_DELETEQUEUE) (struct MSG_QUEUE *hMsgQueue);
-
-/*
- *  ======== WMD_MSG_Get ========
- *  Purpose:
- *      Get a message from a MSG queue.
- *  Parameters:
- *      hMsgQueue:     Handle to MSG queue returned from
- *                     WMD_MSG_CreateQueue.
- *      pMsg:          Location to copy message into.
- *      uTimeout:      Timeout to wait for a message.
- *  Returns:
- *      DSP_SOK:       Success.
- *      DSP_ETIMEOUT:  Timeout occurred.
- *      DSP_EFAIL:     No frames available for message (uMaxMessages too
- *                     small).
- *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_MSG_GET) (struct MSG_QUEUE *hMsgQueue,
-						 struct DSP_MSG *pMsg,
-						 u32 uTimeout);
-
-/*
- *  ======== WMD_MSG_Put ========
- *  Purpose:
- *      Put a message onto a MSG queue.
- *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      pMsg:           Pointer to message.
- *      uTimeout:       Timeout to wait for a message.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ETIMEOUT:   Timeout occurred.
- *      DSP_EFAIL:      No frames available for message (uMaxMessages too
- *                      small).
- *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_MSG_PUT) (struct MSG_QUEUE *hMsgQueue,
-						 IN CONST struct DSP_MSG *pMsg,
-						 u32 uTimeout);
-
-/*
- *  ======== WMD_MSG_RegisterNotify ========
- *  Purpose:
- *      Register notification for when a message is ready.
- *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      uEventMask:     Type of events to be notified about: Must be
- *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of notification object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory.
- *  Requires:
- *      Valid hMsgQueue.
- *      hNotification != NULL.
- *      uNotifyType == DSP_SIGNALEVENT.
- *      uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0.
- *  Ensures:
- */
-       typedef DSP_STATUS(*WMD_MSG_REGISTERNOTIFY)
-				(struct MSG_QUEUE *hMsgQueue,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
-
-/*
- *  ======== WMD_MSG_SetQueueId ========
- *  Purpose:
- *      Set message queue id to node environment. Allows WMD_MSG_CreateQueue
- *      to be called in NODE_Allocate, before the node environment is known.
- *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
- *      dwId:       Node environment pointer.
- *  Returns:
- *  Requires:
- *      Valid hMsgQueue.
- *      dwId != 0.
- *  Ensures:
- */
-       typedef void(*WMD_MSG_SETQUEUEID) (struct MSG_QUEUE *hMsgQueue,
-						  u32 dwId);
-
-/*
- *  'Bridge Mini Driver (WMD) interface function table.
- *
- *  The information in this table is filled in by the specific mini-driver,
- *  and copied into the 'Bridge class driver's own space.  If any interface
- *  function field is set to a value of NULL, then the class driver will
- *  consider that function not implemented, and return the error code
- *  DSP_ENOTIMPL when a WMD client attempts to call that function.
- *
- *  This function table contains WCD version numbers, which are used by the
- *  WMD loader to help ensure backwards compatility between older WMD's and a
- *  newer 'Bridge Class Driver.  These must be set to WCD_MAJOR_VERSION
- *  and WCD_MINOR_VERSION, respectively.
- *
- *  A mini-driver need not export a CHNL interface.  In this case, *all* of
- *  the WMD_CHNL_* entries must be set to NULL.
- */
-	struct WMD_DRV_INTERFACE {
-		u32 dwWCDMajorVersion;	/* Set to WCD_MAJOR_VERSION. */
-		u32 dwWCDMinorVersion;	/* Set to WCD_MINOR_VERSION. */
-		WMD_DEV_CREATE pfnDevCreate;	/* Create device context     */
-		WMD_DEV_DESTROY pfnDevDestroy;	/* Destroy device context    */
-		WMD_DEV_CTRL pfnDevCntrl;	/* Optional vendor interface */
-		WMD_BRD_MONITOR pfnBrdMonitor;	/* Load and/or start monitor */
-		WMD_BRD_START pfnBrdStart;	/* Start DSP program.        */
-		WMD_BRD_STOP pfnBrdStop;	/* Stop/reset board.         */
-		WMD_BRD_STATUS pfnBrdStatus;	/* Get current board status. */
-		WMD_BRD_READ pfnBrdRead;	/* Read board memory         */
-		WMD_BRD_WRITE pfnBrdWrite;	/* Write board memory.       */
-		WMD_BRD_SETSTATE pfnBrdSetState;  /* Sets the Board State */
-		WMD_BRD_MEMCOPY pfnBrdMemCopy;	 /* Copies DSP Memory         */
-		WMD_BRD_MEMWRITE pfnBrdMemWrite; /* Write DSP Memory w/o halt */
-		WMD_BRD_MEMMAP pfnBrdMemMap;	 /* Maps MPU mem to DSP mem   */
-		WMD_BRD_MEMUNMAP pfnBrdMemUnMap; /* Unmaps MPU mem to DSP mem */
-		WMD_CHNL_CREATE pfnChnlCreate;	 /* Create channel manager.   */
-		WMD_CHNL_DESTROY pfnChnlDestroy; /* Destroy channel manager.  */
-		WMD_CHNL_OPEN pfnChnlOpen;	 /* Create a new channel.     */
-		WMD_CHNL_CLOSE pfnChnlClose;	 /* Close a channel.          */
-		WMD_CHNL_ADDIOREQ pfnChnlAddIOReq; /* Req I/O on a channel. */
-		WMD_CHNL_GETIOC pfnChnlGetIOC;	 /* Wait for I/O completion.  */
-		WMD_CHNL_CANCELIO pfnChnlCancelIO; /* Cancl I/O on a channel. */
-		WMD_CHNL_FLUSHIO pfnChnlFlushIO;	/* Flush I/O.         */
-		WMD_CHNL_GETINFO pfnChnlGetInfo; /* Get channel specific info */
-		/* Get channel manager info. */
-		WMD_CHNL_GETMGRINFO pfnChnlGetMgrInfo;
-		WMD_CHNL_IDLE pfnChnlIdle;	/* Idle the channel */
-		/* Register for notif. */
-		WMD_CHNL_REGISTERNOTIFY pfnChnlRegisterNotify;
-		WMD_DEH_CREATE pfnDehCreate;	/* Create DEH manager */
-		WMD_DEH_DESTROY pfnDehDestroy;	/* Destroy DEH manager */
-		WMD_DEH_NOTIFY pfnDehNotify;    /* Notify of DSP error */
-		/* register for deh notif. */
-		WMD_DEH_REGISTERNOTIFY pfnDehRegisterNotify;
-		WMD_DEH_GETINFO pfnDehGetInfo;	/* register for deh notif. */
-		WMD_IO_CREATE pfnIOCreate;	/* Create IO manager */
-		WMD_IO_DESTROY pfnIODestroy;	/* Destroy IO manager */
-		WMD_IO_ONLOADED pfnIOOnLoaded;	/* Notify of program loaded */
-		/* Get Processor's current and predicted load */
-		WMD_IO_GETPROCLOAD pfnIOGetProcLoad;
-		WMD_MSG_CREATE pfnMsgCreate;	/* Create message manager */
-		/* Create message queue */
-		WMD_MSG_CREATEQUEUE pfnMsgCreateQueue;
-		WMD_MSG_DELETE pfnMsgDelete;	/* Delete message manager */
-		/* Delete message queue */
-		WMD_MSG_DELETEQUEUE pfnMsgDeleteQueue;
-		WMD_MSG_GET pfnMsgGet;	/* Get a message */
-		WMD_MSG_PUT pfnMsgPut;	/* Send a message */
-		/* Register for notif. */
-		WMD_MSG_REGISTERNOTIFY pfnMsgRegisterNotify;
-		/* Set message queue id */
-		WMD_MSG_SETQUEUEID pfnMsgSetQueueId;
-	} ;
-
-/*
- *  ======== WMD_DRV_Entry ========
- *  Purpose:
- *      Registers WMD functions with the class driver. Called only once
- *      by the WCD.  The caller will first check WCD version compatibility, and
- *      then copy the interface functions into its own memory space.
- *  Parameters:
- *      ppDrvInterface  Pointer to a location to receive a pointer to the
- *                      mini driver interface.
- *  Returns:
- *  Requires:
- *      The code segment this function resides in must expect to be discarded
- *      after completion.
- *  Ensures:
- *      ppDrvInterface pointer initialized to WMD's function interface.
- *      No system resources are acquired by this function.
- *  Details:
- *      Win95: Called during the Device_Init phase.
- */
-       void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
-				 IN CONST char *pstrWMDFileName);
-
-#endif				/* WMD_ */
--- a/arch/arm/plat-omap/include/bridge/wmdioctl.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmdioctl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmdioctl.h ========
- *  Description:
- *    BRIDGE Minidriver BRD_IOCtl reserved command definitions.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb   Updated HW typedefs
- *! 16-Feb-2004 vp   Added MMU endianness attributes to WMDIOCTL_EXTPROC
- *! 21-Mar-2003 sb   Changed WMDIOCTL_NUMOFMMUTLB from 7 to 32
- *! 14-May-2001 sg   Added codes for PWR.
- *! 10-Aug-2001 ag   Added _SETMMUCONFIG ioctl used for DSP-MMU init.
- *! 16-Nov-1999 rajesh ?
- *! 18-Jun-1998 ag   Moved EMIF, SDRAM_C, & CE space init to ENBLEXTMEM ioctl.
- *!                  Added ENBLEXTMEM, RESETDSP, UNRESETDSP & ASSERTSIG ioctls.
- *! 07-Jun-1998 ag   Added JTAG_SELECT, MAP_TBC, GET_CONFIGURATION ioctls.
- *! 26-Jan-1998 jeh: Added START, RECV, and SEND ioctls.
- *! 07-Nov-1997 nn:  Added command to interrupt DSP for interrupt test.
- *! 20-Oct-1997 nn:  Added commands for getting and resetting interrupt count.
- *! 17-Oct-1997 gp:  Moved to src/wmd. Standardized prefix.
- *! 08-Oct-1997 nn:  Created.
- */
-
-#ifndef WMDIOCTL_
-#define WMDIOCTL_
-
-/* ------------------------------------ Hardware Abstraction Layer */
-#include <hw_defs.h>
-#include <hw_mmu.h>
-
-/* Any IOCTLS at or above this value are reserved for standard WMD interfaces.*/
-#define WMDIOCTL_RESERVEDBASE       0x8000
-
-#define WMDIOCTL_CHNLREAD           (WMDIOCTL_RESERVEDBASE + 0x10)
-#define WMDIOCTL_CHNLWRITE          (WMDIOCTL_RESERVEDBASE + 0x20)
-#define WMDIOCTL_GETINTRCOUNT       (WMDIOCTL_RESERVEDBASE + 0x30)
-#define WMDIOCTL_RESETINTRCOUNT     (WMDIOCTL_RESERVEDBASE + 0x40)
-#define WMDIOCTL_INTERRUPTDSP       (WMDIOCTL_RESERVEDBASE + 0x50)
-#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)   /* DMMU */
-#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)   /* PWR */
-
-/* attention, modifiers:
- * Some of these control enumerations are made visible to user for power
- * control, so any changes to this list, should also be updated in the user
- * header file 'dbdefs.h' ***/
-/* These ioctls are reserved for PWR power commands for the DSP */
-#define WMDIOCTL_DEEPSLEEP          (WMDIOCTL_PWRCONTROL + 0x0)
-#define WMDIOCTL_EMERGENCYSLEEP     (WMDIOCTL_PWRCONTROL + 0x1)
-#define WMDIOCTL_WAKEUP             (WMDIOCTL_PWRCONTROL + 0x2)
-#define WMDIOCTL_PWRENABLE          (WMDIOCTL_PWRCONTROL + 0x3)
-#define WMDIOCTL_PWRDISABLE         (WMDIOCTL_PWRCONTROL + 0x4)
-#define WMDIOCTL_CLK_CTRL		    (WMDIOCTL_PWRCONTROL + 0x7)
-#define WMDIOCTL_PWR_HIBERNATE (WMDIOCTL_PWRCONTROL + 0x8) /*DSP Initiated
-							    * Hibernate*/
-#define WMDIOCTL_PRESCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0x9)
-#define WMDIOCTL_POSTSCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0xA)
-#define WMDIOCTL_CONSTRAINT_REQUEST (WMDIOCTL_PWRCONTROL + 0xB)
-
-/* Number of actual DSP-MMU TLB entrries */
-#define WMDIOCTL_NUMOFMMUTLB        32
-
-struct WMDIOCTL_EXTPROC {
-	u32 ulDspVa;		/* DSP virtual address */
-	u32 ulGppPa;		/* GPP physical address */
-	/* GPP virtual address. __va does not work for ioremapped addresses */
-	u32 ulGppVa;
-	u32 ulSize;		/* Size of the mapped memory in bytes */
-	enum HW_Endianism_t endianism;
-	enum HW_MMUMixedSize_t mixedMode;
-	enum HW_ElementSize_t elemSize;
-};
-
-#endif				/* WMDIOCTL_ */
-
--- a/arch/arm/plat-omap/include/bridge/wmdio.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmdio.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmdio.h ========
- *  Description:
- *      Declares the upper edge IO  functions required by
- *      all WMD / WCD driver interface tables.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 27-Feb-2004 vp		Added IVA releated function.
- *! 06-Nov-2000 jeh     Created.
- */
-
-#ifndef WMDIO_
-#define WMDIO_
-
-#include <devdefs.h>
-#include <iodefs.h>
-
-	extern DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
-
-	extern DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr);
-
-	extern DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr);
-
-	extern DSP_STATUS IVA_IO_OnLoaded(struct IO_MGR *hIOMgr);
-	extern DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
-				OUT struct DSP_PROCLOADSTAT *pProcStat);
-
-#endif				/* WMDIO_ */
--- a/arch/arm/plat-omap/include/bridge/wmdmsg.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * arch/arm/plat-omap/include/bridge/wmdmsg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== wmdmsg.h ========
- *  Description:
- *      Declares the upper edge message class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are
- *      implemented by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 06-Dec-2000 jeh     Added uEventMask to WMD_MSG_RegisterNotify(). Added
- *!                     WMD_MSG_SetQueueId().
- *! 17-Nov-2000 jeh     Created.
- */
-
-#ifndef WMDMSG_
-#define WMDMSG_
-
-#include <msgdefs.h>
-
-	extern DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-					 struct DEV_OBJECT *hDevObject,
-					 MSG_ONEXIT msgCallback);
-
-	extern DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
-					      OUT struct MSG_QUEUE **phMsgQueue,
-					      u32 dwId, u32 uMaxMsgs,
-					      HANDLE h);
-
-	extern void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr);
-
-	extern void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue);
-
-	extern DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
-				      struct DSP_MSG *pMsg, u32 uTimeout);
-
-	extern DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
-				      IN CONST struct DSP_MSG *pMsg,
-				      u32 uTimeout);
-
-	extern DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
-
-	extern void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId);
-
-#endif				/* WMDMSG_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/brddefs.h
@@ -0,0 +1,54 @@
+/*
+ * arch/arm/plat-omap/include/bridge/brddefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== brddefs.h ========
+ *  Description:
+ *      Global BRD constants and types, shared between WSX, WCD, and WMD.
+ *
+ *! Revision History:
+ *! ================
+ *! 31-Jan-2000 rr: Comment Exec changed to Monitor
+ *! 22-Jul-1999 jeh Added BRD_LOADED state.
+ *! 26-Mar-1997 gp: Added BRD_SYNCINIT state.
+ *! 11-Dec-1996 cr: Added BRD_LASTSTATE definition.
+ *! 11-Jul-1996 gp: Added missing u32 callback argument to BRD_CALLBACK.
+ *! 10-Jun-1996 gp: Created from board.h and brd.h.
+ */
+
+#ifndef BRDDEFS_
+#define BRDDEFS_
+
+/* platform status values */
+#define BRD_STOPPED     0x0	/* No Monitor Loaded, Not running. */
+#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended.  */
+#define BRD_RUNNING     0x2	/* Monitor loaded, and executing.  */
+#define BRD_UNKNOWN     0x3	/* Board state is indeterminate. */
+#define BRD_SYNCINIT    0x4
+#define BRD_LOADED      0x5
+#define BRD_LASTSTATE   BRD_LOADED	/* Set to highest legal board state. */
+#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress  */
+#define BRD_HIBERNATION 0x7		/* MPU initiated hibernation */
+#define BRD_RETENTION     0x8       /* Retention mode */
+#define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
+#define BRD_ERROR		0xA       /* Board state is Error */
+	typedef u32 BRD_STATUS;
+
+/* BRD Object */
+	struct BRD_OBJECT;
+
+#endif				/* BRDDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
@@ -0,0 +1,127 @@
+/*
+ * arch/arm/plat-omap/include/bridge/cfgdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== cfgdefs.h ========
+ *  Purpose:
+ *      Global CFG constants and types, shared between class and mini driver.
+ *
+ *! Revision History:
+ *! ================
+ *! 24-Feb-2003 kc  Removed wIOPort* in CFG_HOSTRES.
+ *! 06-Sep-2000 jeh Added channel info to CFG_HOSTRES.
+ *! 09-May-2000 rr: CFG_HOSTRES now support multiple windows for PCI support.
+ *! 31-Jan-2000 rr: Comments changed after code review.
+ *! 06-Jan-2000 rr: Bus Type included in CFG_HOSTRES.
+ *! 12-Nov-1999 rr: CFG_HOSTRES member names changed.
+ *! 25-Oct-1999 rr: Modified the CFG_HOSTRES Structure
+ *!                 PCMCIA ISR Register/Unregister fxn removed..
+ *!                 New flag PCCARD introduced during compile time.
+ *! 10-Sep-1999 ww: Added PCMCIA ISR Register/Unregister fxn.
+ *! 01-Sep-1999 ag: Removed NT/95 specific fields in CFG_HOSTRES
+ *! 27-Oct-1997 cr: Updated CFG_HOSTRES struct to support 1+ IRQs per board.
+ *! 17-Sep-1997 gp: Tacked some NT config info to end of CFG_HOSTRES structure.
+ *! 12-Dec-1996 cr: Cleaned up after code review.
+ *! 14-Nov-1996 gp: Renamed from wsxcfg.h
+ *! 19-Jun-1996 cr: Created.
+ */
+
+#ifndef CFGDEFS_
+#define CFGDEFS_
+
+/* Maximum length of module search path. */
+#define CFG_MAXSEARCHPATHLEN    255
+
+/* Maximum length of general paths. */
+#define CFG_MAXPATH             255
+
+/* Host Resources:  */
+#define CFG_MAXMEMREGISTERS     9
+#define CFG_MAXIOPORTS          20
+#define CFG_MAXIRQS             7
+#define CFG_MAXDMACHANNELS      7
+
+/* IRQ flag */
+#define CFG_IRQSHARED           0x01	/* IRQ can be shared */
+
+/* DSP Resources: */
+#define CFG_DSPMAXMEMTYPES      10
+#define CFG_DEFAULT_NUM_WINDOWS 1	/* We support only one window. */
+
+/* A platform-related device handle: */
+	struct CFG_DEVNODE;
+
+/*
+ *  Host resource structure.
+ */
+	struct CFG_HOSTRES {
+		u32 wNumMemWindows;	/* Set to default */
+		/* This is the base.memory */
+		u32 dwMemBase[CFG_MAXMEMREGISTERS];  /* SHM virtual address */
+		u32 dwMemLength[CFG_MAXMEMREGISTERS]; /* Length of the Base */
+		u32 dwMemPhys[CFG_MAXMEMREGISTERS]; /* SHM Physical address */
+		u8 bIRQRegisters;	/* IRQ Number */
+		u8 bIRQAttrib;	/* IRQ Attribute */
+		u32 dwOffsetForMonitor;	/* The Shared memory starts from
+					 * dwMemBase + this offset */
+		u32 dwBusType;	/* Bus type for this device */
+		u32 dwProgBase;	/* DSP ProgBase */
+		u32 dwProgLength;	/* DSP ProgBase Length */
+		u32 dwRegBase;	/* DSP memory mapped register base */
+		u32 dwRegLength;	/* DSP Register Base Length */
+		u32 ClientHandle;	/* Client Handle */
+		u32 SocketHandle;	/* Socket and Function Pair */
+		u32 CardInfo;	/* This will be used as a context data in
+				 * in the CardRequestIRQ */
+	/*
+	 *  Info needed by NODE for allocating channels to communicate with RMS:
+	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
+	 *                          reserved.
+	 *      dwChnlBufSize:      Size of channel buffer to send to RMS
+	 *      dwNumChnls:       Total number of channels (including reserved).
+	 */
+		u32 dwChnlOffset;
+		u32 dwChnlBufSize;
+		u32 dwNumChnls;
+
+#ifdef CONFIG_ARCH_OMAP3430
+		u32 dwPrmBase;
+		u32 dwCmBase;
+		u32 dwPerBase;
+		u32 dwWdTimerDspBase;
+		u32 dwMboxBase;
+		u32 dwDmmuBase;
+		u32 dwDipiBase;
+		u32 dwSysCtrlBase;
+#endif
+	} ;
+
+	struct CFG_DSPMEMDESC {
+		u32 uMemType;	/* Type of memory.                        */
+		u32 ulMin;	/* Minimum amount of memory of this type. */
+		u32 ulMax;	/* Maximum amount of memory of this type. */
+	} ;
+
+	struct CFG_DSPRES {
+		u32 uChipType;	/* DSP chip type.               */
+		u32 uWordSize;	/* Number of bytes in a word    */
+		u32 cChips;	/* Number of chips.             */
+		u32 cMemTypes;	/* Types of memory.             */
+		struct CFG_DSPMEMDESC aMemDesc[CFG_DSPMAXMEMTYPES];
+		/* DSP Memory types */
+	} ;
+
+#endif				/* CFGDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cfg.h
@@ -0,0 +1,339 @@
+/*
+ * arch/arm/plat-omap/include/bridge/cfg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== cfg.h ========
+ *  Purpose:
+ *      PM Configuration module.
+ *
+ *  Private Functions:
+ *      CFG_Exit
+ *      CFG_GetAutoStart
+ *      CFG_GetCDVersion
+ *      CFG_GetDevObject
+ *      CFG_GetDSPResources
+ *      CFG_GetExecFile
+ *      CFG_GetHostResources
+ *      CFG_GetObject
+ *      CFG_GetPerfValue
+ *      CFG_GetWMDFileName
+ *      CFG_GetZLFile
+ *      CFG_Init
+ *      CFG_SetDevObject
+ *      CFG_SetObject
+ *
+ *! Revision History:
+ *! =================
+ *! 26-Feb-2003 kc  Removed unused CFG fxns.
+ *! 28-Aug-2001 jeh  Added CFG_GetLoaderName.
+ *! 26-Jul-2000 rr:  Added CFG_GetDCDName to retrieve the DCD Dll name.
+ *! 13-Jul-2000 rr:  Added CFG_GetObject & CFG_SetObject.
+ *! 13-Jan-2000 rr:  CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
+ *!                  CFG_GetWinBRIDGEDir/Directory,CFG_GetSearchPath removed.
+ *! 15-Jan-1998 cr:  Code review cleanup.
+ *! 16-Aug-1997 cr:  Added explicit cdecl identifiers.
+ *! 12-Dec-1996 gp:  Moved CFG_FindInSearchPath to CSP module.
+ *! 13-Sep-1996 gp:  Added CFG_GetBoardName().
+ *! 22-Jul-1996 gp:  Added CFG_GetTraceStr, to retrieve an initial GT trace.
+ *! 26-Jun-1996 cr:  Added CFG_FindInSearchPath.
+ *! 25-Jun-1996 cr:  Added CFG_GetWinSPOXDir.
+ *! 17-Jun-1996 cr:  Added CFG_GetDevNode.
+ *! 11-Jun-1996 cr:  Cleaned up for code review.
+ *! 07-Jun-1996 cr:  Added CFG_GetExecFile and CFG_GetZLFileName functions.
+ *! 04-Jun-1996 gp:  Added AutoStart regkey and accessor function.  Placed
+ *!                  OUT parameters in accessor function param. lists at end.
+ *! 29-May-1996 gp:  Moved DEV_HDEVNODE to here and renamed CFG_HDEVNODE.
+ *! 22-May-1996 cr:  Added GetHostResources, GetDSPResources, and
+ *!                  GetWMDFileName services.
+ *! 18-May-1996 gp:  Created.
+ */
+
+#ifndef CFG_
+#define CFG_
+#include <host_os.h>
+#include <cfgdefs.h>
+
+/*
+ *  ======== CFG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CFG module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CFG_Init() was previously called.
+ *  Ensures:
+ *      Resources acquired in CFG_Init() are freed.
+ */
+	extern void CFG_Exit();
+
+/*
+ *  ======== CFG_GetAutoStart ========
+ *  Purpose:
+ *      Retreive the autostart mask, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      pdwAutoStart:   Ptr to location for 32 bit autostart mask.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: Unable to retreive resource.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        *pdwAutoStart contains autostart mask for this devnode.
+ */
+	extern DSP_STATUS CFG_GetAutoStart(IN struct CFG_DEVNODE *hDevNode,
+					   OUT u32 *pdwAutoStart);
+
+/*
+ *  ======== CFG_GetCDVersion ========
+ *  Purpose:
+ *      Retrieves the version of the PM Class Driver.
+ *  Parameters:
+ *      pdwVersion: Ptr to u32 to contain version number upon return.
+ *  Returns:
+ *      DSP_SOK:    Success.  pdwVersion contains Class Driver version in
+ *                  the form: 0xAABBCCDD where AABB is Major version and
+ *                  CCDD is Minor.
+ *      DSP_EFAIL:  Failure.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Success.
+ *      else:       *pdwVersion is NULL.
+ */
+	extern DSP_STATUS CFG_GetCDVersion(OUT u32 *pdwVersion);
+
+/*
+ *  ======== CFG_GetDevObject ========
+ *  Purpose:
+ *      Retrieve the Device Object handle for a given devnode.
+ *  Parameters:
+ *      hDevNode:       Platform's DevNode handle from which to retrieve value.
+ *      pdwValue:       Ptr to location to store the value.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDPOINTER:   phDevObject is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    *pdwValue is set to the retrieved u32.
+ *      else:       *pdwValue is set to 0L.
+ */
+	extern DSP_STATUS CFG_GetDevObject(IN struct CFG_DEVNODE *hDevNode,
+					   OUT u32 *pdwValue);
+
+/*
+ *  ======== CFG_GetDSPResources ========
+ *  Purpose:
+ *      Get the DSP resources available to a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      pDSPResTable:   Ptr to a location to store the DSP resource table.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The DSP Resource information is not
+ *                              available
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    pDSPResTable points to a filled table of resources allocated
+ *                  for the specified WMD.
+ */
+	extern DSP_STATUS CFG_GetDSPResources(IN struct CFG_DEVNODE *hDevNode,
+				      OUT struct CFG_DSPRES *pDSPResTable);
+
+
+/*
+ *  ======== CFG_GetExecFile ========
+ *  Purpose:
+ *      Retreive the default executable, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pstrExecFile:   Ptr to character buf to hold ExecFile.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDPOINTER:   pstrExecFile is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Not more than cBufSize bytes were copied into pstrExecFile,
+ *                  and *pstrExecFile contains default executable for this
+ *                  devnode.
+ */
+	extern DSP_STATUS CFG_GetExecFile(IN struct CFG_DEVNODE *hDevNode,
+					  IN u32 cBufSize,
+					  OUT char *pstrExecFile);
+
+/*
+ *  ======== CFG_GetHostResources ========
+ *  Purpose:
+ *      Get the Host PC allocated resources assigned to a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      pHostResTable:  Ptr to a location to store the host resource table.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDPOINTER:   pHostResTable is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    pHostResTable points to a filled table of resources
+ *                  allocated for the specified WMD.
+ *
+ */
+	extern DSP_STATUS CFG_GetHostResources(IN struct CFG_DEVNODE *hDevNode,
+				       OUT struct CFG_HOSTRES *pHostResTable);
+
+/*
+ *  ======== CFG_GetObject ========
+ *  Purpose:
+ *      Retrieve the Driver Object handle From the Registry
+ *  Parameters:
+ *      pdwValue:   Ptr to location to store the value.
+ *      dwType      Type of Object to Get
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    *pdwValue is set to the retrieved u32(non-Zero).
+ *      else:       *pdwValue is set to 0L.
+ */
+	extern DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType);
+
+/*
+ *  ======== CFG_GetPerfValue ========
+ *  Purpose:
+ *      Retrieve a flag indicating whether PERF should log statistics for the
+ *      PM class driver.
+ *  Parameters:
+ *      pfEnablePerf:   Location to store flag.  0 indicates the key was
+ *                      not found, or had a zero value.  A nonzero value
+ *                      means the key was found and had a nonzero value.
+ *  Returns:
+ *  Requires:
+ *      pfEnablePerf != NULL;
+ *  Ensures:
+ */
+	extern void CFG_GetPerfValue(OUT bool *pfEnablePerf);
+
+/*
+ *  ======== CFG_GetWMDFileName ========
+ *  Purpose:
+ *    Get the mini-driver file name for a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pWMDFileName:   Ptr to a character buffer to hold the WMD filename.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The filename is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        Not more than cBufSize bytes were copied
+ *                      into pWMDFileName.
+ *
+ */
+	extern DSP_STATUS CFG_GetWMDFileName(IN struct CFG_DEVNODE *hDevNode,
+					     IN u32 cBufSize,
+					     OUT char *pWMDFileName);
+
+/*
+ *  ======== CFG_GetZLFile ========
+ *  Purpose:
+ *      Retreive the ZLFile, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pstrZLFileName: Ptr to character buf to hold ZLFileName.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDPOINTER:   pstrZLFileName is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: couldn't find the ZLFileName.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Not more than cBufSize bytes were copied into
+ *                  pstrZLFileName, and *pstrZLFileName contains ZLFileName
+ *                  for this devnode.
+ */
+	extern DSP_STATUS CFG_GetZLFile(IN struct CFG_DEVNODE *hDevNode,
+					IN u32 cBufSize,
+					OUT char *pstrZLFileName);
+
+/*
+ *  ======== CFG_Init ========
+ *  Purpose:
+ *      Initialize the CFG module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CFG functions.
+ */
+	extern bool CFG_Init();
+
+/*
+ *  ======== CFG_SetDevObject ========
+ *  Purpose:
+ *      Store the Device Object handle for a given devnode.
+ *  Parameters:
+ *      hDevNode:   Platform's DevNode handle we are storing value with.
+ *      dwValue:    Arbitrary value to store.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      DSP_EFAIL:              Internal Error.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    The Private u32 was successfully set.
+ */
+	extern DSP_STATUS CFG_SetDevObject(IN struct CFG_DEVNODE *hDevNode,
+					   IN u32 dwValue);
+
+/*
+ *  ======== CFG_SetDrvObject ========
+ *  Purpose:
+ *      Store the Driver Object handle.
+ *  Parameters:
+ *      dwValue:        Arbitrary value to store.
+ *      dwType          Type of Object to Store
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Internal Error.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        The Private u32 was successfully set.
+ */
+	extern DSP_STATUS CFG_SetObject(IN u32 dwValue, IN u32 dwType);
+
+#endif				/* CFG_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnldefs.h
@@ -0,0 +1,92 @@
+/*
+ * arch/arm/plat-omap/include/bridge/chnldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== chnldefs.h ========
+ *  Purpose:
+ *      System-wide channel objects and constants.
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Jan-2002 ag  Added cBufSize to IOC.
+ *! 05-Jan-2000 ag: Text format cleanup.
+ *! 02-Dec-1999 ag: Added new chnl attribute pstrEventName.
+ *! 12-Nov-1999 kc: Enabled hEvent attribute for tests.
+ *! 01-Nov-1999 ag: hEvent attribute not supported(yet).
+ *! 16-Jan-1997 gp: Moved private stuff into chnlpriv.h
+ *! 14-Jan-1997 gp: Updated based on code review feedback:
+ *!                 Removed CHNL_MODENOWAIT, CHNL_MODEDIRECT,
+ *! 03-Jan-1997 gp: Added channel class library types.
+ *! 14-Dec-1996 gp: Moved uChnlId field from CHNL_ATTRS to CHNL_Open().
+ *! 10-Dec-1996 gp: Added CHNL_IsTimedOut() macro.
+ *! 14-Nov-1996 gp: Renamed from wsxchnl.h.
+ *! 09-Sep-1996 gp: Added hReserved2 field to CHNL_ATTRS. Updated CHNL_INFO.
+ *! 10-Jul-1996 gp: Created from channel.h.
+ */
+
+#ifndef CHNLDEFS_
+#define CHNLDEFS_
+
+/* Channel id option. */
+#define CHNL_PICKFREE       (~0UL)	/* Let manager pick a free channel. */
+
+/* Channel manager limits: */
+#define CHNL_INITIOREQS      4	/* Default # of I/O requests.       */
+
+/* Channel modes */
+#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP.      */
+#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP.    */
+
+/* GetIOCompletion flags */
+#define CHNL_IOCINFINITE     0xffffffff	/* Wait forever for IO completion. */
+#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available.   */
+
+/* IO Completion Record status: */
+#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed.             */
+#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled          */
+#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out.   */
+#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached.    */
+
+/* Macros for checking I/O Completion status: */
+#define CHNL_IsEOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
+#define CHNL_IsIOComplete(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
+#define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
+#define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
+
+/* CHNL types: */
+	typedef u32 CHNL_MODE;	/* Channel transfer mode.         */
+
+/* Channel attributes: */
+	struct CHNL_ATTRS {
+		u32 uIOReqs;	/* Max # of preallocated I/O requests.    */
+		HANDLE hEvent;	/* User supplied auto-reset event object. */
+		char *pstrEventName;	/* Ptr to name of user event object.  */
+		HANDLE hReserved1;	/* Reserved for future use.         */
+		u32 hReserved2;	/* Reserved for future use.        */
+
+	};
+
+/* I/O completion record: */
+	struct CHNL_IOC {
+		void *pBuf;	/* Buffer to be filled/emptied.           */
+		u32 cBytes;	/* Bytes transferred.                     */
+		u32 cBufSize;	/* Actual buffer size in bytes            */
+		u32 status;	/* Status of IO completion.               */
+		u32 dwArg;	/* User argument associated with pBuf.    */
+	} ;
+
+#endif				/* CHNLDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnl.h
@@ -0,0 +1,537 @@
+/*
+ * arch/arm/plat-omap/include/bridge/chnl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== chnl.h ========
+ *  Description:
+ *      WCD channel interface: multiplexes data streams through the single
+ *      physical link managed by a mini-driver.
+ *
+ *  Public Functions:
+ *      CHNL_AddIOReq
+ *      CHNL_AllocBuffer
+ *      CHNL_CancelIO
+ *      CHNL_Close
+ *      CHNL_CloseOrphans
+ *      CHNL_Create
+ *      CHNL_Destroy
+ *      CHNL_Exit
+ *      CHNL_FlushIO
+ *      CHNL_FreeBuffer
+ *      CHNL_GetEventHandle
+ *      CHNL_GetHandle
+ *      CHNL_GetIOCompletion
+ *      CHNL_GetId
+ *      CHNL_GetMgr
+ *      CHNL_GetMode
+ *      CHNL_GetPosition
+ *      CHNL_GetProcessHandle
+ *      CHNL_Init
+ *      CHNL_Open
+ *
+ *  Notes:
+ *      See DSP API chnl.h for more details.
+ *
+ *! Revision History:
+ *! ================
+ *! 14-Jan-1997 gp: Updated based on code review feedback.
+ *! 24-Oct-1996 gp: Move CloseOrphans into here from dspsys.
+ *! 09-Sep-1996 gp: Added CHNL_GetProcessID() and CHNL_GetHandle().
+ *! 10-Jul-1996 gp: Created.
+ */
+
+#ifndef CHNL_
+#define CHNL_
+
+#include <chnlpriv.h>
+
+/*
+ *  ======== CHNL_AddIOReq ========
+ *  Purpose:
+ *      Enqueue an I/O request for data transfer with the DSP on this channel.
+ *      The direction (mode) is specified in the channel object.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      pHostBuf:       Host buffer address source.
+ *      cBytes:         Number of PC bytes to transfer. A zero value indicates
+ *                      that this buffer is the last in the output channel.
+ *                      A zero value is invalid for an input channel.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pHostBuf is invalid.
+ *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
+ *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
+ *                      I/O is allowed.
+ *      CHNL_E_EOS:     End of stream was already marked on a previous
+ *                      IORequest on this output channel. Not returned for
+ *                      input channels.
+ *      CHNL_E_NOIORPS: No free IO request packets available for queuing.
+ *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
+ *                      the size of the physical shared memory output window.
+ *  Requires:
+ *      CHNL_Init() called.
+ *      pHostBuf points to memory which can be safely accessed at interrupt
+ *      time without page fault.
+ *  Ensures:
+ *      The buffer will be transferred if the channel is ready; otherwise, will
+ *      be queued for transfer when the channel becomes ready.  In any case,
+ *      notifications of I/O completion are asynchronous.
+ *      If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's on
+ *      this channel will fail with error code CHNL_E_EOS.  The corresponding
+ *      IOC for this I/O request will have its status flag set to
+ *      CHNL_IOCSTATEOS.
+ */
+	extern DSP_STATUS CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
+					void *pHostBuf,
+					u32 cBytes);
+
+/*
+ *  ======== CHNL_AllocBuffer ========
+ *  Purpose:
+ *      Allocate a zero-initialized buffer to be used in data transfers though
+ *      a channel managed by this channel manager.
+ *  Parameters:
+ *      ppBuf:              Location to store buffer pointer.
+ *      hChnlMgr:           Handle to a valid channel manager.
+ *      cBytes:             Size of buffer in bytes. Must be greater than zero.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EPOINTER:       ppBuf is invalid.
+ *      DSP_EHANDLE:        hChnlMgr is invalid.
+ *      DSP_EMEMORY:        Insufficient memory to allocate buffer.
+ *      DSP_EINVALIDARG:    Invalid cBytes value.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      DSP_SOK:            *ppBuf points to memory which can be accessed in
+ *                          any context.
+ *      else:               *ppBuf contains NULL if ppBuf != NULL.
+ */
+	extern DSP_STATUS CHNL_AllocBuffer(OUT void **ppBuf,
+					   struct CHNL_MGR *hChnlMgr,
+					   u32 cBytes);
+
+/*
+ *  ======== CHNL_CancelIO ========
+ *  Purpose:
+ *      Return all I/O requests to the client which have not yet been
+ *      transferred.  The channel's I/O completion object is
+ *      signalled, and all the I/O requests are queued as IOC's, with the
+ *      status field set to CHNL_IOCSTATCANCEL.
+ *      This call is typically used in abort situations, and is a prelude to
+ *      CHNL_Close();
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:           Success;
+ *      DSP_EHANDLE:       Invalid hChnl.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      Subsequent I/O requests to this channel will not be accepted.
+ */
+	extern DSP_STATUS CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
+
+/*
+ *  ======== CHNL_Close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *      CHNL_Init() called.
+ *      No thread must be blocked on this channel's I/O completion event.
+ *  Ensures:
+ *      DSP_SOK:        The I/O completion event for this channel is freed.
+ *                      hChnl is no longer valid.
+ */
+	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
+
+/*
+ *  ======== CHNL_CloseOrphans ========
+ *  Purpose:
+ *      Close open channels orphaned by a closing process.
+ *  Parameters:
+ *      hChnlMgr:       Channel manager holding the channels.
+ *      hProcess:       Kernel mode handle of the process claiming the channels.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_SFALSE:     No channels were left open by this process.
+ *      DSP_EHANDLE:    Invalid hChnlMgr handle.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_CloseOrphans(struct CHNL_MGR *hChnlMgr,
+					    HANDLE hProcess);
+
+/*
+ *  ======== CHNL_Create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given board.
+ *  Parameters:
+ *      phChnlMgr:      Location to store a channel manager object on output.
+ *      hDevObject:     Handle to a device object.
+ *      pMgrAttrs:      Channel manager attributes.
+ *      pMgrAttrs->cChannels:   Max channels
+ *      pMgrAttrs->bIRQ:        Channel's I/O IRQ number.
+ *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EHANDLE:            hDevObject is invalid.
+ *      DSP_EINVALIDARG:        cChannels is 0.
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
+ *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
+ *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
+ *      CHNL_E_MGREXISTS:       Channel manager already exists for this device.
+ *  Requires:
+ *      CHNL_Init() called.
+ *      phChnlMgr != NULL.
+ *      pMgrAttrs != NULL.
+ *  Ensures:
+ *      DSP_SOK:                Subsequent calls to CHNL_Create() for the same
+ *                              board without an intervening call to
+ *                              CHNL_Destroy() will fail.
+ */
+	extern DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct CHNL_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ *  Parameters:
+ *      hChnlMgr:           Channel manager object.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        hChnlMgr was invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      DSP_SOK:            Cancels I/O on each open channel.
+ *                          Closes each open channel.
+ *                          CHNL_Create may subsequently be called for the
+ *                          same board.
+ */
+	extern DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+
+/*
+ *  ======== CHNL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CHNL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CHNL_Init() previously called.
+ *  Ensures:
+ *      Resources, if any acquired in CHNL_Init(), are freed when the last
+ *      client of CHNL calls CHNL_Exit().
+ */
+	extern void CHNL_Exit();
+
+/*
+ *  ======== CHNL_FlushIO ========
+ *  Purpose:
+ *      For an output stream (to the DSP), flush all pending IO requests to the
+ *      output device.  This function will wait for IO completion for each of
+ *      the queued IO requests, up to the specified timeout (per IOR).   For
+ *      input streams (from the DSP), will cancel all pending IO requests.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      Timeout in milliseconds to wait for I/O completion.
+ *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
+ *                      The value of CHNL_IOCNOWAIT is not allowed.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EINVALIDARG:    dwTimeOut value of CHNL_IOCNOWAIT was given.
+ *      CHNL_E_WAITTIMEOUT: Wait for flush of output stream timed out.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      DSP_SOK:        No I/O requests will be pending on this channel.
+ */
+	extern DSP_STATUS CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
+					u32 dwTimeOut);
+
+/*
+ *  ======== CHNL_FreeBuffer ========
+ *  Purpose:
+ *      Free a buffer previously allocated using CHNL_AllocBuffer().
+ *  Parameters:
+ *      hChnlMgr:       Handle to a valid channel manager.
+ *      cBytes:         Size of buffer in bytes.
+ *      pBuf:           Buffer pointer returned by CHNL_FreeBuffer().
+ *  Returns:
+ *      DSP_SOK:           Success.
+ *      DSP_EHANDLE:       hChnlMgr is invalid.
+ *      DSP_EINVALIDARG:   pBuf is NULL.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_FreeBuffer(struct CHNL_MGR *hChnlMgr,
+					  u32 cBytes,
+					  void *pBuf);
+
+/*
+ *  ======== CHNL_GetEventHandle ========
+ *  Purpose:
+ *      Retrieve this channel's I/O completion auto-reset event.
+ *  Parameters:
+ *      hChnl:          Handle to a valid channel object.
+ *      phEvent:        Location to store the I/O completion event object.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   phEvent is invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+
+ */
+	extern DSP_STATUS CHNL_GetEventHandle(struct CHNL_OBJECT *hChnl,
+					      OUT HANDLE *phEvent);
+
+/*
+ *  ======== CHNL_GetHandle ========
+ *  Purpose:
+ *      Retrieve the channel handle given the logical ID and channel manager.
+ *  Parameters:
+ *      hChnlMgr:           Handle to a valid channel manager, or NULL.
+ *      uChnlID:            Channel ID.
+ *      phChnl:             Location to store channel handle.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnlMgr.
+ *      DSP_EPOINTER:       phChnl == NULL.
+ *      CHNL_E_BADCHANID:   Invalid channel ID.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      DSP_SOK:            *phChnl points to a valid channel object,
+ *                          if phChnl != NULL.
+ */
+	extern DSP_STATUS CHNL_GetHandle(struct CHNL_MGR *hChnlMgr,
+					 u32 uChnlID,
+					 OUT struct CHNL_OBJECT **phChnl);
+
+/*
+ *  ======== CHNL_GetIOCompletion ========
+ *  Purpose:
+ *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
+ *      completion record, which contains information about the completed
+ *      I/O request.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      Timeout in milliseconds to wait for completion.
+ *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
+ *                      A value of CHNL_IOCNOWAIT will simply dequeue the
+ *                      first available IOC.
+ *      pIOC:           On output, contains host buffer address, bytes
+ *                      transferred, and status of I/O completion.
+ *      pIOC->status:   I/O Completion status: see chnldefs.h for definitions.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pIOC is invalid.
+ *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
+ *                      yet no I/O completions were queued.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ *      DSP_SOK:        If there are any remaining IOC's queued before this
+ *                      call returns, the channel event object will be left
+ *                      in a signalled state.
+ *      If the return status is anything other than DSP_EPOINTER or DSP_SOK,
+ *      then pIOC->pBuf will be set to NULL, pIOC->cBytes will be 0, and
+ *      pIOC->status will be undefined.
+ */
+	extern DSP_STATUS CHNL_GetIOCompletion(struct CHNL_OBJECT *hChnl,
+					       u32 dwTimeOut,
+					       OUT struct CHNL_IOC *pIOC);
+
+/*
+ *  ======== CHNL_GetId ========
+ *  Purpose:
+ *      Retrieve the channel logical ID of this channel.
+ *  Parameters:
+ *      hChnl:          Handle to a valid channel object.
+ *      pdwID:          Location to store logical ID.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pdwID is invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_GetId(struct CHNL_OBJECT *hChnl,
+				     OUT u32 *pdwID);
+
+/*
+ *  ======== CHNL_GetMgr ========
+ *  Purpose:
+ *      Retrieve a channel manager handle, required for opening new channels
+ *      and closing old ones on a given board.
+ *  Parameters:
+ *      hDevNode:       A valid system specific DEVNODE handle.
+ *      phChnlMgr:      Location to store the channel manager handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hDevNode is invalid.
+ *      CHNL_E_NOMGR:   No channel manager exists for this board.
+ *  Requires:
+ *      CHNL_Init() called.
+ *      phChnlMgr != NULL.
+ *  Ensures:
+ *      DSP_SOK: The DSP board represented by hDevNode was in the RUNNING state
+ *            before this function returned.
+ *      else: *phChnlMgr == NULL.
+ */
+	extern DSP_STATUS CHNL_GetMgr(struct CFG_DEVNODE *hDevNode,
+				      OUT struct CHNL_MGR **phChnlMgr);
+
+/*
+ *  ======== CHNL_GetMode ========
+ *  Purpose:
+ *      Retrieve the mode flags of this channel.
+ *  Parameters:
+ *      hChnl:              Handle to a valid channel object.
+ *      pMode:              Location to store mode flags.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EPOINTER:       pMode is invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_GetMode(struct CHNL_OBJECT *hChnl,
+				       OUT CHNL_MODE * pMode);
+
+/*
+ *  ======== CHNL_GetPosition ========
+ *  Purpose:
+ *      Retrieve the total number of bytes transferred on this channel.
+ *  Parameters:
+ *      hChnl:              Handle to a valid channel object.
+ *      pcPosition:         Location to store number of bytes.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EPOINTER:       pcPosition is invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_GetPosition(struct CHNL_OBJECT *hChnl,
+					   OUT u32 *pcPosition);
+
+/*
+ *  ======== CHNL_GetProcessHandle ========
+ *  Purpose:
+ *      Retrieve the handle of the process owning this channel.
+ *  Parameters:
+ *      hChnl:              Channel handle.
+ *      phProcess:          Location to store the process handle.  A NULL value
+ *                          indicates the channel is either closed or is not
+ *                          owned by any particular process.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EPOINTER:       phProcess is invalid.
+ *  Requires:
+ *      CHNL_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS CHNL_GetProcessHandle(struct CHNL_OBJECT *hChnl,
+						OUT HANDLE *phProcess);
+
+/*
+ *  ======== CHNL_Init ========
+ *  Purpose:
+ *      Initialize the CHNL module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occurred.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CHNL functions.
+ */
+	extern bool CHNL_Init();
+
+/*
+ *  ======== CHNL_Open ========
+ *  Purpose:
+ *      Open a new half-duplex channel to the DSP board.
+ *  Parameters:
+ *      phChnl:         Location to store a channel object handle.
+ *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
+ *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *                      direction of data transfer.
+ *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
+ *                      select a free channel id (default);
+ *                      otherwise this field specifies the id of the channel.
+ *      pAttrs:         Channel attributes.  Attribute fields are as follows:
+ *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
+ *                       be pending at any given time. All request packets are
+ *                       preallocated when the channel is opened.
+ *      pAttrs->hEvent: This field allows the user to supply an auto reset
+ *                      event object for channel I/O completion notifications.
+ *                      It is the responsibility of the user to destroy this
+ *                      object AFTER closing the channel.
+ *                      This channel event object can be retrieved using
+ *                      CHNL_GetEventHandle().
+ *      pAttrs->hReserved: The kernel mode handle of this event object.
+ *
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            hChnlMgr is invalid.
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      DSP_EINVALIDARG:        Invalid number of IOReqs.
+ *      CHNL_E_BADMODE:         Invalid mode argument.
+ *      CHNL_E_OUTOFSTREAMS:    No free channels available.
+ *      CHNL_E_BADCHANID:       Channel ID is out of range.
+ *      CHNL_E_CHANBUSY:        Channel is in use.
+ *  Requires:
+ *      CHNL_Init() called.
+ *      phChnl != NULL.
+ *      pAttrs != NULL.
+ *      pAttrs->hEvent is a valid event handle.
+ *  Ensures:
+ *      DSP_SOK:        *phChnl is a valid channel.
+ *      else:           *phChnl is set to NULL if (phChnl != NULL);
+ */
+	extern DSP_STATUS CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
+				    struct CHNL_MGR *hChnlMgr, CHNL_MODE uMode,
+				    u32 uChnlId,
+				    CONST IN struct CHNL_ATTRS *pAttrs);
+
+#endif				/* CHNL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
@@ -0,0 +1,136 @@
+/*
+ * arch/arm/plat-omap/include/bridge/chnlpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== chnlpriv.h ========
+ *  Description:
+ *      Private channel header shared between DSPSYS, WCD and WMD modules.
+ *
+ *  Public Functions:
+ *      None.
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 05-Jan-2002 ag  Added cChannels(total # of chnls) to CHNL_MGRINFO struct.
+ *!                 Added private CHNL_[PCPY][ZCPY][DDMA].
+ *! 17-Nov-2000 jeh Removed IRQ, shared memory from CHNL_MGRATTRS, since these
+ *!                 now belong to IO_ATTRS.
+ *! 21-Jan-2000 ag: Code review comments added.
+ *! 05-Jan-2000 ag: Text format cleanup.
+ *! 11-Dec-1999 ag: Added CHNL_MAXLOCKPAGES for CHNL_PrepareBuffer().
+ *! 04-Dec-1999 ag: Added CHNL_MAXEVTNAMELEN for i/o compl named event support.
+ *! 01-Nov-1999 ag: CHNL_MAXCHANNELS set to 16 for 16-bit DSPs.
+ *! 27-Oct-1997 cr: Expanded CHNL_MAXIRQ from 0x0f to 0xff.
+ *! 16-Jan-1997 gp: Moved symbols into here from chnldefs.h.
+ *! 03-Jan-1997 gp: Added CHNL_MAXIRQ define.
+ *! 09-Dec-1996 gp: Removed CHNL_STATEIDLE.
+ *! 15-Jul-1996 gp: Created.
+ */
+
+#ifndef CHNLPRIV_
+#define CHNLPRIV_
+
+#include <chnldefs.h>
+#include <devdefs.h>
+#include <sync.h>
+
+/* CHNL Object validation signatures: */
+#define CHNL_MGRSIGNATURE   0x52474D43	/* "CMGR" (in reverse). */
+#define CHNL_SIGNATURE      0x4C4E4843	/* "CHNL" (in reverse). */
+
+/* Channel manager limits: */
+#define CHNL_MAXCHANNELS    32	/* Max channels available per transport */
+
+
+/*
+ *  Trans port channel Id definitions:(must match dsp-side).
+ *
+ *  For CHNL_MAXCHANNELS = 16:
+ *
+ *  ChnlIds:
+ *      0-15  (PCPY) - transport 0)
+ *      16-31 (DDMA) - transport 1)
+ *      32-47 (ZCPY) - transport 2)
+ */
+#define CHNL_PCPY       0	/* Proc-copy transport 0 */
+
+#define CHNL_MAXIRQ     0xff	/* Arbitrarily large number. */
+
+/* The following modes are private: */
+#define CHNL_MODEUSEREVENT  0x1000	/* User provided the channel event. */
+#define CHNL_MODEMASK       0x1001
+
+/* Higher level channel states: */
+#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O.    */
+#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled.        */
+#define CHNL_STATEEOS       0x0002	/* End Of Stream reached.    */
+
+/* Determine if user supplied an event for this channel:  */
+#define CHNL_IsUserEvent(mode)  (mode & CHNL_MODEUSEREVENT)
+
+/* Macros for checking mode: */
+#define CHNL_IsInput(mode)      (mode & CHNL_MODEFROMDSP)
+#define CHNL_IsOutput(mode)     (!CHNL_IsInput(mode))
+
+/* Types of channel class libraries: */
+#define CHNL_TYPESM         1	/* Shared memory driver. */
+#define CHNL_TYPEBM         2	/* Bus Mastering driver. */
+
+/* Max string length of channel I/O completion event name - change if needed */
+#define CHNL_MAXEVTNAMELEN  32
+
+/* Max memory pages lockable in CHNL_PrepareBuffer() - change if needed */
+#define CHNL_MAXLOCKPAGES   64
+
+/* Channel info.  */
+	 struct CHNL_INFO {
+		struct CHNL_MGR *hChnlMgr;	/* Owning channel manager.   */
+		u32 dwID;	/* Channel ID.                            */
+		HANDLE hEvent;	/* Channel I/O completion event.          */
+		/*Abstraction of I/O completion event.*/
+		struct SYNC_OBJECT *hSyncEvent;
+		u32 dwMode;	/* Channel mode.                          */
+		u32 dwState;	/* Current channel state.                 */
+		u32 cPosition;	/* Total bytes transferred.        */
+		u32 cIOCs;	/* Number of IOCs in queue.               */
+		u32 cIOReqs;	/* Number of IO Requests in queue.        */
+		HANDLE hProcess;	/* Process owning this channel.     */
+		/*
+		 * Name of channel I/O completion event. Not required in Linux
+		 */
+		char szEventName[CHNL_MAXEVTNAMELEN + 1];
+	} ;
+
+/* Channel manager info: */
+	struct CHNL_MGRINFO {
+		u32 dwType;	/* Type of channel class library.         */
+		/* Channel handle, given the channel id. */
+		struct CHNL_OBJECT *hChnl;
+		u32 cOpenChannels;	/* Number of open channels.     */
+		u32 cChannels;	/* total # of chnls supported */
+	} ;
+
+/* Channel Manager Attrs: */
+	struct CHNL_MGRATTRS {
+		/* Max number of channels this manager can use. */
+		u32 cChannels;
+		u32 uWordSize;	/* DSP Word size.                       */
+	} ;
+
+#endif				/* CHNLPRIV_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
@@ -0,0 +1,218 @@
+/*
+ * arch/arm/plat-omap/include/bridge/_chnl_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== _chnl_sm.h ========
+ *  Description:
+ *      Private header file defining channel manager and channel objects for
+ *      a shared memory channel driver.
+ *
+ *  Public Functions:
+ *      None.
+ *
+ *  Notes:
+ *      Shared between the modules implementing the shared memory channel class
+ *      library.
+ *
+ *! Revision History:
+ *! ================
+ *! 15-Oct-2002 kc  Removed legacy PERF code.
+ *! 12-Jan-2002 ag  Removed unused gppReqIO & ddmaChnlId DDMA fields.
+ *!                 Added zero-copy chnl descriptor array: zchnldesc.
+ *! 21-Dec-2001 ag  Moved descPaGpp to private chnl obj from chnl descriptor.
+ *! 20-May-2001 ag/jeh Removed fShmSyms field from CHNL_MGR.
+ *! 04-Feb-2001 ag  DSP-DMA support added.
+ *! 26-Oct-2000 jeh Added arg and resvd to SHM control structure. Added dwArg
+ *!                 to CHNL_IRP.
+ *! 16-Oct-2000 jeh Removed #ifdef DEBUG from around channel object's cIOCs
+ *!                 field, added cIOReqs.
+ *! 20-Jan-2000 ag: Incorporated code review comments.
+ *! 05-Jan-2000 ag: Text format cleanup.
+ *! 03-Nov-1999 ag: Added szEventName[] to CHNL object for name event support.
+ *! 02-Nov-1999 ag: _SHM_BEG & _END Syms from COFF now used for IO and SM CLASS.
+ *! 27-Oct-1999 jeh Define SHM structure to work for 16-bit targets.
+ *! 25-May-1999 jg: Added target side symbol names for share memory buffer
+ *! 03-Jan-1997 gp: Added fSharedIRQ field.
+ *! 22-Oct-1996 gp: Made dwProcessID a handle.
+ *! 09-Sep-1996 gp: Added dwProcessID field to CHNL_OBJECT.
+ *! 13-Aug-1996 gp: Created.
+ */
+
+#ifndef _CHNL_SM_
+#define _CHNL_SM_
+
+#include <wcd.h>
+#include <wmd.h>
+#include <dpc.h>
+
+#include <list.h>
+#include <ntfy.h>
+
+/*
+ *  These target side symbols define the beginning and ending addresses
+ *  of shared memory buffer. They are defined in the *cfg.cmd file by
+ *  cdb code.
+ */
+#define CHNL_SHARED_BUFFER_BASE_SYM "_SHM_BEG"
+#define CHNL_SHARED_BUFFER_LIMIT_SYM "_SHM_END"
+#define BRIDGEINIT_BIOSGPTIMER "_BRIDGEINIT_BIOSGPTIMER"
+#define BRIDGEINIT_LOADMON_GPTIMER "_BRIDGEINIT_LOADMON_GPTIMER"
+
+#ifndef _CHNL_WORDSIZE
+#define _CHNL_WORDSIZE 4	/* default _CHNL_WORDSIZE is 2 bytes/word */
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3430
+
+#define MAXOPPS 16
+
+struct oppTableEntry {
+    u32 voltage;
+    u32 frequency;
+    u32 minFreq;
+    u32 maxFreq;
+} ;
+
+struct oppStruct {
+    u32 currOppPt;
+    u32 numOppPts;
+    struct oppTableEntry oppPoint[MAXOPPS];
+} ;
+
+/* Request to MPU */
+struct oppRqstStruct {
+    u32 rqstDspFreq;
+    u32 rqstOppPt;
+};
+
+/* Info to MPU */
+struct loadMonStruct {
+    u32 currDspLoad;
+    u32 currDspFreq;
+    u32 predDspLoad;
+    u32 predDspFreq;
+};
+
+#endif
+
+	enum SHM_DESCTYPE {
+		SHM_CURROPP = 0,
+		SHM_OPPINFO = 1,
+		SHM_GETOPP = 2,		/* Get DSP requested OPP info */
+	} ;
+
+/* Structure in shared between DSP and PC for communication.*/
+	struct SHM {
+		u32 dspFreeMask;	/* Written by DSP, read by PC. */
+		u32 hostFreeMask;	/* Written by PC, read by DSP */
+
+		u32 inputFull;	/* Input channel has unread data. */
+		u32 inputId;	/* Channel for which input is available. */
+		u32 inputSize;	/* Size of data block (in DSP words). */
+
+		u32 outputFull;	/* Output channel has unread data. */
+		u32 outputId;	/* Channel for which output is available. */
+		u32 outputSize;	/* Size of data block (in DSP words). */
+
+		u32 arg;	/* Arg for Issue/Reclaim (23 bits for 55x). */
+		u32 resvd;	/* Keep structure size even for 32-bit DSPs */
+
+#ifdef CONFIG_ARCH_OMAP3430
+		/* Operating Point structure */
+		struct oppStruct  oppTableStruct;
+		/* Operating Point Request structure */
+		struct oppRqstStruct oppRequest;
+		/* load monitor information structure*/
+		struct loadMonStruct loadMonInfo;
+		char dummy[184];             /* padding to 256 byte boundary */
+		u32 shm_dbg_var[64];         /* shared memory debug variables */
+#endif
+	} ;
+
+	/* Channel Manager: only one created per board: */
+	struct CHNL_MGR {
+		u32 dwSignature;	/* Used for object validation */
+		/* Function interface to WMD */
+		struct WMD_DRV_INTERFACE *pIntfFxns;
+		struct IO_MGR *hIOMgr;	/* IO manager */
+		/* Device this board represents */
+		struct DEV_OBJECT *hDevObject;
+
+		/* These fields initialized in WMD_CHNL_Create():    */
+		u32 dwOutputMask; /* Host output channels w/ full buffers */
+		u32 dwLastOutput;	/* Last output channel fired from DPC */
+		/* Critical section object handle */
+		struct SYNC_CSOBJECT *hCSObj;
+		u32 uWordSize;	/* Size in bytes of DSP word */
+		u32 cChannels;	/* Total number of channels */
+		u32 cOpenChannels;	/* Total number of open channels */
+		struct CHNL_OBJECT **apChannel;	/* Array of channels */
+		u32 dwType;	/* Type of channel class library */
+		/* If no SHM syms, return for CHNL_Open */
+		DSP_STATUS chnlOpenStatus;
+	} ;
+
+/*
+ *  Channel: up to CHNL_MAXCHANNELS per board or if DSP-DMA supported then
+ *     up to CHNL_MAXCHANNELS + CHNL_MAXDDMACHNLS per board.
+ */
+	struct CHNL_OBJECT {
+		u32 dwSignature;	/* Used for object validation */
+		/* Pointer back to channel manager */
+		struct CHNL_MGR *pChnlMgr;
+		u32 uId;	/* Channel id */
+		u32 dwState;	/* Current channel state */
+		u32 uMode;	/* Chnl mode and attributes */
+		/* Chnl I/O completion event (user mode) */
+		HANDLE hUserEvent;
+		/* Abstract syncronization object */
+		struct SYNC_OBJECT *hSyncEvent;
+		/* Name of Sync event */
+		char szEventName[SYNC_MAXNAMELENGTH + 1];
+               u32 hProcess;   /* Process which created this channel */
+		u32 pCBArg;	/* Argument to use with callback */
+		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
+		s32 cIOCs;	/* Number of IOC's in queue */
+		s32 cIOReqs;	/* Number of IORequests in queue */
+		s32 cChirps;	/* Initial number of free Irps */
+		/* List of IOC's from driver */
+		struct LST_LIST *pIOCompletions;
+		struct LST_LIST *pFreeList;	/* List of free Irps */
+		struct NTFY_OBJECT *hNtfy;
+		u32 cBytesMoved;	/* Total number of bytes transfered */
+
+		/* For DSP-DMA */
+
+		/* Type of chnl transport:CHNL_[PCPY][DDMA] */
+		u32 uChnlType;
+	} ;
+
+/* I/O Request/completion packet: */
+	struct CHNL_IRP {
+		struct LST_ELEM link;	/* Link to next CHIRP in queue. */
+		/* Buffer to be filled/emptied. (User)   */
+		u8 *pHostUserBuf;
+		/* Buffer to be filled/emptied. (System) */
+		u8 *pHostSysBuf;
+		u32 dwArg;	/* Issue/Reclaim argument.               */
+		u32 uDspAddr;	/* Transfer address on DSP side.         */
+		u32 cBytes;	/* Bytes transferred.                    */
+		u32 cBufSize;	/* Actual buffer size when allocated.    */
+		u32 status;	/* Status of IO completion.              */
+	} ;
+
+#endif				/* _CHNL_SM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
@@ -0,0 +1,210 @@
+/*
+ * dspbridge/inc/chnl_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== chnl_sm.h ========
+ *  Description:
+ *      Prototypes for channel lower edge functions for a WinBRIDGE mini driver
+ *      implementing data transfer via shared memory.
+ *
+ *  Public Functions:
+ *      CHNLSM_DisableInterrupt;
+ *      CHNLSM_DPC;
+ *      CHNLSM_EnableInterrupt;
+ *      CHNLSM_InterruptDSP;
+ *      CHNLSM_ISR;
+ *      CHNLSM_Read;
+ *      CHNLSM_UpdateSHMLength;
+ *      CHNLSM_Write;
+ *
+ *  Notes:
+ *      These lower edge functions must be implemented by the WMD writer.
+ *      Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
+ *      be defined to link.
+ *
+ *! Revision History:
+ *! ================
+ *! 06-Jan-2002 ag: Added CHNLSM_InterruptDSP2 to set Mailbox value.
+ *! 05-Nov-2001 kc: Updated CHNLSM_ISR to read value returned by interrupt.
+ *! 21-Jan-2000 ag: Updated comments per code review.
+ *! 18-Dec-1997 gp: Added CDECL.
+ *! 16-Jun-1997 gp: Added function UpdateSHMLength().
+ *! 13-Nov-1996 gp: Renamed CHNL_ to CHNLSM_.
+ *! 10-Jul-1996 gp: Created.
+ */
+
+#ifndef CHNLSM_
+#define CHNLSM_
+
+#include <wmd.h>
+
+/*
+ *  ======== CHNLSM_DisableInterrupt ========
+ *  Purpose:
+ *      Disable interrupts from the DSP board to the PC.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT*
+							hDevContext);
+
+/*
+ *  ======== CHNLSM_DPC ========
+ *  Purpose:
+ *      This mini-driver's deferred processing routine.  Finishes processing
+ *      deferred by the WMD's ISR.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *  Requires:
+ *      Must not block.
+ *      Must not acquire resources.
+ *      All data objects touched must be locked in memory.
+ *  Ensures:
+ */
+       extern void CHNLSM_DPC(struct WMD_DEV_CONTEXT *hDevContext);
+
+/*
+ *  ======== CHNLSM_EnableInterrupt ========
+ *  Purpose:
+ *      Enable interrupts from the DSP board to the PC.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT*
+						       hDevContext);
+
+/*
+ *  ======== CHNLSM_InterruptDSP ========
+ *  Purpose:
+ *      Send an interrupt to the DSP processor(s).
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *      DSP_SOK:        Interrupt sent;
+ *      else:           Unable to send interrupt.
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_InterruptDSP(struct WMD_DEV_CONTEXT*
+						    hDevContext);
+
+/*
+ *  ======== CHNLSM_InterruptDSP2 ========
+ *  Purpose:
+ *      Set interrupt value & send an interrupt to the DSP processor(s).
+ *      This is typicaly used when mailbox interrupt mechanisms allow data
+ *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      wMbVal:         Value associated with interrupt(e.g. mailbox value).
+ *  Returns:
+ *      DSP_SOK:        Interrupt sent;
+ *      else:           Unable to send interrupt.
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT*
+						     hDevContext, u16 wMbVal);
+
+/*
+ *  ======== CHNLSM_ISR ========
+ *  Purpose:
+ *      Mini-driver's ISR, called by WCD when the board interrupts the host.
+ *  Parameters:
+ *      hDevContext:    Handle to the mini-driver defined device info.
+ *      pfSchedDPC:     Set to TRUE to schedule a deferred procedure call
+ *                      to advance the channel protocol.  The channel class
+ *                      library will call the WMD's CHNLSM_DPC routine during
+ *                      its own DPC, before dispatching I/O.
+ *                      The channel class library should ignore *pfSchedDPC when
+ *                      CHNLSM_ISR returns FALSE.
+ *      pwMBRegVal:     Value of mailbox register.
+ *  Returns:
+ *      TRUE if this interrupt is was generated by the DSP board.
+ *      FALSE otherwise.
+ *  Requires:
+ *      Interrupts to the host processor are disabled on entry.
+ *      Must only call functions which are in page locked memory.
+ *      Must only call asynchronous OS services.
+ *      The EOI for this interrupt has already been sent to the PIC.
+ *  Ensures:
+ *      If the interrupt is *not* shared, this routine must return TRUE.
+ */
+       extern bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *hDevContext,
+				     OUT bool *pfSchedDPC,
+				     OUT u16 *pwIntrVal);
+
+/*
+ *  ======== CHNLSM_Read ========
+ *  Purpose:
+ *      Read data from DSP board memory into a Host buffer.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Destination).
+ *      dwDSPAddr:      Address on DSP board (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_Read(struct WMD_DEV_CONTEXT *hDevContext,
+					    OUT u8 *pHostBuf,
+					    u32 dwDSPAddr, u32 ulNumBytes);
+
+/*
+ *  ======== CHNLSM_UpdateSHMLength ========
+ *  Purpose:
+ *      Allow the minidriver a chance to override the SHM length as reported
+ *      to the mini driver (chnl_sm.lib) by Windows Plug and Play.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pSHMLength:     Pointer to size of SHM window (in DSP words).
+ *  Returns:
+ *      TRUE if pSHMLength updated; FALSE otherwise.
+ *  Requires:
+ *      pSHMLength != NULL.
+ *  Ensures:
+ *      No more than sizeof(u32) bytes written to *pSHMLength
+ */
+	extern bool CHNLSM_UpdateSHMLength(struct WMD_DEV_CONTEXT *hDevContext,
+					   IN OUT u32 *pSHMLength);
+
+/*
+ *  ======== CHNLSM_Write ========
+ *  Purpose:
+ *      Write data from a Host buffer to DSP board memory.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_Write(struct WMD_DEV_CONTEXT *hDevContext,
+					    IN u8 *pHostBuf,
+					    u32 dwDSPAddr, u32 ulNumBytes);
+
+#endif				/* CHNLSM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/clk.h
@@ -0,0 +1,155 @@
+/*
+ * arch/arm/plat-omap/include/bridge/clk.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== clk.h ========
+ *  Purpose: Provides Clock functions.
+ *
+ *! Revision History:
+ *! ================
+ *! 08-May-2007 rg: Moved all clock functions from sync module.
+ */
+
+#ifndef _CLK_H
+#define _CLK_H
+
+	/* Generic TIMER object: */
+	struct TIMER_OBJECT;
+	enum SERVICES_ClkId {
+		SERVICESCLK_iva2_ck = 0,
+		SERVICESCLK_mailbox_ick,
+		SERVICESCLK_gpt5_fck,
+		SERVICESCLK_gpt5_ick,
+		SERVICESCLK_gpt6_fck,
+		SERVICESCLK_gpt6_ick,
+		SERVICESCLK_gpt7_fck,
+		SERVICESCLK_gpt7_ick,
+		SERVICESCLK_gpt8_fck,
+		SERVICESCLK_gpt8_ick,
+		SERVICESCLK_wdt3_fck,
+		SERVICESCLK_wdt3_ick,
+		SERVICESCLK_mcbsp1_fck,
+		SERVICESCLK_mcbsp1_ick,
+		SERVICESCLK_mcbsp2_fck,
+		SERVICESCLK_mcbsp2_ick,
+		SERVICESCLK_mcbsp3_fck,
+		SERVICESCLK_mcbsp3_ick,
+		SERVICESCLK_mcbsp4_fck,
+		SERVICESCLK_mcbsp4_ick,
+		SERVICESCLK_mcbsp5_fck,
+		SERVICESCLK_mcbsp5_ick,
+		SERVICESCLK_ssi_fck,
+		SERVICESCLK_ssi_ick,
+		SERVICESCLK_sys_32k_ck,
+		SERVICESCLK_sys_ck,
+		SERVICESCLK_NOT_DEFINED
+	} ;
+
+/*
+ *  ======== CLK_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CLK initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void CLK_Exit();
+
+/*
+ *  ======== CLK_Init ========
+ *  Purpose:
+ *      Initializes private state of CLK module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      CLK initialized.
+ */
+	extern bool CLK_Init();
+
+
+/*
+ *  ======== CLK_Enable ========
+ *  Purpose:
+ *      Enables the clock requested.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:	Success.
+ *	DSP_EFAIL:	Error occured while enabling the clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id);
+
+/*
+ *  ======== CLK_Disable ========
+ *  Purpose:
+ *      Disables the clock requested.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while disabling the clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id);
+
+/*
+ *  ======== CLK_GetRate ========
+ *  Purpose:
+ *      Get the clock rate of requested clock.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while Getting the clock rate.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id,
+				     u32 *speedMhz);
+/*
+ *  ======== CLK_Set_32KHz ========
+ *  Purpose:
+ *      Set the requested clock to 32KHz.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while setting the clock parent to 32KHz.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id);
+	extern void SSI_Clk_Prepare(bool FLAG);
+
+/*
+ *  ======== CLK_Get_RefCnt ========
+ *  Purpose:
+ *      get the reference count for the clock.
+ *  Parameters:
+ *  Returns:
+ *      s32:        Reference Count for the clock.
+ *      DSP_EFAIL:  Error occured while getting the reference count of a clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id);
+
+#endif				/* _SYNC_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
@@ -0,0 +1,135 @@
+/*
+ * arch/arm/plat-omap/include/bridge/cmmdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== cmmdefs.h ========
+ *  Purpose:
+ *      Global MEM constants and types.
+ *
+ *! Revision History:
+ *! ================
+ *! 12-Nov-2001 ag  CMM_KERNMAPTYPE added for dsp<->device process addr map'n.
+ *!                 This allows addr conversion from drvr process <-> DSP addr.
+ *! 29-Aug-2001 ag  Added CMM_ALLSEGMENTS.
+ *! 08-Dec-2000 ag  Added bus address conversion type CMM_POMAPEMIF2DSPBUS.
+ *! 05-Dec-2000 ag  Added default CMM_DEFLTCONVFACTOR & CMM_DEFLTDSPADDROFFSET.
+ *! 29-Oct-2000 ag  Added converstion factor for GPP DSP Pa translation.
+ *! 15-Oct-2000 ag  Added address translator attributes and defaults.
+ *! 12-Jul-2000 ag  Created.
+ */
+
+#ifndef CMMDEFS_
+#define CMMDEFS_
+
+#include <list.h>
+
+/* Cmm attributes used in CMM_Create() */
+	struct CMM_MGRATTRS {
+		/* Minimum SM allocation; default 32 bytes.  */
+		u32 ulMinBlockSize;
+	} ;
+
+/* Attributes for CMM_AllocBuf() & CMM_AllocDesc() */
+	struct CMM_ATTRS {
+		u32 ulSegId;	/*  1,2... are SM segments. 0 is not. */
+		u32 ulAlignment;	/*  0,1,2,4....ulMinBlockSize */
+	} ;
+
+/*
+ *  DSPPa to GPPPa Conversion Factor.
+ *
+ *  For typical platforms:
+ *      converted Address = PaDSP + ( cFactor * addressToConvert).
+ */
+	enum CMM_CNVTTYPE {
+		CMM_SUBFROMDSPPA = -1,
+		/* PreOMAP is special case: not simple offset */
+		CMM_POMAPEMIF2DSPBUS = 0,
+		CMM_ADDTODSPPA = 1
+	} ;
+
+#define CMM_DEFLTDSPADDROFFSET  0
+#define CMM_DEFLTCONVFACTOR     CMM_POMAPEMIF2DSPBUS /* PreOMAP DSPBUS<->EMIF */
+#define CMM_ALLSEGMENTS         0xFFFFFF	/* All SegIds */
+#define CMM_MAXGPPSEGS          1	/* Maximum # of SM segs */
+
+/*
+ *  SMSEGs are SM segments the DSP allocates from.
+ *
+ *  This info is used by the GPP to xlate DSP allocated PAs.
+ */
+
+	struct CMM_SEGINFO {
+		u32 dwSegBasePa;	/* Start Phys address of SM segment */
+		/* Total size in bytes of segment: DSP+GPP */
+		u32 ulTotalSegSize;
+		u32 dwGPPBasePA;	/* Start Phys addr of Gpp SM seg */
+		u32 ulGPPSize;	/* Size of Gpp SM seg in bytes */
+		u32 dwDSPBaseVA;	/* DSP virt base byte address */
+		u32 ulDSPSize;	/* DSP seg size in bytes */
+		/* # of current GPP allocations from this segment */
+		u32 ulInUseCnt;
+		u32 dwSegBaseVa;	/* Start Virt address of SM seg */
+
+	} ;
+
+/* CMM useful information */
+	struct CMM_INFO {
+		/* # of SM segments registered with this Cmm. */
+		u32 ulNumGPPSMSegs;
+		/* Total # of allocations outstanding for CMM */
+		u32 ulTotalInUseCnt;
+		/* Min SM block size allocation from CMM_Create() */
+		u32 ulMinBlockSize;
+		/* Info per registered SM segment. */
+		struct CMM_SEGINFO segInfo[CMM_MAXGPPSEGS];
+	} ;
+
+/* XlatorCreate attributes */
+	struct CMM_XLATORATTRS {
+		u32 ulSegId;	/* segment Id used for SM allocations */
+		u32 dwDSPBufs;	/* # of DSP-side bufs */
+		u32 dwDSPBufSize;	/* size of DSP-side bufs in GPP bytes */
+		/* Vm base address alloc'd in client process context */
+		void *pVmBase;
+		/* dwVmSize must be >= (dwMaxNumBufs * dwMaxSize) */
+		u32 dwVmSize;
+	} ;
+
+/*
+ * Cmm translation types. Use to map SM addresses to process context.
+ */
+	enum CMM_XLATETYPE {
+		CMM_VA2PA = 0,	/* Virtual to GPP physical address xlation */
+		CMM_PA2VA = 1,	/* GPP Physical to virtual  */
+		CMM_VA2DSPPA = 2,	/* Va to DSP Pa  */
+		CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
+		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
+	} ;
+
+/*
+ *  Used to "map" between device process virt addr and dsp addr.
+ */
+	enum CMM_KERNMAPTYPE {
+		CMM_KERNVA2DSP = 0, /* Device process context to dsp address. */
+		CMM_DSP2KERNVA = 1, /* Dsp address to device process context. */
+	} ;
+
+	struct CMM_OBJECT;
+	struct CMM_XLATOROBJECT;
+
+#endif				/* CMMDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cmm.h
@@ -0,0 +1,420 @@
+/*
+ * arch/arm/plat-omap/include/bridge/cmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== cmm.h ========
+ *  Purpose:
+ *      The Communication Memory Management(CMM) module provides shared memory
+ *      management services for DSP/BIOS Bridge data streaming and messaging.
+ *      Multiple shared memory segments can be registered with CMM. Memory is
+ *      coelesced back to the appropriate pool when a buffer is freed.
+ *
+ *      The CMM_Xlator[xxx] functions are used for node messaging and data
+ *      streaming address translation to perform zero-copy inter-processor
+ *      data transfer(GPP<->DSP). A "translator" object is created for a node or
+ *      stream object that contains per thread virtual address information. This
+ *      translator info is used at runtime to perform SM address translation
+ *      to/from the DSP address space.
+ *
+ *
+ *  Public Functions:
+ *      CMM_CallocBuf
+ *      CMM_Create
+ *      CMM_Destroy
+ *      CMM_Exit
+ *      CMM_FreeBuf
+ *      CMM_GetHandle
+ *      CMM_GetInfo
+ *      CMM_Init
+ *      CMM_RegisterGPPSMSeg
+ *      CMM_UnRegisterGPPSMSeg
+ *      CMM_XlatorAllocBuf       (Note #1 below)
+ *      CMM_XlatorCreate           "
+ *      CMM_XlatorDelete           "
+ *      CMM_XlatorFreeBuf          "
+ *      CMM_XlatorTranslate        "
+ *
+ *
+ *  Notes:
+ *      #1: Used by Node and Stream modules for SM address translation.
+ *
+ *! Revision History:
+ *! ================
+ *! 30-Jan-2002 ag  Removed unused CMM_Alloc[Free]Desc & CMM_XlatorRegisterPa.
+ *!                 Renamed CMM_AllocBuf() to CMM_CallocBuf().
+ *! 29-Aug-2001 ag: Added dsp virt base and size to CMM_RegisterGPPSMSeg().
+ *! 12-Aug-2001 ag: Added CMM_UnRegisterGPP[DSP}SMSeg[s]().
+ *! 05-Dec-2000 ag: Added param to CMM_XlatorDelete() to force buf cleanup.
+ *! 30-Oct-2000 ag: Added conversion factor to CMM_RegisterDSP[GPP]SMSeg().
+ *! 12-Oct-2000 ag: Added CMM_Xlator[xxx] functions.
+ *! 10-Aug-2000 ag: Created.
+ *!
+ */
+
+#ifndef CMM_
+#define CMM_
+
+#include <devdefs.h>
+
+#include <cmmdefs.h>
+#include <host_os.h>
+
+/*
+ *  ======== CMM_CallocBuf ========
+ *  Purpose:
+ *      Allocate memory buffers that can be used for data streaming or
+ *      messaging.
+ *  Parameters:
+ *      hCmmMgr:   Cmm Mgr handle.
+ *      uSize:     Number of bytes to allocate.
+ *      pAttr:     Attributes of memory to allocate.
+ *      ppBufVA:   Address of where to place VA.
+ *  Returns:
+ *      Pointer to a zero'd block of SM memory;
+ *      NULL if memory couldn't be allocated,
+ *      or if cBytes == 0,
+ *  Requires:
+ *      Valid hCmmMgr.
+ *      CMM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.
+ *
+ */
+	extern void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr,
+				   u32 uSize, struct CMM_ATTRS *pAttrs,
+				   OUT void **ppBufVA);
+
+/*
+ *  ======== CMM_Create ========
+ *  Purpose:
+ *      Create a communication memory manager object.
+ *  Parameters:
+ *      phCmmMgr:   Location to store a communication manager handle on output.
+ *      hDevObject: Handle to a device object.
+ *      pMgrAttrs:  Comm mem manager attributes.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      Failed to initialize critical sect sync object.
+ *
+ *  Requires:
+ *      CMM_Init() called.
+ *      phCmmMgr != NULL.
+ *      pMgrAttrs->ulMinBlockSize >= 4 bytes.
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     IN CONST struct CMM_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== CMM_Destroy ========
+ *  Purpose:
+ *      Destroy the communication memory manager object.
+ *  Parameters:
+ *      hCmmMgr:   Cmm Mgr handle.
+ *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
+ *                 If FALSE, and outstanding allocations will return DSP_EFAIL
+ *                 status.
+ *  Returns:
+ *      DSP_SOK:        CMM object & resources deleted.
+ *      DSP_EFAIL:      Unable to free CMM object due to outstanding allocation.
+ *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
+ *  Requires:
+ *      CMM is initialized.
+ *      hCmmMgr != NULL.
+ *  Ensures:
+ *      Memory resources used by Cmm Mgr are freed.
+ */
+	extern DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce);
+
+/*
+ *  ======== CMM_Exit ========
+ *  Purpose:
+ *     Discontinue usage of module. Cleanup CMM module if CMM cRef reaches zero.
+ *  Parameters:
+ *     n/a
+ *  Returns:
+ *     n/a
+ *  Requires:
+ *     CMM is initialized.
+ *  Ensures:
+ */
+	extern void CMM_Exit();
+
+/*
+ *  ======== CMM_FreeBuf ========
+ *  Purpose:
+ *      Free the given buffer.
+ *  Parameters:
+ *      hCmmMgr:    Cmm Mgr handle.
+ *      pBuf:       Pointer to memory allocated by CMM_CallocBuf().
+ *      ulSegId:    SM segment Id used in CMM_Calloc() attrs.
+ *                  Set to 0 to use default segment.
+ *  Returns:
+ *      DSP_SOK
+ *      DSP_EFAIL
+ *  Requires:
+ *      CMM initialized.
+ *      pBufPA != NULL
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr,
+				      void *pBufPA, u32 ulSegId);
+
+/*
+ *  ======== CMM_GetHandle ========
+ *  Purpose:
+ *      Return the handle to the cmm mgr for the given device obj.
+ *  Parameters:
+ *      hProcessor:   Handle to a Processor.
+ *      phCmmMgr:     Location to store the shared memory mgr handle on output.
+ *
+ *  Returns:
+ *      DSP_SOK:        Cmm Mgr opaque handle returned.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      phCmmMgr != NULL
+ *      hDevObject != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
+					OUT struct CMM_OBJECT **phCmmMgr);
+
+/*
+ *  ======== CMM_GetInfo ========
+ *  Purpose:
+ *      Return the current SM and VM utilization information.
+ *  Parameters:
+ *      hCmmMgr:     Handle to a Cmm Mgr.
+ *      pCmmInfo:    Location to store the Cmm information on output.
+ *
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *      DSP_EINVALIDARG Invalid input argument.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
+				      OUT struct CMM_INFO *pCmmInfo);
+
+/*
+ *  ======== CMM_Init ========
+ *  Purpose:
+ *      Initializes private state of CMM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      CMM initialized.
+ */
+	extern bool CMM_Init();
+
+/*
+ *  ======== CMM_RegisterGPPSMSeg ========
+ *  Purpose:
+ *      Register a block of SM with the CMM.
+ *  Parameters:
+ *      hCmmMgr:         Handle to a Cmm Mgr.
+ *      lpGPPBasePA:     GPP Base Physical address.
+ *      ulSize:          Size in GPP bytes.
+ *      dwDSPAddrOffset  GPP PA to DSP PA Offset.
+ *      cFactor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
+ *      dwDSPBase:       DSP virtual base byte address.
+ *      ulDSPSize:       Size of DSP segment in bytes.
+ *      pulSegId:        Address to store segment Id.
+ *
+ *  Returns:
+ *      DSP_SOK:         Success.
+ *      DSP_EHANDLE:     Invalid hCmmMgr handle.
+ *      DSP_EINVALIDARG: Invalid input argument.
+ *      DSP_EFAIL:       Unable to register.
+ *      - On success *pulSegId is a valid SM segment ID.
+ *  Requires:
+ *      ulSize > 0
+ *      pulSegId != NULL
+ *      dwGPPBasePA != 0
+ *      cFactor = CMM_ADDTODSPPA || cFactor = CMM_SUBFROMDSPPA
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
+					       unsigned int dwGPPBasePA,
+					       u32 ulSize,
+					       u32 dwDSPAddrOffset,
+					       enum CMM_CNVTTYPE cFactor,
+					       unsigned int dwDSPBase,
+					       u32 ulDSPSize,
+					       u32 *pulSegId,
+					       u32 dwGPPBaseBA);
+
+/*
+ *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  Purpose:
+ *      Unregister the given memory segment that was previously registered
+ *      by CMM_RegisterGPPSMSeg.
+ *  Parameters:
+ *      hCmmMgr:    Handle to a Cmm Mgr.
+ *      ulSegId     Segment identifier returned by CMM_RegisterGPPSMSeg.
+ *  Returns:
+ *       DSP_SOK:         Success.
+ *       DSP_EHANDLE:     Invalid handle.
+ *       DSP_EINVALIDARG: Invalid ulSegId.
+ *       DSP_EFAIL:       Unable to unregister for unknown reason.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
+						 u32 ulSegId);
+
+/*
+ *  ======== CMM_XlatorAllocBuf ========
+ *  Purpose:
+ *      Allocate the specified SM buffer and create a local memory descriptor.
+ *      Place on the descriptor on the translator's HaQ (Host Alloc'd Queue).
+ *  Parameters:
+ *      hXlator:    Handle to a Xlator object.
+ *      pVaBuf:     Virtual address ptr(client context)
+ *      uPaSize:    Size of SM memory to allocate.
+ *  Returns:
+ *      Ptr to valid physical address(Pa) of uPaSize bytes, NULL if failed.
+ *  Requires:
+ *      pVaBuf != 0.
+ *      uPaSize != 0.
+ *  Ensures:
+ *
+ */
+	extern void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator,
+					void *pVaBuf, u32 uPaSize);
+
+/*
+ *  ======== CMM_XlatorCreate ========
+ *  Purpose:
+ *     Create a translator(xlator) object used for process specific Va<->Pa
+ *     address translation. Node messaging and streams use this to perform
+ *     inter-processor(GPP<->DSP) zero-copy data transfer.
+ *  Parameters:
+ *     phXlator:       Address to place handle to a new Xlator handle.
+ *     hCmmMgr:        Handle to Cmm Mgr associated with this translator.
+ *     pXlatorAttrs:   Translator attributes used for the client NODE or STREAM.
+ *  Returns:
+ *     DSP_SOK:            Success.
+ *     DSP_EINVALIDARG:    Bad input Attrs.
+ *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
+ *  Requires:
+ *     phXlator != NULL
+ *     hCmmMgr != NULL
+ *     pXlatorAttrs != NULL
+ *  Ensures:
+ *
+ */
+      extern DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
+					 struct CMM_OBJECT *hCmmMgr,
+					 struct CMM_XLATORATTRS *pXlatorAttrs);
+
+/*
+ *  ======== CMM_XlatorDelete ========
+ *  Purpose:
+ *      Delete translator resources
+ *  Parameters:
+ *      hXlator:    handle to translator.
+ *      bForce:     bForce = TRUE will free XLators SM buffers/dscriptrs.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *      DSP_EFAIL:      Unable to free translator resources.
+ *  Requires:
+ *      cRefs > 0
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator,
+					   bool bForce);
+
+/*
+ *  ======== CMM_XlatorFreeBuf ========
+ *  Purpose:
+ *      Free SM buffer and descriptor.
+ *      Does not free client process VM.
+ *  Parameters:
+ *      hXlator:    handle to translator.
+ *      pBufVa      Virtual address of PA to free.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator,
+					    void *pBufVa);
+
+/*
+ *  ======== CMM_XlatorInfo ========
+ *  Purpose:
+ *      Set/Get process specific "translator" address info.
+ *      This is used to perform fast virtaul address translation
+ *      for shared memory buffers between the GPP and DSP.
+ *  Parameters:
+ *     hXlator:     handle to translator.
+ *     pAddr:       Virtual base address of segment.
+ *     ulSize:      Size in bytes.
+ *     uSegId:      Segment identifier of SM segment(s)
+ *     bSetInfo     Set xlator fields if TRUE, else return base addr
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *  Requires:
+ *      (cRefs > 0)
+ *      (pAddr != NULL)
+ *      (ulSize > 0)
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator,
+					 IN OUT u8 **pAddr,
+					 u32 ulSize, u32 uSegId,
+					 bool bSetInfo);
+
+/*
+ *  ======== CMM_XlatorTranslate ========
+ *  Purpose:
+ *      Perform address translation VA<->PA for the specified stream or
+ *      message shared memory buffer.
+ *  Parameters:
+ *     hXlator: handle to translator.
+ *     pAddr    address of buffer to translate.
+ *     xType    Type of address xlation. CMM_PA2VA or CMM_VA2PA.
+ *  Returns:
+ *     Valid address on success, else NULL.
+ *  Requires:
+ *      cRefs > 0
+ *      pAddr != NULL
+ *      xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA)
+ *  Ensures:
+ *
+ */
+	extern void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator,
+					 void *pAddr, enum CMM_XLATETYPE xType);
+
+#endif				/* CMM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cod.h
@@ -0,0 +1,433 @@
+/*
+ * arch/arm/plat-omap/include/bridge/cod.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== cod.h ========
+ *  Description:
+ *      Code management module for DSPs. This module provides an interface
+ *      interface for loading both static and dynamic code objects onto DSP
+ *      systems.
+ *
+ *  Public Functions:
+ *      COD_Close
+ *      COD_Create
+ *      COD_Delete
+ *      COD_Exit
+ *      COD_GetBaseLib
+ *      COD_GetBaseName
+ *      COD_GetLoader
+ *      COD_GetSection
+ *      COD_GetSymValue
+ *      COD_Init
+ *      COD_LoadBase
+ *      COD_Open
+ *      COD_OpenBase
+ *      COD_ReadSection
+ *      COD_UnloadSection
+ *
+ *  Note:
+ *      Currently, only static loading is supported.
+ *
+ *! Revision History
+ *! ================
+ *! 08-Apr-2003 map: Changed DBL to DBLL
+ *! 07-Aug-2002 jeh: Added COD_GetBaseName().
+ *! 17-Jul-2002 jeh: Added COD_Open(), COD_Close().
+ *! 15-Mar-2002 jeh: Added DBL_Flags param to COD_OpenBase().
+ *! 19-Oct-2001 jeh: Added COD_GetBaseLib, COD_GetLoader, (left in
+ *!                  COD_LoadSection(), COD_UnloadSection(), since they
+ *!                  may be needed for BridgeLite).
+ *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
+ *! 11-Jan-2001 jeh: Added COD_OpenBase.
+ *! 29-Sep-2000 kc:  Added size param to COD_ReadSection for input buffer
+ *!                  validation.
+ *! 02-Aug-2000 kc:  Added COD_ReadSection.
+ *! 04-Sep-1997 gp:  Added CDECL identifier to COD_WRITEFXN (for NT)..
+ *! 18-Aug-1997 cr:  Added explicit CDECL identifier.
+ *! 28-Oct-1996 gp:  Added COD_GetSection.
+ *! 30-Jul-1996 gp:  Added envp[] argument to COD_LoadBase().
+ *! 12-Jun-1996 gp:  Moved OUT param first in _Create().  Updated _Create()
+ *!                  call to take a ZLFileName.  Moved COD_ processor types
+ *!                  to CFG.
+ *! 29-May-1996 gp:  Changed WCD_STATUS to DSP_STATUS.  Removed include's.
+ *! 07-May-1996 mg:  Created.
+ *
+ */
+
+#ifndef COD_
+#define COD_
+
+#include <dblldefs.h>
+
+#define COD_MAXPATHLENGTH       255
+#define COD_TRACEBEG            "SYS_PUTCBEG"
+#define COD_TRACEEND            "SYS_PUTCEND"
+#define COD_TRACESECT           "trace"
+#define COD_TRACEBEGOLD         "PUTCBEG"
+#define COD_TRACEENDOLD         "PUTCEND"
+
+#define COD_NOLOAD              DBLL_NOLOAD
+#define COD_SYMB                DBLL_SYMB
+
+/* Flags passed to COD_Open */
+	typedef DBLL_Flags COD_FLAGS;
+
+/* COD code manager handle */
+	struct COD_MANAGER;
+
+/* COD library handle */
+	struct COD_LIBRARYOBJ;
+
+/* COD attributes */
+	 struct COD_ATTRS {
+		u32 ulReserved;
+	} ;
+
+/*
+ *  Function prototypes for writing memory to a DSP system, allocating
+ *  and freeing DSP memory.
+ */
+       typedef u32(*COD_WRITEFXN) (void *pPrivRef, u32 ulDspAddr,
+					     void *pBuf, u32 ulNumBytes,
+					     u32 nMemSpace);
+
+
+/*
+ *  ======== COD_Close ========
+ *  Purpose:
+ *      Close a library opened with COD_Open().
+ *  Parameters:
+ *      lib             - Library handle returned by COD_Open().
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD module initialized.
+ *      valid lib.
+ *  Ensures:
+ *
+ */
+       extern void COD_Close(struct COD_LIBRARYOBJ *lib);
+
+/*
+ *  ======== COD_Create ========
+ *  Purpose:
+ *      Create an object to manage code on a DSP system. This object can be
+ *      used to load an initial program image with arguments that can later
+ *      be expanded with dynamically loaded object files.
+ *      Symbol table information is managed by this object and can be retrieved
+ *      using the COD_GetSymValue() function.
+ *  Parameters:
+ *      phManager:      created manager object
+ *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
+ *      attrs:          attributes to be used by this object. A NULL value
+ *                      will cause default attrs to be used.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      COD_E_NOZLFUNCTIONS:    Could not initialize ZL functions.
+ *      COD_E_ZLCREATEFAILED:   ZL_Create failed.
+ *      DSP_ENOTIMPL:           attrs was not NULL.  We don't yet support
+ *                              non default values of attrs.
+ *  Requires:
+ *      COD module initialized.
+ *      pstrZLFile != NULL
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_Create(OUT struct COD_MANAGER **phManager,
+				    char *pstrZLFile,
+				    IN OPTIONAL CONST struct COD_ATTRS *attrs);
+
+/*
+ *  ======== COD_Delete ========
+ *  Purpose:
+ *      Delete a code manager object.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *  Ensures:
+ */
+       extern void COD_Delete(struct COD_MANAGER *hManager);
+
+/*
+ *  ======== COD_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the COD module.
+ *  Parameters:
+ *      None.
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD initialized.
+ *  Ensures:
+ *      Resources acquired in COD_Init() are freed.
+ */
+       extern void COD_Exit();
+
+/*
+ *  ======== COD_GetBaseLib ========
+ *  Purpose:
+ *      Get handle to the base image DBL library.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      plib:       location to store library handle on output.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      plib != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
+					       struct DBLL_LibraryObj **plib);
+
+/*
+ *  ======== COD_GetBaseName ========
+ *  Purpose:
+ *      Get the name of the base image DBL library.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      pszName:    location to store library name on output.
+ *      uSize:       size of name buffer.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Buffer too small.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pszName != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager,
+						char *pszName, u32 uSize);
+
+/*
+ *  ======== COD_GetEntry ========
+ *  Purpose:
+ *      Retrieve the entry point of a loaded DSP program image
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      pulEntry:   pointer to location for entry point
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pulEntry != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager,
+					     u32 *pulEntry);
+
+/*
+ *  ======== COD_GetLoader ========
+ *  Purpose:
+ *      Get handle to the DBL loader.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      phLoader:   location to store loader handle on output.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      phLoader != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
+					      struct DBLL_TarObj **phLoader);
+
+/*
+ *  ======== COD_GetSection ========
+ *  Purpose:
+ *      Retrieve the starting address and length of a section in the COFF file
+ *      given the section name.
+ *  Parameters:
+ *      lib         Library handle returned from COD_Open().
+ *      pstrSect:   name of the section, with or without leading "."
+ *      puAddr:     Location to store address.
+ *      puLen:      Location to store length.
+ *  Returns:
+ *      DSP_SOK:                Success
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pstrSect != NULL;
+ *      puAddr != NULL;
+ *      puLen != NULL;
+ *  Ensures:
+ *      DSP_SOK:  *puAddr and *puLen contain the address and length of the
+ *                 section.
+ *      else:  *puAddr == 0 and *puLen == 0;
+ *
+ */
+       extern DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib,
+					       IN char *pstrSect,
+					       OUT u32 *puAddr,
+					       OUT u32 *puLen);
+
+/*
+ *  ======== COD_GetSymValue ========
+ *  Purpose:
+ *      Retrieve the value for the specified symbol. The symbol is first
+ *      searched for literally and then, if not found, searched for as a
+ *      C symbol.
+ *  Parameters:
+ *      lib:        library handle returned from COD_Open().
+ *      pstrSymbol: name of the symbol
+ *      value:      value of the symbol
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      COD module initialized.
+ *      Valid hManager.
+ *      pstrSym != NULL.
+ *      pulValue != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hManager,
+						IN char *pstrSym,
+						OUT u32 *pulValue);
+
+/*
+ *  ======== COD_Init ========
+ *  Purpose:
+ *      Initialize the COD module's private state.
+ *  Parameters:
+ *      None.
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public COD functions.
+ */
+       extern bool COD_Init();
+
+/*
+ *  ======== COD_LoadBase ========
+ *  Purpose:
+ *      Load the initial program image, optionally with command-line arguments,
+ *      on the DSP system managed by the supplied handle. The program to be
+ *      loaded must be the first element of the args array and must be a fully
+ *      qualified pathname.
+ *  Parameters:
+ *      hMgr:       manager to load the code with
+ *      nArgc:      number of arguments in the args array
+ *      args:       array of strings for arguments to DSP program
+ *      writeFxn:   board-specific function to write data to DSP system
+ *      pArb:       arbitrary pointer to be passed as first arg to writeFxn
+ *      envp:       array of environment strings for DSP exec.
+ *  Returns:
+ *      DSP_SOK:                   Success.
+ *      COD_E_OPENFAILED:       Failed to open target code.
+ *      COD_E_LOADFAILED:       Failed to load code onto target.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      nArgc > 0.
+ *      aArgs != NULL.
+ *      aArgs[0] != NULL.
+ *      pfnWrite != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_LoadBase(struct COD_MANAGER *hManager,
+					     u32 nArgc, char *aArgs[],
+					     COD_WRITEFXN pfnWrite, void *pArb,
+					     char *envp[]);
+
+
+/*
+ *  ======== COD_Open ========
+ *  Purpose:
+ *      Open a library for reading sections. Does not load or set the base.
+ *  Parameters:
+ *      hMgr:           manager to load the code with
+ *      pszCoffPath:    Coff file to open.
+ *      flags:          COD_NOLOAD (don't load symbols) or COD_SYMB (load
+ *                      symbols).
+ *      pLib:           Handle returned that can be used in calls to COD_Close
+ *                      and COD_GetSection.
+ *  Returns:
+ *      S_OK:                   Success.
+ *      COD_E_OPENFAILED:       Failed to open target code.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      flags == COD_NOLOAD || flags == COD_SYMB.
+ *      pszCoffPath != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS COD_Open(struct COD_MANAGER *hMgr,
+				   IN char *pszCoffPath,
+				   COD_FLAGS flags,
+				   OUT struct COD_LIBRARYOBJ **pLib);
+
+/*
+ *  ======== COD_OpenBase ========
+ *  Purpose:
+ *      Open base image for reading sections. Does not load the base.
+ *  Parameters:
+ *      hMgr:           manager to load the code with
+ *      pszCoffPath:    Coff file to open.
+ *      flags:          Specifies whether to load symbols.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      COD_E_OPENFAILED:   Failed to open target code.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      pszCoffPath != NULL.
+ *  Ensures:
+ */
+extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
+				       DBLL_Flags flags);
+
+/*
+ *  ======== COD_ReadSection ========
+ *  Purpose:
+ *      Retrieve the content of a code section given the section name.
+ *  Parameters:
+ *      hManager    - manager in which to search for the symbol
+ *      pstrSect    - name of the section, with or without leading "."
+ *      pstrContent - buffer to store content of the section.
+ *  Returns:
+ *      DSP_SOK: on success, error code on failure
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_READFAILED: Failed to read content of code section.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pstrSect != NULL;
+ *      pstrContent != NULL;
+ *  Ensures:
+ *      DSP_SOK:  *pstrContent stores the content of the named section.
+ */
+       extern DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib,
+						IN char *pstrSect,
+						OUT char *pstrContent,
+						IN u32 cContentSize);
+
+
+
+#endif				/* COD_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/csl.h
@@ -0,0 +1,135 @@
+/*
+ * arch/arm/plat-omap/include/bridge/csl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== csl.h ========
+ *  Purpose:
+ *      Platform independent C Standard library functions.
+ *
+ *  Public Functions:
+ *      CSL_AnsiToWchar
+ *      CSL_ByteSwap
+ *      CSL_Exit
+ *      CSL_Init
+ *      CSL_NumToAscii
+ *      CSL_Strtok
+ *      CSL_Strtokr
+ *      CSL_WcharToAnsi
+ *
+ *! Revision History:
+ *! ================
+ *! 07-Aug-2002 jeh: Added CSL_Strtokr().
+ *! 21-Sep-2001 jeh: Added CSL_Strncmp.
+ *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
+ *! 19-Nov-2000 kc:  Added CSL_ByteSwap().
+ *! 09-Nov-2000 kc:  Added CSL_Strncat.
+ *! 29-Oct-1999 kc:  Added CSL_Wstrlen().
+ *! 20-Sep-1999 ag:  Added CSL_Wchar2Ansi().
+ *! 19-Jan-1998 cr:  Code review cleanup (mostly documentation fixes).
+ *! 29-Dec-1997 cr:  Changed CSL_lowercase to CSL_Uppercase, added
+ *!                  CSL_AnsiToWchar.
+ *! 30-Sep-1997 cr:  Added explicit cdecl descriptors to fxn definitions.
+ *! 25-Jun-1997 cr:  Added CSL_strcmp.
+ *! 12-Jun-1996 gp:  Created.
+ */
+
+#ifndef CSL_
+#define CSL_
+
+#include <host_os.h>
+
+/*
+ *  ======== CSL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CSL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CSL initialized.
+ *  Ensures:
+ *      Resources acquired in CSL_Init() are freed.
+ */
+	extern void CSL_Exit();
+
+/*
+ *  ======== CSL_Init ========
+ *  Purpose:
+ *      Initialize the CSL module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CSL functions.
+ */
+	extern bool CSL_Init();
+
+/*
+ *  ======== CSL_NumToAscii ========
+ *  Purpose:
+ *      Convert a 1 or 2 digit number to a 2 digit string.
+ *  Parameters:
+ *      pstrNumber: Buffer to store converted string.
+ *      dwNum:      Number to convert.
+ *  Returns:
+ *  Requires:
+ *      pstrNumber must be able to hold at least three characters.
+ *  Ensures:
+ *      pstrNumber will be null terminated.
+ */
+	extern void CSL_NumToAscii(OUT char *pstrNumber, IN u32 dwNum);
+
+
+/*
+ *  ======== CSL_Strtok ========
+ *  Purpose:
+ *      Tokenize a NULL terminated string
+ *  Parameters:
+ *      ptstrSrc:       pointer to string.
+ *      szSeparators:   pointer to a string of seperators
+ *  Returns:
+ *      char *
+ *  Requires:
+ *      CSL initialized.
+ *      ptstrSrc is a valid string pointer.
+ *      szSeparators is a valid string pointer.
+ *  Ensures:
+ */
+	extern char *CSL_Strtok(IN char *ptstrSrc,
+				IN CONST char *szSeparators);
+
+/*
+ *  ======== CSL_Strtokr ========
+ *  Purpose:
+ *      Re-entrant version of strtok.
+ *  Parameters:
+ *      pstrSrc:        Pointer to string. May be NULL on subsequent calls.
+ *      szSeparators:   Pointer to a string of seperators
+ *      ppstrCur:       Location to store start of string for next call to
+ *                      to CSL_Strtokr.
+ *  Returns:
+ *      char * (the token)
+ *  Requires:
+ *      CSL initialized.
+ *      szSeparators != NULL
+ *      ppstrCur != NULL
+ *  Ensures:
+ */
+	extern char *CSL_Strtokr(IN char *pstrSrc,
+				 IN CONST char *szSeparators,
+				 OUT char **ppstrCur);
+
+#endif				/* CSL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbc.h
@@ -0,0 +1,66 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbc.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dbc.h ========
+ *  Purpose:
+ *      "Design by Contract" programming macros.
+ *
+ *  Public Functions:
+ *      DBC_Assert
+ *      DBC_Require
+ *      DBC_Ensure
+ *
+ *  Notes:
+ *      Requires that the GT->ERROR function has been defaulted to a valid
+ *      error handler for the given execution environment.
+ *
+ *      Does not require that GT_init() be called.
+ *
+ *! Revision History:
+ *! ================
+ *! 11-Aug-2000 ag: Removed include <std.h>
+ *! 22-Apr-1996 gp: Created.
+ */
+
+#ifndef DBC_
+#define DBC_
+
+#ifndef GT_TRACE
+#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
+#endif
+
+/* Assertion Macros: */
+#if GT_TRACE
+
+#include <gt.h>
+
+#define DBC_Assert(exp) \
+    if (!(exp)) \
+	printk("%s, line %d: Assertion (" #exp ") failed.\n", \
+	__FILE__, __LINE__)
+#define DBC_Require DBC_Assert	/* Function Precondition.  */
+#define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
+
+#else
+
+#define DBC_Assert(exp)
+#define DBC_Require(exp)
+#define DBC_Ensure(exp)
+
+#endif				/* DEBUG */
+
+#endif				/* DBC_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
@@ -0,0 +1,94 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbdcddef.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbdcddef.h ========
+ *  Description:
+ *      DCD (DSP/BIOS Bridge Configuration Database) constants and types.
+ *
+ *! Revision History:
+ *! ================
+ *! 03-Dec-2003 map Moved and renamed DCD_OBJTYPE to DSP_DCDOBJTYPE in dbdefs.h
+ *! 05-Dec-2002 map Added DCD_CREATELIBTYPE, DCD_EXECUTELIBTYPE,
+ *                        DCD_DELETELIBTYPE
+ *! 24-Feb-2003 kc  Updated REG entry names to DspBridge.
+ *! 22-Nov-2002 gp  Cleaned up comments, formatting.
+ *! 05-Aug-2002 jeh Added DCD_REGISTERFXN.
+ *! 19-Apr-2002 jeh Added DCD_LIBRARYTYPE to DCD_OBJTYPE, dynamic load
+ *!                 properties to DCD_NODEPROPS.
+ *! 29-Jul-2001 ag  Added extended procObj.
+ *! 13-Feb-2001 kc: Named changed from dcdbsdef.h dbdcddef.h.
+ *! 12-Dec-2000 jeh Added DAIS iAlg name to DCD_NODEPROPS.
+ *! 30-Oct-2000 kc: Added #defines for DCD_AutoRegister function.
+ *! 05-Sep-2000 jeh Added DCD_NODEPROPS.
+ *! 12-Aug-2000 kc: Incoroporated the use of types defined in <dspdefs.h>.
+ *! 29-Jul-2000 kc: Created.
+ */
+
+#ifndef DBDCDDEF_
+#define DBDCDDEF_
+
+#include <dbdefs.h>
+#include <mgrpriv.h>		/* for MGR_PROCESSOREXTINFO */
+
+/*
+ *  The following defines are critical elements for the DCD module:
+ *
+ * - DCD_REGKEY enables DCD functions to locate registered DCD objects.
+ * - DCD_REGISTER_SECTION identifies the COFF section where the UUID of
+ *   registered DCD objects are stored.
+ */
+#define DCD_REGKEY              "Software\\TexasInstruments\\DspBridge\\DCD"
+#define DCD_REGISTER_SECTION    ".dcd_register"
+
+/* DCD Manager Object */
+	struct DCD_MANAGER;
+
+/* DCD Node Properties */
+	struct DCD_NODEPROPS {
+		struct DSP_NDBPROPS ndbProps;
+		u32 uMsgSegid;
+		u32 uMsgNotifyType;
+		char *pstrCreatePhaseFxn;
+		char *pstrDeletePhaseFxn;
+		char *pstrExecutePhaseFxn;
+		char *pstrIAlgName;
+
+		/* Dynamic load properties */
+		u16 usLoadType;	/* Static, dynamic, overlay */
+		u32 ulDataMemSegMask;	/* Data memory requirements */
+		u32 ulCodeMemSegMask;	/* Code memory requirements */
+	} ;
+
+/* DCD Generic Object Type */
+	struct DCD_GENERICOBJ {
+		union dcdObjUnion {
+			struct DCD_NODEPROPS nodeObj;	/* node object. */
+			/* processor object. */
+			struct DSP_PROCESSORINFO procObj;
+			/* extended proc object (private) */
+			struct MGR_PROCESSOREXTINFO extProcObj;
+		} objData;
+	} ;
+
+/* DCD Internal Callback Type */
+       typedef DSP_STATUS(*DCD_REGISTERFXN) (IN struct DSP_UUID *pUuid,
+						IN enum DSP_DCDOBJTYPE objType,
+						IN void *handle);
+
+#endif				/* DBDCDDEF_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
@@ -0,0 +1,388 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbdcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dbdcd.h ========
+ *  Description:
+ *      Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
+ *
+ *! Revision History
+ *! ================
+ *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
+ *! 24-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
+ *!                 DCD implementation.
+ *! 05-Aug-2002 jeh Added DCD_GetObjects().
+ *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
+ *! 22-Apr-2002 jeh Added DCD_GetLibraryName().
+ *! 03-Apr-2001 sg  Changed error names to have DCD_E* format.
+ *! 13-Feb-2001 kc  Name changed from dcdbs.h to dbdcd.h.
+ *! 12-Dec-2000 kc  Added DCD_AutoUnregister.
+ *! 09-Nov-2000 kc  Updated usage of DCD_EnumerateObject.
+ *! 30-Oct-2000 kc  Added DCD_AutoRegister. Updated error DCD error codes.
+ *! 29-Sep-2000 kc  Incorporated code review comments. See
+ *!                 /src/reviews/dcd_review.txt.
+ *! 26-Jul-2000 kc  Created.
+ *!
+ */
+
+#ifndef DBDCD_
+#define DBDCD_
+
+#include <dbdcddef.h>
+#include <host_os.h>
+#include <nldrdefs.h>
+
+/*
+ *  ======== DCD_AutoRegister ========
+ *  Purpose:
+ *      This function automatically registers DCD objects specified in a
+ *      special COFF section called ".dcd_register"
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing DCD
+ *                              objects to be registered.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto registration.
+ */
+	extern DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
+					   IN char *pszCoffPath);
+
+/*
+ *  ======== DCD_AutoUnregister ========
+ *  Purpose:
+ *      This function automatically unregisters DCD objects specified in a
+ *      special COFF section called ".dcd_register"
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing
+ *                              DCD objects to be unregistered.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto unregistration.
+ */
+	extern DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
+					     IN char *pszCoffPath);
+
+/*
+ *  ======== DCD_CreateManager ========
+ *  Purpose:
+ *      This function creates a DCD module manager.
+ *  Parameters:
+ *      pszZlDllName:   Pointer to a DLL name string.
+ *      phDcdMgr:       A pointer to a DCD manager handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Unable to allocate memory for DCD manager handle.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      pszZlDllName is non-NULL.
+ *      phDcdMgr is non-NULL.
+ *  Ensures:
+ *      A DCD manager handle is created.
+ */
+	extern DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
+					    OUT struct DCD_MANAGER **phDcdMgr);
+
+/*
+ *  ======== DCD_DestroyManager ========
+ *  Purpose:
+ *      This function destroys a DCD module manager.
+ *  Parameters:
+ *      hDcdMgr:        A DCD manager handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid DCD manager handle.
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr);
+
+/*
+ *  ======== DCD_EnumerateObject ========
+ *  Purpose:
+ *      This function enumerates currently visible DSP/BIOS Bridge objects
+ *      and returns the UUID and type of each enumerated object.
+ *  Parameters:
+ *      cIndex:             The object enumeration index.
+ *      objType:            Type of object to enumerate.
+ *      pUuid:              Pointer to a DSP_UUID object.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EFAIL:          Unable to enumerate through the DCD database.
+ *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid is a valid pointer.
+ *  Ensures:
+ *  Details:
+ *      This function can be used in conjunction with DCD_GetObjectDef to
+ *      retrieve object properties.
+ */
+	extern DSP_STATUS DCD_EnumerateObject(IN s32 cIndex,
+					      IN enum DSP_DCDOBJTYPE objType,
+					      OUT struct DSP_UUID *pUuid);
+
+/*
+ *  ======== DCD_Exit ========
+ *  Purpose:
+ *      This function cleans up the DCD module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ */
+	extern void DCD_Exit();
+
+/*
+ *  ======== DCD_GetDepLibs ========
+ *  Purpose:
+ *      Given the uuid of a library and size of array of uuids, this function
+ *      fills the array with the uuids of all dependent libraries of the input
+ *      library.
+ *  Parameters:
+ *      hDcdMgr: A DCD manager handle.
+ *      pUuid: Pointer to a DSP_UUID for a library.
+ *      numLibs: Size of uuid array (number of library uuids).
+ *      pDepLibUuids: Array of dependent library uuids to be filled in.
+ *      pPersistentDepLibs: Array indicating if corresponding lib is persistent.
+ *      phase: phase to obtain correct input library
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EMEMORY: Memory allocation failure.
+ *      DSP_EDCDREADSECT: Failure to read section containing library info.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pUuid != NULL
+ *      pDepLibUuids != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+					 IN struct DSP_UUID *pUuid,
+					 u16 numLibs,
+					 OUT struct DSP_UUID *pDepLibUuids,
+					 OUT bool *pPersistentDepLibs,
+					 IN enum NLDR_PHASE phase);
+
+/*
+ *  ======== DCD_GetNumDepLibs ========
+ *  Purpose:
+ *      Given the uuid of a library, determine its number of dependent
+ *      libraries.
+ *  Parameters:
+ *      hDcdMgr:        A DCD manager handle.
+ *      pUuid:          Pointer to a DSP_UUID for a library.
+ *      pNumLibs:       Size of uuid array (number of library uuids).
+ *      pNumPersLibs:   number of persistent dependent library.
+ *      phase:          Phase to obtain correct input library
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EMEMORY: Memory allocation failure.
+ *      DSP_EDCDREADSECT: Failure to read section containing library info.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pUuid != NULL
+ *      pNumLibs != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+					    IN struct DSP_UUID *pUuid,
+					    OUT u16 *pNumLibs,
+					    OUT u16 *pNumPersLibs,
+					    IN enum NLDR_PHASE phase);
+
+/*
+ *  ======== DCD_GetLibraryName ========
+ *  Purpose:
+ *      This function returns the name of a (dynamic) library for a given
+ *      UUID.
+ *  Parameters:
+ *      hDcdMgr: A DCD manager handle.
+ *      pUuid:          Pointer to a DSP_UUID that represents a unique DSP/BIOS
+ *                      Bridge object.
+ *      pstrLibName: Buffer to hold library name.
+ *      pdwSize: Contains buffer size. Set to string size on output.
+ *      phase:          Which phase to load
+ *      fPhaseSplit:    Are phases in multiple libraries
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pstrLibName != NULL.
+ *      pUuid != NULL
+ *      pdwSize != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
+					     IN struct DSP_UUID *pUuid,
+					     IN OUT char *pstrLibName,
+					     IN OUT u32 *pdwSize,
+					     IN enum NLDR_PHASE phase,
+					     OUT bool *fPhaseSplit);
+
+/*
+ *  ======== DCD_GetObjectDef ========
+ *  Purpose:
+ *      This function returns the properties/attributes of a DSP/BIOS Bridge
+ *      object.
+ *  Parameters:
+ *      hDcdMgr:            A DCD manager handle.
+ *      pUuid:              Pointer to a DSP_UUID that represents a unique
+ *                          DSP/BIOS Bridge object.
+ *      objType:            The type of DSP/BIOS Bridge object to be
+ *                          referenced (node, processor, etc).
+ *      pObjDef:            Pointer to an object definition structure. A
+ *                          union of various possible DCD object types.
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EDCDPARSESECT:  Unable to parse content of object code section.
+ *      DSP_EDCDREADSECT:   Unable to read object code section.
+ *      DSP_EDCDGETSECT:    Unable to access object code section.
+ *      DSP_EDCDLOADBASE:   Unable to load code base.
+ *      DSP_EFAIL:          General failure.
+ *      DSP_EHANDLE:        Invalid DCD_HMANAGER handle.
+ *  Requires:
+ *      DCD initialized.
+ *      pObjUuid is non-NULL.
+ *      pObjDef is non-NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
+					   IN struct DSP_UUID *pObjUuid,
+					   IN enum DSP_DCDOBJTYPE objType,
+					   OUT struct DCD_GENERICOBJ *pObjDef);
+
+/*
+ *  ======== DCD_GetObjects ========
+ *  Purpose:
+ *      This function finds all DCD objects specified in a special
+ *      COFF section called ".dcd_register", and for each object,
+ *      call a "register" function.  The "register" function may perform
+ *      various actions, such as 1) register nodes in the node database, 2)
+ *      unregister nodes from the node database, and 3) add overlay nodes.
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing DCD
+ *                              objects.
+ *      registerFxn:            Callback fxn to be applied on each located
+ *                              DCD object.
+ *      handle:                 Handle to pass to callback.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find .dcd_register section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto registration.
+ */
+	extern DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr,
+					 IN char *pszCoffPath,
+					 DCD_REGISTERFXN registerFxn,
+					 void *handle);
+
+/*
+ *  ======== DCD_Init ========
+ *  Purpose:
+ *      This function initializes DCD.
+ *  Parameters:
+ *  Returns:
+ *      FALSE:  Initialization failed.
+ *      TRUE:   Initialization succeeded.
+ *  Requires:
+ *  Ensures:
+ *      DCD initialized.
+ */
+	extern bool DCD_Init();
+
+/*
+ *  ======== DCD_RegisterObject ========
+ *  Purpose:
+ *      This function registers a DSP/BIOS Bridge object in the DCD database.
+ *  Parameters:
+ *      pUuid:          Pointer to a DSP_UUID that identifies a DSP/BIOS
+ *                      Bridge object.
+ *      objType:        Type of object.
+ *      pszPathName:    Path to the object's COFF file.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to register object.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid and szPathName are non-NULL values.
+ *      objType is a valid type value.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
+					     IN enum DSP_DCDOBJTYPE objType,
+					     IN char *pszPathName);
+
+/*
+ *  ======== DCD_UnregisterObject ========
+ *  Purpose:
+ *      This function de-registers a valid DSP/BIOS Bridge object from the DCD
+ *      database.
+ *  Parameters:
+ *      pUuid:      Pointer to a DSP_UUID that identifies a DSP/BIOS Bridge
+ *                  object.
+ *      objType:    Type of object.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Unable to de-register the specified object.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid is a non-NULL value.
+ *      objType is a valid type value.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
+					       IN enum DSP_DCDOBJTYPE objType);
+
+#endif				/* _DBDCD_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -0,0 +1,565 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dbdefs.h ========
+ *  Description:
+ *      Global definitions and constants for DSP/BIOS Bridge.
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
+ *! 08-Mar-2004 sb  Added MAPATTR & ELEM_SIZE for Dynamic Memory Mapping feature
+ *! 09-Feb-2004 vp  Added processor ID numbers for DSP and IVA
+ *! 06-Feb-2003 kc  Removed DSP_POSTMESSAGE. Updated IsValid*Event macros.
+ *! 22-Nov-2002 gp  Cleaned up comments, formatting.
+ *!                 Removed unused DSP_ENUMLASTNODE define.
+ *! 13-Feb-2002 jeh Added uSysStackSize to DSP_NDBPROPS.
+ *! 23-Jan-2002 ag  Added #define DSP_SHMSEG0.
+ *! 12-Dec-2001 ag  Added DSP_ESTRMMODE error code.
+ *! 04-Dec-2001 jeh Added DSP_ENOTCONNECTED error code.
+ *! 10-Dec-2001 kc: Modified macros and definitions to disable DSP_POSTMESSAGE.
+ *! 01-Nov-2001 jeh Added DSP_EOVERLAYMEMORY.
+ *! 18-Oct-2001 ag  Added DSP_STRMMODE type.
+ *!                 Added DSP_ENOTSHAREDMEM.
+ *! 21-Sep-2001 ag  Added additional error codes.
+ *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
+ *! 11-May-2001 jeh Changed DSP_NODE_MIN_PRIORITY from 0 to 1. Removed hNode
+ *!                 from DSP_NODEINFO.
+ *! 02-Apr-2001 sg  Added missing error codes, rearranged codes, switched to
+ *!             hex offsets, renamed some codes to match API spec.
+ *! 16-Jan-2001 jeh Added DSP_ESYMBOL, DSP_EUUID.
+ *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
+ *! 05-Dec-2000 ag: Added DSP_RMSxxx user available message command codes.
+ *! 09-Nov-2000 rr: Added DSP_PROCEESORRESTART define; Removed DSP_PBUFFER.
+ *!                 Added DSP_DCD_ENOAUTOREGISTER, DSP_EUSER1-16, DSP_ESTRMFUL
+ *!                 Removed DSP_EDONE. Macros's modified.
+ *! 23-Oct-2000 jeh Replaced DSP_STREAMSTATECHANGE with DSP_STREAMDONE.
+ *! 09-Oct-2000 jeh Updated to version 0.9 DSP Bridge API spec.
+ *! 29-Sep-2000 kc  Added error codes for DCD and REG to simplify use of
+ *!                 these codes within the RM module.
+ *! 27-Sep-2000 jeh Added segid, alignment, uNumBufs to DSP_STREAMATTRIN.
+ *! 29-Aug-2000 jeh Added DSP_NODETYPE enum, changed DSP_EALREADYATTACHED to
+ *!                 DSP_EALREADYCONNECTED. Changed scStreamConnection[1]
+ *!                 to scStreamConnection[16] in DSP_NODEINFO structure.
+ *!                 Added DSP_NOTIFICATION, DSP_STRMATTR. PSTRING changed
+ *!                 back to TCHAR * and moved to dbtype.h.
+ *! 11-Aug-2000 rr: Macros to check valid events and notify masks added.
+ *! 09-Aug-2000 rr: Changed PSTRING to *s8
+ *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
+ *! 20-Jul-2000 rr: Updated to version 0.8
+ *! 17-Jul-2000 rr: New PROC states added to the DSP_PROCSTATE.
+ *! 27-Jun-2000 rr: Created from dspapi.h
+ */
+
+#ifndef DBDEFS_
+#define DBDEFS_
+
+#include <linux/types.h>
+
+#include <dbtype.h>		/* GPP side type definitions           */
+#include <std.h>		/* DSP/BIOS type definitions           */
+#include <rms_sh.h>		/* Types shared between GPP and DSP    */
+
+#define PG_SIZE_4K 4096
+#define PG_MASK(pg_size) (~((pg_size)-1))
+#define PG_ALIGN_LOW(addr, pg_size) ((addr) & PG_MASK(pg_size))
+#define PG_ALIGN_HIGH(addr, pg_size) (((addr)+(pg_size)-1) & PG_MASK(pg_size))
+
+/* API return value and calling convention */
+#define DBAPI                       DSP_STATUS
+
+/* Infinite time value for the uTimeout parameter to DSPStream_Select() */
+#define DSP_FOREVER                 (-1)
+
+/* Maximum length of node name, used in DSP_NDBPROPS */
+#define DSP_MAXNAMELEN              32
+
+/* uNotifyType values for the RegisterNotify() functions. */
+#define DSP_SIGNALEVENT             0x00000001
+
+/* Types of events for processors */
+#define DSP_PROCESSORSTATECHANGE    0x00000001
+#define DSP_PROCESSORATTACH         0x00000002
+#define DSP_PROCESSORDETACH         0x00000004
+#define DSP_PROCESSORRESTART        0x00000008
+
+/* DSP exception events (DSP/BIOS and DSP MMU fault) */
+#define DSP_MMUFAULT                0x00000010
+#define DSP_SYSERROR                0x00000020
+#define DSP_EXCEPTIONABORT          0x00000300
+
+/* IVA exception events (IVA MMU fault) */
+#define IVA_MMUFAULT                0x00000040
+/* Types of events for nodes */
+#define DSP_NODESTATECHANGE         0x00000100
+#define DSP_NODEMESSAGEREADY        0x00000200
+
+/* Types of events for streams */
+#define DSP_STREAMDONE              0x00001000
+#define DSP_STREAMIOCOMPLETION      0x00002000
+
+/* Handle definition representing the GPP node in DSPNode_Connect() calls */
+#define DSP_HGPPNODE                0xFFFFFFFF
+
+/* Node directions used in DSPNode_Connect() */
+#define DSP_TONODE                  1
+#define DSP_FROMNODE                2
+
+/* Define Node Minimum and Maximum Priorities */
+#define DSP_NODE_MIN_PRIORITY       1
+#define DSP_NODE_MAX_PRIORITY       15
+
+/* Pre-Defined Message Command Codes available to user: */
+#define DSP_RMSUSERCODESTART RMS_USER	/* Start of RMS user cmd codes */
+/* end of user codes */
+#define DSP_RMSUSERCODEEND (RMS_USER + RMS_MAXUSERCODES);
+#define DSP_RMSBUFDESC RMS_BUFDESC	/* MSG contains SM buffer description */
+
+/* Shared memory identifier for MEM segment named "SHMSEG0" */
+#define DSP_SHMSEG0     (u32)(-1)
+
+/* Processor ID numbers */
+#define DSP_UNIT    0
+#define IVA_UNIT    1
+
+#define DSPWORD       unsigned char
+#define DSPWORDSIZE     sizeof(DSPWORD)
+
+/* Success & Failure macros  */
+#define DSP_SUCCEEDED(Status)      likely((s32)(Status) >= 0)
+#define DSP_FAILED(Status)         unlikely((s32)(Status) < 0)
+
+/* Power control enumerations */
+#define PROC_PWRCONTROL             0x8070
+
+#define PROC_PWRMGT_ENABLE          (PROC_PWRCONTROL + 0x3)
+#define PROC_PWRMGT_DISABLE         (PROC_PWRCONTROL + 0x4)
+
+/* Bridge Code Version */
+#define BRIDGE_VERSION_CODE         333
+
+#define    MAX_PROFILES     16
+
+/* Types defined for 'Bridge API */
+	typedef u32 DSP_STATUS;	/* API return code type         */
+
+	typedef HANDLE DSP_HNODE;	/* Handle to a DSP Node object  */
+	typedef HANDLE DSP_HPROCESSOR;	/* Handle to a Processor object */
+	typedef HANDLE DSP_HSTREAM;	/* Handle to a Stream object    */
+
+	typedef u32 DSP_PROCFAMILY;	/* Processor family             */
+	typedef u32 DSP_PROCTYPE;	/* Processor type (w/in family) */
+	typedef u32 DSP_RTOSTYPE;	/* Type of DSP RTOS             */
+
+/* Handy Macros */
+#define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
+				    DSP_PROCESSORATTACH | \
+				    DSP_PROCESSORDETACH | \
+				    DSP_PROCESSORRESTART | \
+				    DSP_NODESTATECHANGE | \
+				    DSP_STREAMDONE | \
+				    DSP_STREAMIOCOMPLETION | \
+				    DSP_MMUFAULT | \
+				    DSP_SYSERROR)) && \
+				!((x) & ~(DSP_PROCESSORSTATECHANGE | \
+				    DSP_PROCESSORATTACH | \
+				    DSP_PROCESSORDETACH | \
+				    DSP_PROCESSORRESTART | \
+				    DSP_NODESTATECHANGE | \
+				    DSP_STREAMDONE | \
+				    DSP_STREAMIOCOMPLETION | \
+				    DSP_MMUFAULT | \
+				    DSP_SYSERROR))))
+
+#define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
+				DSP_NODEMESSAGEREADY)) && \
+				!((x) & ~(DSP_NODESTATECHANGE | \
+				DSP_NODEMESSAGEREADY))))
+
+#define IsValidStrmEvent(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
+				DSP_STREAMIOCOMPLETION)) && \
+				!((x) & ~(DSP_STREAMDONE | \
+				DSP_STREAMIOCOMPLETION))))
+
+#define IsValidNotifyMask(x)   ((x) & DSP_SIGNALEVENT)
+
+/* The Node UUID structure */
+	struct DSP_UUID {
+		u32 ulData1;
+		u16 usData2;
+		u16 usData3;
+		u8 ucData4;
+		u8 ucData5;
+		u8 ucData6[6];
+	};
+
+/* DCD types */
+	enum DSP_DCDOBJTYPE {
+		DSP_DCDNODETYPE,
+		DSP_DCDPROCESSORTYPE,
+		DSP_DCDLIBRARYTYPE,
+		DSP_DCDCREATELIBTYPE,
+		DSP_DCDEXECUTELIBTYPE,
+		DSP_DCDDELETELIBTYPE
+	} ;
+
+/* Processor states */
+	enum DSP_PROCSTATE {
+		PROC_STOPPED,
+		PROC_LOADED,
+		PROC_RUNNING,
+		PROC_ERROR
+	} ;
+
+/* Node types */
+	enum DSP_NODETYPE {
+		NODE_DEVICE,
+		NODE_TASK,
+		NODE_DAISSOCKET,
+		NODE_MESSAGE
+	} ;
+
+/* Node states */
+	enum DSP_NODESTATE {
+		NODE_ALLOCATED,
+		NODE_CREATED,
+		NODE_RUNNING,
+		NODE_PAUSED,
+		NODE_DONE
+	} ;
+
+/* Stream states */
+	enum DSP_STREAMSTATE {
+		STREAM_IDLE,
+		STREAM_READY,
+		STREAM_PENDING,
+		STREAM_DONE
+	} ;
+
+/* Stream connect types */
+	enum DSP_CONNECTTYPE {
+		CONNECTTYPE_NODEOUTPUT,
+		CONNECTTYPE_GPPOUTPUT,
+		CONNECTTYPE_NODEINPUT,
+		CONNECTTYPE_GPPINPUT
+	} ;
+
+/* Stream mode types */
+	enum DSP_STRMMODE {
+		STRMMODE_PROCCOPY, /* Processor(s) copy stream data payloads */
+		STRMMODE_ZEROCOPY, /* Strm buffer ptrs swapped no data copied */
+		STRMMODE_LDMA,	/* Local DMA : OMAP's System-DMA device */
+		STRMMODE_RDMA	/* Remote DMA: OMAP's DSP-DMA device */
+	} ;
+
+/* Resource Types */
+	enum DSP_RESOURCEINFOTYPE {
+		DSP_RESOURCE_DYNDARAM = 0,
+		DSP_RESOURCE_DYNSARAM,
+		DSP_RESOURCE_DYNEXTERNAL,
+		DSP_RESOURCE_DYNSRAM,
+		DSP_RESOURCE_PROCLOAD
+	} ;
+
+/* Memory Segment Types */
+	enum DSP_MEMTYPE {
+		DSP_DYNDARAM = 0,
+		DSP_DYNSARAM,
+		DSP_DYNEXTERNAL,
+		DSP_DYNSRAM
+	} ;
+
+/* Memory Flush Types */
+       enum DSP_FLUSHTYPE {
+		PROC_INVALIDATE_MEM = 0,
+		PROC_WRITEBACK_MEM,
+		PROC_WRITEBACK_INVALIDATE_MEM,
+	} ;
+
+/* Memory Segment Status Values */
+	struct DSP_MEMSTAT {
+		u32 ulSize;
+		u32 ulTotalFreeSize;
+		u32 ulLenMaxFreeBlock;
+		u32 ulNumFreeBlocks;
+		u32 ulNumAllocBlocks;
+	} ;
+
+/* Processor Load information Values */
+	 struct DSP_PROCLOADSTAT {
+		u32 uCurrLoad;
+		u32 uPredictedLoad;
+		u32 uCurrDspFreq;
+		u32 uPredictedFreq;
+	} ;
+
+/* Attributes for STRM connections between nodes */
+	struct DSP_STRMATTR {
+		u32 uSegid;	/* Memory segment on DSP to allocate buffers */
+		u32 uBufsize;	/* Buffer size (DSP words) */
+		u32 uNumBufs;	/* Number of buffers */
+		u32 uAlignment;	/* Buffer alignment */
+		u32 uTimeout;	/* Timeout for blocking STRM calls */
+		enum DSP_STRMMODE lMode;	/* mode of stream when opened */
+		/* DMA chnl id if DSP_STRMMODE is LDMA or RDMA */
+		u32 uDMAChnlId;
+		u32 uDMAPriority;  /* DMA channel priority 0=lowest, >0=high */
+	} ;
+
+/* The DSP_CBDATA structure */
+	struct DSP_CBDATA {
+		u32 cbData;
+		u8 cData[1];
+	} ;
+
+/* The DSP_MSG structure */
+	struct DSP_MSG {
+		u32 dwCmd;
+		u32 dwArg1;
+		u32 dwArg2;
+	} ;
+
+/* The DSP_RESOURCEREQMTS structure for node's resource requirements  */
+	struct DSP_RESOURCEREQMTS {
+		u32 cbStruct;
+		u32 uStaticDataSize;
+		u32 uGlobalDataSize;
+		u32 uProgramMemSize;
+		u32 uWCExecutionTime;
+		u32 uWCPeriod;
+		u32 uWCDeadline;
+		u32 uAvgExectionTime;
+		u32 uMinimumPeriod;
+	} ;
+
+/*
+ * The DSP_STREAMCONNECT structure describes a stream connection
+ * between two nodes, or between a node and the GPP
+ */
+	struct DSP_STREAMCONNECT {
+		u32 cbStruct;
+		enum DSP_CONNECTTYPE lType;
+		u32 uThisNodeStreamIndex;
+		DSP_HNODE hConnectedNode;
+		struct DSP_UUID uiConnectedNodeID;
+		u32 uConnectedNodeStreamIndex;
+	} ;
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+	struct DSP_NODEPROFS {
+		u32 ulHeapSize;
+	} ;
+#endif
+
+/* The DSP_NDBPROPS structure reports the attributes of a node */
+	struct DSP_NDBPROPS {
+		u32 cbStruct;
+		struct DSP_UUID uiNodeID;
+		char acName[DSP_MAXNAMELEN];
+		enum DSP_NODETYPE uNodeType;
+		u32 bCacheOnGPP;
+		struct DSP_RESOURCEREQMTS dspResourceReqmts;
+		s32 iPriority;
+		u32 uStackSize;
+		u32 uSysStackSize;
+		u32 uStackSeg;
+		u32 uMessageDepth;
+		u32 uNumInputStreams;
+		u32 uNumOutputStreams;
+		u32 uTimeout;
+		u32 uCountProfiles;	/* Number of supported profiles */
+		/* Array of profiles */
+		struct DSP_NODEPROFS aProfiles[MAX_PROFILES];
+		u32 uStackSegName; /* Stack Segment Name */
+	} ;
+
+	/* The DSP_NODEATTRIN structure describes the attributes of a
+	 * node client */
+	struct DSP_NODEATTRIN {
+		u32 cbStruct;
+		s32 iPriority;
+		u32 uTimeout;
+		u32    uProfileID;
+		/* Reserved, for Bridge Internal use only */
+		u32    uHeapSize;
+		void *pGPPVirtAddr; /* Reserved, for Bridge Internal use only */
+	} ;
+
+	/* The DSP_NODEINFO structure is used to retrieve information
+	 * about a node */
+	struct DSP_NODEINFO {
+		u32 cbStruct;
+		struct DSP_NDBPROPS nbNodeDatabaseProps;
+		u32 uExecutionPriority;
+		enum DSP_NODESTATE nsExecutionState;
+		DSP_HNODE hDeviceOwner;
+		u32 uNumberStreams;
+		struct DSP_STREAMCONNECT scStreamConnection[16];
+		u32 uNodeEnv;
+	} ;
+
+	/* The DSP_NODEATTR structure describes the attributes of a node */
+	struct DSP_NODEATTR {
+		u32 cbStruct;
+		struct DSP_NODEATTRIN inNodeAttrIn;
+		u32 uInputs;
+		u32 uOutputs;
+		struct DSP_NODEINFO iNodeInfo;
+	} ;
+
+/*
+ *  Notification type: either the name of an opened event, or an event or
+ *  window handle.
+ */
+	struct DSP_NOTIFICATION {
+		char *psName;
+		HANDLE handle;
+	} ;
+
+/* The DSP_PROCESSORATTRIN structure describes the attributes of a processor */
+	struct DSP_PROCESSORATTRIN{
+		u32 cbStruct;
+		u32 uTimeout;
+	} ;
+
+	enum chipTypes {
+		DSPTYPE_55 = 6,
+		IVA_ARM7 = 0x97,
+		DSPTYPE_64 = 0x99
+	};
+
+/*
+ * The DSP_PROCESSORINFO structure describes basic capabilities of a
+ * DSP processor
+ */
+	struct DSP_PROCESSORINFO {
+		u32 cbStruct;
+		DSP_PROCFAMILY uProcessorFamily;
+		DSP_PROCTYPE uProcessorType;
+		u32 uClockRate;
+		u32 ulInternalMemSize;
+		u32 ulExternalMemSize;
+		u32 uProcessorID;
+		DSP_RTOSTYPE tyRunningRTOS;
+		s32 nNodeMinPriority;
+		s32 nNodeMaxPriority;
+	} ;
+
+/* Error information of last DSP exception signalled to the GPP */
+	struct DSP_ERRORINFO {
+		u32 dwErrMask;
+		u32 dwVal1;
+		u32 dwVal2;
+		u32 dwVal3;
+	} ;
+
+/* The DSP_PROCESSORSTATE structure describes the state of a DSP processor */
+	struct DSP_PROCESSORSTATE {
+		u32 cbStruct;
+		enum DSP_PROCSTATE iState;
+		struct DSP_ERRORINFO errInfo;
+	} ;
+
+/*
+ * The DSP_RESOURCEINFO structure is used to retrieve information about a
+ * processor's resources
+ */
+	struct DSP_RESOURCEINFO {
+		u32 cbStruct;
+		enum DSP_RESOURCEINFOTYPE uResourceType;
+		union {
+			u32 ulResource;
+			struct DSP_MEMSTAT memStat;
+			struct DSP_PROCLOADSTAT procLoadStat;
+		} result;
+	} ;
+
+/*
+ * The DSP_STREAMATTRIN structure describes the attributes of a stream,
+ * including segment and alignment of data buffers allocated with
+ * DSPStream_AllocateBuffers(), if applicable
+ */
+	struct DSP_STREAMATTRIN {
+		u32 cbStruct;
+		u32 uTimeout;
+		u32 uSegment;
+		u32 uAlignment;
+		u32 uNumBufs;
+		enum DSP_STRMMODE lMode;
+		u32 uDMAChnlId;
+		u32 uDMAPriority;
+	} ;
+
+/* The DSP_BUFFERATTR structure describes the attributes of a data buffer */
+	struct DSP_BUFFERATTR {
+		u32 cbStruct;
+		u32 uSegment;
+		u32 uAlignment;
+	} ;
+
+/*
+ *  The DSP_STREAMINFO structure is used to retrieve information
+ *  about a stream.
+ */
+	struct DSP_STREAMINFO {
+		u32 cbStruct;
+		u32 uNumberBufsAllowed;
+		u32 uNumberBufsInStream;
+		u32 ulNumberBytes;
+		HANDLE hSyncObjectHandle;
+		enum DSP_STREAMSTATE ssStreamState;
+	} ;
+
+/* DMM MAP attributes
+It is a bit mask with each bit value indicating a specific attribute
+bit 0 - GPP address type (user virtual=0, physical=1)
+bit 1 - MMU Endianism (Big Endian=1, Little Endian=0)
+bit 2 - MMU mixed page attribute (Mixed/ CPUES=1, TLBES =0)
+bit 3 - MMU element size = 8bit (valid only for non mixed page entries)
+bit 4 - MMU element size = 16bit (valid only for non mixed page entries)
+bit 5 - MMU element size = 32bit (valid only for non mixed page entries)
+bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
+*/
+
+/* Types of mapping attributes */
+
+/* MPU address is virtual and needs to be translated to physical addr */
+#define DSP_MAPVIRTUALADDR          0x00000000
+#define DSP_MAPPHYSICALADDR         0x00000001
+
+/* Mapped data is big endian */
+#define DSP_MAPBIGENDIAN            0x00000002
+#define DSP_MAPLITTLEENDIAN         0x00000000
+
+/* Element size is based on DSP r/w access size */
+#define DSP_MAPMIXEDELEMSIZE        0x00000004
+
+/*
+ * Element size for MMU mapping (8, 16, 32, or 64 bit)
+ * Ignored if DSP_MAPMIXEDELEMSIZE enabled
+ */
+#define DSP_MAPELEMSIZE8            0x00000008
+#define DSP_MAPELEMSIZE16           0x00000010
+#define DSP_MAPELEMSIZE32           0x00000020
+#define DSP_MAPELEMSIZE64           0x00000040
+
+#define DSP_MAPVMALLOCADDR         0x00000080
+
+#define GEM_CACHE_LINE_SIZE     128
+#define GEM_L1P_PREFETCH_SIZE   128
+
+#endif				/* DBDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbg.h
@@ -0,0 +1,110 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dbg.h ========
+ *  Purpose:
+ *      Provide debugging services for 'Bridge Mini Drivers.
+ *
+ *  Public Functions:
+ *      DBG_Exit
+ *      DBG_Init
+ *      DBG_Printf
+ *      DBG_Trace
+ *
+ *  Notes:
+ *      WMD's must not call DBG_Init or DBG_Exit.
+ *
+ *! Revision History:
+ *! ================
+ *! 03-Feb-2000 rr: DBG Levels redefined.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 10-Oct-1997 cr: Added DBG_Printf service.
+ *! 29-May-1996 gp: Removed WCD_ prefix.
+ *! 15-May-1996 gp: Created.
+ */
+
+#ifndef DBG_
+#define DBG_
+#include <host_os.h>
+#include <linux/types.h>
+
+/* Levels of trace debug messages: */
+#define DBG_ENTER   (u8)(0x01)	/* Function entry point. */
+#define DBG_LEVEL1  (u8)(0x02)	/* Display debugging state/varibles */
+#define DBG_LEVEL2  (u8)(0x04)	/* Display debugging state/varibles */
+#define DBG_LEVEL3  (u8)(0x08)	/* Display debugging state/varibles */
+#define DBG_LEVEL4  (u8)(0x10)	/* Display debugging state/varibles */
+#define DBG_LEVEL5  (u8)(0x20)	/* Module Init, Exit */
+#define DBG_LEVEL6  (u8)(0x40)	/* Warn SERVICES Failures */
+#define DBG_LEVEL7  (u8)(0x80)	/* Warn Critical Errors */
+
+#if ((defined DEBUG) || (defined DDSP_DEBUG_PRODUCT)) && GT_TRACE
+
+/*
+ *  ======== DBG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DBG initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void DBG_Exit();
+
+/*
+ *  ======== DBG_Init ========
+ *  Purpose:
+ *      Initializes private state of DBG module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ */
+	extern bool DBG_Init();
+
+/*
+ *  ======== DBG_Trace ========
+ *  Purpose:
+ *      Output a trace message to the debugger, if the given trace level
+ *      is unmasked.
+ *  Parameters:
+ *      bLevel:         Trace level.
+ *      pstrFormat:     sprintf-style format string.
+ *      ...:            Arguments for format string.
+ *  Returns:
+ *      DSP_SOK:        Success, or trace level masked.
+ *      DSP_EFAIL:      On Error.
+ *  Requires:
+ *      DBG initialized.
+ *  Ensures:
+ *      Debug message is printed to debugger output window, if trace level
+ *      is unmasked.
+ */
+	extern DSP_STATUS DBG_Trace(IN u8 bLevel, IN char *pstrFormat, ...);
+#else
+
+#define DBG_Exit()
+#define DBG_Init() true
+#define DBG_Trace(bLevel, pstrFormat, args...)
+
+#endif	     /* ((defined DEBUG) || (defined DDSP_DEBUG_PRODUCT)) && GT_TRACE */
+
+#endif				/* DBG_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbldefs.h
@@ -0,0 +1,155 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbldefs.h ========
+ *
+ *! Revision History
+ *! ================
+ *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
+ *!                     between different loaders).
+ *! 28-Sep-2001 jeh     Created from zl.h.
+ */
+#ifndef DBLDEFS_
+#define DBLDEFS_
+
+/*
+ *  Bit masks for DBL_Flags.
+ */
+#define DBL_NOLOAD   0x0	/* Don't load symbols, code, or data */
+#define DBL_SYMB     0x1	/* load symbols */
+#define DBL_CODE     0x2	/* load code */
+#define DBL_DATA     0x4	/* load data */
+#define DBL_DYNAMIC  0x8	/* dynamic load */
+#define DBL_BSS      0x20	/* Unitialized section */
+
+#define DBL_MAXPATHLENGTH       255
+
+
+
+/*
+ *  ======== DBL_Flags ========
+ *  Specifies whether to load code, data, or symbols
+ */
+typedef s32 DBL_Flags;
+
+/*
+ *  ======== DBL_SectInfo ========
+ *  For collecting info on overlay sections
+ */
+struct DBL_SectInfo {
+	const char *name;	/* name of section */
+	u32 runAddr;		/* run address of section */
+	u32 loadAddr;		/* load address of section */
+	u32 size;		/* size of section (target MAUs) */
+	DBL_Flags type;		/* Code, data, or BSS */
+} ;
+
+/*
+ *  ======== DBL_Symbol ========
+ *  (Needed for dynamic load library)
+ */
+struct DBL_Symbol {
+	u32 value;
+};
+
+/*
+ *  ======== DBL_AllocFxn ========
+ *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
+ *  "size" bytes of memory from segment "space" and return the address in
+ *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
+ *  success, or an error code on failure.
+ */
+typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
+			u32 *dspAddr, s32 segId, s32 req, bool reserved);
+
+
+
+/*
+ *  ======== DBL_FreeFxn ========
+ *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
+ *  bytes of memory from segment "space"
+ */
+typedef bool(*DBL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
+			    bool reserved);
+
+/*
+ *  ======== DBL_LogWriteFxn ========
+ *  Function to call when writing data from a section, to log the info.
+ *  Can be NULL if no logging is required.
+ */
+typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
+				      u32 addr, u32 nBytes);
+
+
+/*
+ *  ======== DBL_SymLookup ========
+ *  Symbol lookup function - Find the symbol name and return its value.
+ *
+ *  Parameters:
+ *      handle          - Opaque handle
+ *      pArg            - Opaque argument.
+ *      name            - Name of symbol to lookup.
+ *      sym             - Location to store address of symbol structure.
+ *
+ *  Returns:
+ *      TRUE:           Success (symbol was found).
+ *      FALSE:          Failed to find symbol.
+ */
+typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
+			      const char *name, struct DBL_Symbol **sym);
+
+
+/*
+ *  ======== DBL_WriteFxn ========
+ *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
+ *  starting at address "dspAddr" from the buffer "buf".  The buffer is
+ *  formatted as an array of words appropriate for the DSP.
+ */
+typedef s32(*DBL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
+			    u32 n, s32 mtype);
+
+/*
+ *  ======== DBL_Attrs ========
+ */
+struct DBL_Attrs {
+	DBL_AllocFxn alloc;
+	DBL_FreeFxn free;
+	void *rmmHandle;	/* Handle to pass to alloc, free functions */
+	DBL_WriteFxn write;
+	void *wHandle;		/* Handle to pass to write, cinit function */
+
+	DBL_LogWriteFxn logWrite;
+	void *logWriteHandle;
+
+	/* Symbol matching function and handle to pass to it */
+	DBL_SymLookup symLookup;
+	void *symHandle;
+	void *symArg;
+
+	/*
+	 *  These file manipulation functions should be compatible with the
+	 *  "C" run time library functions of the same name.
+	 */
+	s32(*fread) (void *, size_t, size_t, void *);
+	s32(*fseek) (void *, long, int);
+	s32(*ftell) (void *);
+	s32(*fclose) (void *);
+	void *(*fopen) (const char *, const char *);
+} ;
+
+#endif				/* DBLDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbl.h
@@ -0,0 +1,354 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbl.h ========
+ *
+ *! Revision History
+ *! ================
+ *! 19-Mar-2002 jeh     Pass DBL_Symbol pointer to DBL_getAddr, DBL_getCAddr
+ *!                     to accomodate dynamic loader library.
+ *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
+ *! 24-Sep-2001 jeh     Code review changes.
+ *! 07-Sep-2001 jeh     Added DBL_LoadSect(), DBL_UnloadSect().
+ *! 05-Jun-2001 jeh     Created based on zl.h.
+ */
+
+#ifndef DBL_
+#define DBL_
+
+#include <dbdefs.h>
+#include <dbldefs.h>
+
+/*
+ *  ======== DBL_close ========
+ *  Close library opened with DBL_open.
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+	extern void DBL_close(struct DBL_LibraryObj *lib);
+
+/*
+ *  ======== DBL_create ========
+ *  Create a target object by specifying the alloc, free, and write
+ *  functions for the target.
+ *  Parameters:
+ *      pTarget         - Location to store target handle on output.
+ *      pAttrs          - Attributes.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *      DBL initialized.
+ *      pAttrs != NULL.
+ *      pTarget != NULL;
+ *  Ensures:
+ *      Success:        *pTarget != NULL.
+ *      Failure:        *pTarget == NULL.
+ */
+	extern DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget,
+				     struct DBL_Attrs *pAttrs);
+
+/*
+ *  ======== DBL_delete ========
+ *  Delete target object and free resources for any loaded libraries.
+ *  Parameters:
+ *      target          - Handle returned from DBL_Create().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *  Ensures:
+ */
+	extern void DBL_delete(struct DBL_TargetObj *target);
+
+/*
+ *  ======== DBL_exit ========
+ *  Discontinue use of DBL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      cRefs > 0.
+ *  Ensures:
+ *      cRefs >= 0.
+ */
+	extern void DBL_exit(void);
+
+/*
+ *  ======== DBL_getAddr ========
+ *  Get address of name in the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pAddr != NULL.
+ *  Ensures:
+ */
+	extern bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
+				struct DBL_Symbol **ppSym);
+
+/*
+ *  ======== DBL_getAttrs ========
+ *  Retrieve the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBL_Create().
+ *      pAttrs          - Location to store attributes on output.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+	extern void DBL_getAttrs(struct DBL_TargetObj *target,
+				 struct DBL_Attrs *pAttrs);
+
+/*
+ *  ======== DBL_getCAddr ========
+ *  Get address of "C" name in the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pAddr != NULL.
+ *  Ensures:
+ */
+	extern bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
+				 struct DBL_Symbol **ppSym);
+
+/*
+ *  ======== DBL_getEntry ========
+ *  Get program entry point.
+ *
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      pEntry          - Location to store entry address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Failure.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      pEntry != NULL.
+ *  Ensures:
+ */
+	extern bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry);
+
+/*
+ *  ======== DBL_getSect ========
+ *  Get address and size of a named section.
+ *  Parameters:
+ *      lib             - Library handle returned from DBL_open().
+ *      name            - Name of section.
+ *      pAddr           - Location to store section address on output.
+ *      pSize           - Location to store section size on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pAddr != NULL;
+ *      pSize != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name,
+				      u32 *pAddr, u32 *pSize);
+
+/*
+ *  ======== DBL_init ========
+ *  Initialize DBL module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Failure.
+ *  Requires:
+ *      cRefs >= 0.
+ *  Ensures:
+ *      Success:        cRefs > 0.
+ *      Failure:        cRefs >= 0.
+ */
+	extern bool DBL_init(void);
+
+/*
+ *  ======== DBL_load ========
+ *  Add symbols/code/data defined in file to that already present on
+ *  the target.
+ *
+ *  Parameters:
+ *      lib             - Library handle returned from DBL_open().
+ *      flags           - Specifies whether loading code, data, and/or symbols.
+ *      attrs           - May contain write, alloc, and free functions.
+ *      pulEntry        - Location to store program entry on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFREAD:     File read failed.
+ *      DSP_EFWRITE:    Write to target failed.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      pEntry != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
+				   struct DBL_Attrs *attrs, u32 *pEntry);
+
+/*
+ *  ======== DBL_loadSect ========
+ *  Load a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains write function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *      DSP_EFWRITE:    Write function failed.
+ *  Requires:
+ *      Valid lib.
+ *      sectName != NULL.
+ *      attrs != NULL.
+ *      attrs->write != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib,
+				       char *sectName,
+				       struct DBL_Attrs *attrs);
+
+/*
+ *  ======== DBL_open ========
+ *  DBL_open() returns a library handle that can be used to load/unload
+ *  the symbols/code/data via DBL_load()/DBL_unload().
+ *  Parameters:
+ *      target          - Handle returned from DBL_create().
+ *      file            - Name of file to open.
+ *      flags           - Specifies whether to load symbols now.
+ *      pLib            - Location to store library handle on output.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Memory allocation failure.
+ *      DSP_EFOPEN:         File open failure.
+ *      DSP_EFREAD:         File read failure.
+ *      DSP_ECORRUPTFILE:   Unable to determine target type.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      file != NULL.
+ *      pLib != NULL.
+ *      struct DBL_Attrs fopen function non-NULL.
+ *  Ensures:
+ *      Success:        Valid *pLib.
+ *      Failure:        *pLib == NULL.
+ */
+	extern DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file,
+				   DBL_Flags flags,
+				   struct DBL_LibraryObj **pLib);
+
+/*
+ *  ======== DBL_readSect ========
+ *  Read COFF section into a character buffer.
+ *  Parameters:
+ *      lib             - Library handle returned from DBL_open().
+ *      name            - Name of section.
+ *      pBuf            - Buffer to write section contents into.
+ *      size            - Buffer size
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section does not exists.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pBuf != NULL.
+ *      size != 0.
+ *  Ensures:
+ */
+	extern DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name,
+				       char *pBuf, u32 size);
+
+/*
+ *  ======== DBL_setAttrs ========
+ *  Set the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBL_create().
+ *      pAttrs          - New attributes.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+	extern void DBL_setAttrs(struct DBL_TargetObj *target,
+				 struct DBL_Attrs *pAttrs);
+
+/*
+ *  ======== DBL_unload ========
+ *  Remove the symbols/code/data corresponding to the library lib.
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+	extern void DBL_unload(struct DBL_LibraryObj *lib,
+			       struct DBL_Attrs *attrs);
+
+/*
+ *  ======== DBL_unloadSect ========
+ *  Unload a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      sectName != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib,
+					 char *sectName,
+					 struct DBL_Attrs *attrs);
+
+#endif				/* DBL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
@@ -0,0 +1,509 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dblldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dblldefs.h ========
+ *
+ *! Revision History
+ *! ================
+ *! 08-Apr-2003 map	    Consolidated DBL into DBLL name
+ *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
+ *!                     between different loaders).
+ *! 28-Sep-2001 jeh     Created from zl.h.
+ */
+#ifndef DBLLDEFS_
+#define DBLLDEFS_
+
+/*
+ *  Bit masks for DBL_Flags.
+ */
+#define DBLL_NOLOAD   0x0	/* Don't load symbols, code, or data */
+#define DBLL_SYMB     0x1	/* load symbols */
+#define DBLL_CODE     0x2	/* load code */
+#define DBLL_DATA     0x4	/* load data */
+#define DBLL_DYNAMIC  0x8	/* dynamic load */
+#define DBLL_BSS      0x20	/* Unitialized section */
+
+#define DBLL_MAXPATHLENGTH       255
+
+
+/*
+ *  ======== DBLL_Target ========
+ *
+ */
+struct DBLL_TarObj;
+
+/*
+ *  ======== DBLL_Flags ========
+ *  Specifies whether to load code, data, or symbols
+ */
+typedef s32 DBLL_Flags;
+
+/*
+ *  ======== DBLL_Library ========
+ *
+ */
+struct DBLL_LibraryObj;
+
+/*
+ *  ======== DBLL_SectInfo ========
+ *  For collecting info on overlay sections
+ */
+struct DBLL_SectInfo {
+	const char *name;	/* name of section */
+	u32 runAddr;		/* run address of section */
+	u32 loadAddr;		/* load address of section */
+	u32 size;		/* size of section (target MAUs) */
+	DBLL_Flags type;	/* Code, data, or BSS */
+} ;
+
+/*
+ *  ======== DBLL_Symbol ========
+ *  (Needed for dynamic load library)
+ */
+struct DBLL_Symbol {
+	u32 value;
+};
+
+/*
+ *  ======== DBLL_AllocFxn ========
+ *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
+ *  "size" bytes of memory from segment "space" and return the address in
+ *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
+ *  success, or an error code on failure.
+ */
+typedef s32(*DBLL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
+			     u32 *dspAddr, s32 segId, s32 req,
+			     bool reserved);
+
+/*
+ *  ======== DBLL_CloseFxn ========
+ */
+typedef s32(*DBLL_FCloseFxn) (void *);
+
+/*
+ *  ======== DBLL_FreeFxn ========
+ *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
+ *  bytes of memory from segment "space"
+ */
+typedef bool(*DBLL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
+			     bool reserved);
+
+/*
+ *  ======== DBLL_FOpenFxn ========
+ */
+typedef void *(*DBLL_FOpenFxn) (const char *, const char *);
+
+/*
+ *  ======== DBLL_LogWriteFxn ========
+ *  Function to call when writing data from a section, to log the info.
+ *  Can be NULL if no logging is required.
+ */
+typedef DSP_STATUS(*DBLL_LogWriteFxn)(void *handle, struct DBLL_SectInfo *sect,
+				       u32 addr, u32 nBytes);
+
+/*
+ *  ======== DBLL_ReadFxn ========
+ */
+typedef s32(*DBLL_ReadFxn) (void *, size_t, size_t, void *);
+
+/*
+ *  ======== DBLL_SeekFxn ========
+ */
+typedef s32(*DBLL_SeekFxn) (void *, long, int);
+
+/*
+ *  ======== DBLL_SymLookup ========
+ *  Symbol lookup function - Find the symbol name and return its value.
+ *
+ *  Parameters:
+ *      handle          - Opaque handle
+ *      pArg            - Opaque argument.
+ *      name            - Name of symbol to lookup.
+ *      sym             - Location to store address of symbol structure.
+ *
+ *  Returns:
+ *      TRUE:           Success (symbol was found).
+ *      FALSE:          Failed to find symbol.
+ */
+typedef bool(*DBLL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
+			       const char *name, struct DBLL_Symbol **sym);
+
+/*
+ *  ======== DBLL_TellFxn ========
+ */
+typedef s32(*DBLL_TellFxn) (void *);
+
+/*
+ *  ======== DBLL_WriteFxn ========
+ *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
+ *  starting at address "dspAddr" from the buffer "buf".  The buffer is
+ *  formatted as an array of words appropriate for the DSP.
+ */
+typedef s32(*DBLL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
+			     u32 n, s32 mtype);
+
+/*
+ *  ======== DBLL_Attrs ========
+ */
+struct DBLL_Attrs {
+	DBLL_AllocFxn alloc;
+	DBLL_FreeFxn free;
+	void *rmmHandle;	/* Handle to pass to alloc, free functions */
+	DBLL_WriteFxn write;
+	void *wHandle;		/* Handle to pass to write, cinit function */
+	bool baseImage;
+	DBLL_LogWriteFxn logWrite;
+	void *logWriteHandle;
+
+	/* Symbol matching function and handle to pass to it */
+	DBLL_SymLookup symLookup;
+	void *symHandle;
+	void *symArg;
+
+	/*
+	 *  These file manipulation functions should be compatible with the
+	 *  "C" run time library functions of the same name.
+	 */
+	 s32(*fread) (void *, size_t, size_t, void *);
+	 s32(*fseek) (void *, long, int);
+	 s32(*ftell) (void *);
+	 s32(*fclose) (void *);
+	void *(*fopen) (const char *, const char *);
+} ;
+
+/*
+ *  ======== DBLL_close ========
+ *  Close library opened with DBLL_open.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+typedef void(*DBLL_CloseFxn) (struct DBLL_LibraryObj *library);
+
+/*
+ *  ======== DBLL_create ========
+ *  Create a target object, specifying the alloc, free, and write functions.
+ *  Parameters:
+ *      pTarget         - Location to store target handle on output.
+ *      pAttrs          - Attributes.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *      DBL initialized.
+ *      pAttrs != NULL.
+ *      pTarget != NULL;
+ *  Ensures:
+ *      Success:        *pTarget != NULL.
+ *      Failure:        *pTarget == NULL.
+ */
+typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
+				    struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_delete ========
+ *  Delete target object and free resources for any loaded libraries.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_Create().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *  Ensures:
+ */
+typedef void(*DBLL_DeleteFxn) (struct DBLL_TarObj *target);
+
+/*
+ *  ======== DBLL_exit ========
+ *  Discontinue use of DBL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      cRefs > 0.
+ *  Ensures:
+ *      cRefs >= 0.
+ */
+typedef void(*DBLL_ExitFxn) (void);
+
+/*
+ *  ======== DBLL_getAddr ========
+ *  Get address of name in the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid library.
+ *      name != NULL.
+ *      ppSym != NULL.
+ *  Ensures:
+ */
+typedef bool(*DBLL_GetAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
+				struct DBLL_Symbol **ppSym);
+
+/*
+ *  ======== DBLL_getAttrs ========
+ *  Retrieve the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_Create().
+ *      pAttrs          - Location to store attributes on output.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
+				 struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_getCAddr ========
+ *  Get address of "C" name on the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      name != NULL.
+ *      ppSym != NULL.
+ *  Ensures:
+ */
+typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
+				 struct DBLL_Symbol **ppSym);
+
+/*
+ *  ======== DBLL_getSect ========
+ *  Get address and size of a named section.
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      name            - Name of section.
+ *      pAddr           - Location to store section address on output.
+ *      pSize           - Location to store section size on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pAddr != NULL;
+ *      pSize != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_GetSectFxn) (struct DBLL_LibraryObj *lib, char *name,
+				      u32 *addr, u32 *size);
+
+/*
+ *  ======== DBLL_init ========
+ *  Initialize DBL module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Failure.
+ *  Requires:
+ *      cRefs >= 0.
+ *  Ensures:
+ *      Success:        cRefs > 0.
+ *      Failure:        cRefs >= 0.
+ */
+typedef bool(*DBLL_InitFxn) (void);
+
+/*
+ *  ======== DBLL_load ========
+ *  Load library onto the target.
+ *
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      flags           - Load code, data and/or symbols.
+ *      attrs           - May contain alloc, free, and write function.
+ *      pulEntry        - Location to store program entry on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFREAD:     File read failed.
+ *      DSP_EFWRITE:    Write to target failed.
+ *      DSP_EDYNLOAD:   Failure in dynamic loader library.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      pEntry != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
+				   DBLL_Flags flags,
+				   struct DBLL_Attrs *attrs, u32 *entry);
+
+/*
+ *  ======== DBLL_loadSect ========
+ *  Load a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains write function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *      DSP_EFWRITE:    Write function failed.
+ *      DSP_ENOTIMPL:   Function not implemented.
+ *  Requires:
+ *      Valid lib.
+ *      sectName != NULL.
+ *      attrs != NULL.
+ *      attrs->write != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
+				       char *pszSectName,
+				       struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_open ========
+ *  DBLL_open() returns a library handle that can be used to load/unload
+ *  the symbols/code/data via DBLL_load()/DBLL_unload().
+ *  Parameters:
+ *      target          - Handle returned from DBLL_create().
+ *      file            - Name of file to open.
+ *      flags           - If flags & DBLL_SYMB, load symbols.
+ *      pLib            - Location to store library handle on output.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Memory allocation failure.
+ *      DSP_EFOPEN:         File open failure.
+ *      DSP_EFREAD:         File read failure.
+ *      DSP_ECORRUPTFILE:   Unable to determine target type.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      file != NULL.
+ *      pLib != NULL.
+ *      DBLL_Attrs fopen function non-NULL.
+ *  Ensures:
+ *      Success:        Valid *pLib.
+ *      Failure:        *pLib == NULL.
+ */
+typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
+				   DBLL_Flags flags,
+				   struct DBLL_LibraryObj **pLib);
+
+/*
+ *  ======== DBLL_readSect ========
+ *  Read COFF section into a character buffer.
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      name            - Name of section.
+ *      pBuf            - Buffer to write section contents into.
+ *      size            - Buffer size
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section does not exists.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pBuf != NULL.
+ *      size != 0.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_ReadSectFxn) (struct DBLL_LibraryObj *lib, char *name,
+				       char *content, u32 uContentSize);
+
+/*
+ *  ======== DBLL_setAttrs ========
+ *  Set the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_create().
+ *      pAttrs          - New attributes.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
+				struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_unload ========
+ *  Unload library loaded with DBLL_load().
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
+			       struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_unloadSect ========
+ *  Unload a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section not found.
+ *      DSP_ENOTIMPL
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      sectName != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_UnloadSectFxn) (struct DBLL_LibraryObj *lib,
+					 char *pszSectName,
+					 struct DBLL_Attrs *attrs);
+
+struct DBLL_Fxns {
+	DBLL_CloseFxn closeFxn;
+	DBLL_CreateFxn createFxn;
+	DBLL_DeleteFxn deleteFxn;
+	DBLL_ExitFxn exitFxn;
+	DBLL_GetAttrsFxn getAttrsFxn;
+	DBLL_GetAddrFxn getAddrFxn;
+	DBLL_GetCAddrFxn getCAddrFxn;
+	DBLL_GetSectFxn getSectFxn;
+	DBLL_InitFxn initFxn;
+	DBLL_LoadFxn loadFxn;
+	DBLL_LoadSectFxn loadSectFxn;
+	DBLL_OpenFxn openFxn;
+	DBLL_ReadSectFxn readSectFxn;
+	DBLL_SetAttrsFxn setAttrsFxn;
+	DBLL_UnloadFxn unloadFxn;
+	DBLL_UnloadSectFxn unloadSectFxn;
+} ;
+
+#endif				/* DBLDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbll.h
@@ -0,0 +1,70 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbll.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbll.h ========
+ *  DSP/BIOS Bridge Dynamic load library module interface. Function header
+ *  comments are in the file dblldefs.h.
+ *
+ *! Revision History
+ *! ================
+ *! 31-Jul-2002 jeh     Removed function comments (now in dblldefs.h).
+ *! 17-Apr-2002 jeh     Created based on zl.h.
+ */
+
+#ifndef DBLL_
+#define DBLL_
+
+#include <dbdefs.h>
+#include <dblldefs.h>
+
+	extern void DBLL_close(struct DBLL_LibraryObj *lib);
+	extern DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget,
+				      struct DBLL_Attrs *pAttrs);
+	extern void DBLL_delete(struct DBLL_TarObj *target);
+	extern void DBLL_exit(void);
+	extern bool DBLL_getAddr(struct DBLL_LibraryObj *lib, char *name,
+				 struct DBLL_Symbol **ppSym);
+	extern void DBLL_getAttrs(struct DBLL_TarObj *target,
+				  struct DBLL_Attrs *pAttrs);
+	extern bool DBLL_getCAddr(struct DBLL_LibraryObj *lib, char *name,
+				  struct DBLL_Symbol **ppSym);
+	extern DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name,
+				       u32 *pAddr, u32 *pSize);
+	extern bool DBLL_init(void);
+	extern DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib,
+				    DBLL_Flags flags,
+				    struct DBLL_Attrs *attrs, u32 *pEntry);
+	extern DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *lib,
+					char *sectName,
+					struct DBLL_Attrs *attrs);
+	extern DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file,
+				    DBLL_Flags flags,
+				    struct DBLL_LibraryObj **pLib);
+	extern DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib,
+					char *name,
+					char *pBuf, u32 size);
+	extern void DBLL_setAttrs(struct DBLL_TarObj *target,
+				  struct DBLL_Attrs *pAttrs);
+	extern void DBLL_unload(struct DBLL_LibraryObj *lib,
+				struct DBLL_Attrs *attrs);
+	extern DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib,
+					  char *sectName,
+					  struct DBLL_Attrs *attrs);
+
+#endif				/* DBLL_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbof.h
@@ -0,0 +1,117 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbof.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbof.h ========
+ *  Description:
+ *      Defines and typedefs for DSP/BIOS Bridge Object File Format (DBOF).
+ *
+ *! Revision History
+ *! ================
+ *! 12-Jul-2002 jeh     Added defines for DBOF_SectHdr page.
+ *! 12-Oct-2001 jeh     Converted to std.h format.
+ *! 07-Sep-2001 jeh     Added overlay support.
+ *! 06-Jul-2001 jeh     Created.
+ */
+
+#ifndef DBOF_
+#define DBOF_
+
+/* Enough to hold DCD section names: 32 digit ID + underscores */
+#define DBOF_DCDSECTNAMELEN     40
+
+/* Values for DBOF_SectHdr page field. */
+#define         DBOF_PROGRAM    0
+#define         DBOF_DATA       1
+#define         DBOF_CINIT      2
+
+/*
+ *  ======== DBOF_FileHdr ========
+ */
+	struct DBOF_FileHdr {
+		u32 magic;	/* COFF magic number */
+		u32 entry;	/* Program entry point */
+		u16 numSymbols;	/* Number of bridge symbols */
+		u16 numDCDSects;	/* Number of DCD sections */
+		u16 numSects;	/* Number of sections to load */
+		u16 numOvlySects;	/* Number of overlay sections */
+		u32 symOffset;	/* Offset in file to symbols */
+		u32 dcdSectOffset;	/* Offset to DCD sections */
+		u32 loadSectOffset;	/* Offset to loadable sections */
+		u32 ovlySectOffset;	/* Offset to overlay data */
+		u16 version;	/* DBOF version number */
+		u16 resvd;	/* Reserved for future use */
+	} ;
+
+/*
+ *  ======== DBOF_DCDSectHdr ========
+ */
+	struct DBOF_DCDSectHdr {
+		u32 size;	/* Sect size (target MAUs) */
+		char name[DBOF_DCDSECTNAMELEN];	/* DCD section name */
+	} ;
+
+/*
+ *  ======== DBOF_OvlySectHdr ========
+ */
+	struct DBOF_OvlySectHdr {
+		u16 nameLen;	/* Length of section name */
+		u16 numCreateSects;	/* # of sects loaded for create phase */
+		u16 numDeleteSects;	/* # of sects loaded for delete phase */
+		u16 numExecuteSects; /* # of sects loaded for execute phase */
+
+		/*
+		 *  Number of sections where load/unload phase is not specified.
+		 *  These sections will be loaded when create phase sects are
+		 *  loaded, and unloaded when the delete phase is unloaded.
+		 */
+		u16 numOtherSects;
+		u16 resvd;	/* Reserved for future use */
+	};
+
+/*
+ *  ======== DBOF_OvlySectData ========
+ */
+	struct DBOF_OvlySectData {
+		u32 loadAddr;	/* Section load address */
+		u32 runAddr;	/* Section run address */
+		u32 size;	/* Section size (target MAUs) */
+		u16 page;	/* Memory page number */
+		u16 resvd;	/* Reserved */
+	} ;
+
+/*
+ *  ======== DBOF_SectHdr ========
+ */
+	struct DBOF_SectHdr {
+		u32 addr;	/* Section address */
+		u32 size;	/* Section size (target MAUs) */
+		u16 page;	/* Page number */
+		u16 resvd;	/* Reserved for future use */
+	} ;
+
+/*
+ *  ======== DBOF_SymbolHdr ========
+ */
+	struct DBOF_SymbolHdr {
+		u32 value;	/* Symbol value */
+		u16 nameLen;	/* Length of symbol name */
+		u16 resvd;	/* Reserved for future use */
+	} ;
+
+#endif				/* DBOF_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbreg.h
@@ -0,0 +1,113 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbreg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dbreg.h ========
+ *  Purpose:
+ *      Registry keys for use in Linux.  This is the clearinghouse for
+ *      registry definitions, hopefully eliminating overlapping between
+ *      modules.
+ *
+ *! Revision History:
+ *! ================
+ *! 10-Apr-2003 vp:  Added macro for subkey TCWORDSWAP.
+ *! 21-Mar-2003 sb:  Added macro for subkey SHMSize
+ *! 27-Aug-2001 jeh  Added WSXREG_LOADERFILENAME.
+ *! 13-Feb-2001 kc:  DSP/BIOS Bridge name updates.
+ *! 29-Nov-2000 rr:  Added WSXREG_DSPTYPE_55 as 6.
+ *! 06-Sep-2000 jeh: Added WSXREG_CHNLOFFSET, WSXREG_NUMCHNLS,
+ *!                  WSXREG_CHNLBUFSIZE.
+ *! 26-Aug-2000 rr:  MEMBASE expanded to 9 entries.
+ *! 26-Jul-2000 rr:  Added WSXREG_DCDNAME for the DCD Dll name. It will
+ *!                  live under WSXREG_WINSPOXCONFIG.
+ *! 17-Jul-2000 rr:  REG_MGR_OBJECT and REG_DRV_OBJECT defined. They
+ *!                  are stored in the Registrty under WSXREG_WINSPOXCONFIG
+ *!                  when they are created in DSP_Init. WSXREG_DEVOBJECT
+ *!                  and WSXREG_MGROBJECT defined.
+ *! 11-Dec-1999 ag:  Renamed Isa to IsaBus due to conflict with ceddk.h.
+ *! 12-Nov-1999 rr:  New Registry Defnitions.
+ *! 15-Oct-1999 rr:  New entry for DevObject created. WSXREG_DEVOBJECT
+ *!                  under WSXREG_DDSPDRIVERPATH
+ *! 10-Nov-1997 cr:  Added WSXREG_INFPATH, WSXREG_WINDEVICEPATH,
+ *!                  WSXREG_WINCURVERSION
+ *! 21-Oct-1997 cr:  Added WSXREG_BUSTYPE.
+ *! 08-Sep-1997 cr:  Added WSXREG_SERVICES, WSXREG_SERVICENAME and
+ *!                  WSXREG_CLASSINDEX.
+ *! 30-Aug-1997 cr:  Added WSXREG_SOFTWAREPATHNT & WSXREG_WBCLASSGUID.
+ *! 24-Mar-1997 gp:  Added MAXCHIPINFOSUBKEY def.
+ *! 18-Feb-1997 cr:  Changed Version1.1 -> Version1.0
+ *! 12-Feb-1997 cr:  Changed WinSPOX -> WinBRIDGE.
+ *! 11-Dec-1996 gp:  Added Perf key name in WinSPOX Config.
+ *! 22-Jul-1996 gp:  Added Trace key name.
+ *! 30-May-1996 cr:  Created.
+ */
+
+#ifndef DBREG_
+#define DBREG_ 1	/* Defined as "1" so InstallShield programs compile. */
+
+#define REG_MGR_OBJECT      1
+#define REG_DRV_OBJECT      2
+/* general registry definitions */
+#define MAXREGPATHLENGTH    255	/* Max registry path length. Also the
+				   max registry value length. */
+#define DSPTYPE_55          6	/* This is the DSP Chip type for 55 */
+#define DSPTYPE_64          0x99
+#define IVA_ARM7            0x97    /* This is the DSP Chip type for IVA/ARM7 */
+
+#define DSPPROCTYPE_C55		5510
+#define DSPPROCTYPE_C64		6410
+#define IVAPROCTYPE_ARM7	470
+/* registry */
+#define DEVNODESTRING    "DevNode"	/* u32 devnode */
+#define CONFIG           "Software\\TexasInstruments\\DirectDSP\\Config"
+#define DRVOBJECT        "DrvObject"
+#define MGROBJECT        "MgrObject"
+#define CLASS            "Device"	/*  device class */
+#define TRACE            "Trace"	/* GT Trace settings.  */
+#define PERFR            "Perf"	/* Enable perf bool.  */
+#define ROOT             "Root"	/*  root dir */
+
+/* MiniDriver related definitions */
+/* The following definitions are under "Drivers\\DirectDSP\\Device\\XXX "
+ * Where XXX is the device or board name */
+
+#define WMDFILENAME      "MiniDriver"	/* WMD entry name */
+#define CHIPTYPE         "ChipType"	/* Chip type */
+#define CHIPNUM          "NumChips"	/* Number of chips */
+#define NUMPROCS         "NumOfProcessors"	/* Number of processors */
+#define DEFEXEC          "DefaultExecutable"	/* Default executable */
+#define AUTOSTART        "AutoStart"	/* Statically load flag */
+#define IVAAUTOSTART     "IvaAutoStart"	/* Statically load flag */
+#define BOARDNAME        "BoardName"	/* Name of the Board */
+#define UNITNUMBER       "UnitNumber"	/* Unit # of the Board */
+#define BUSTYPE          "BusType"	/* Bus type board is on */
+#define BUSNUMBER        "BusNumber"	/* Bus number board is on */
+#define CURRENTCONFIG    "CurrentConfig"	/* Current resources */
+#define PCIVENDEVID      "VendorDeviceId"	/* The board's id */
+#define INFPATH          "InfPath"	/* wmd's inf filename */
+#define DEVOBJECT        "DevObject"
+#define ZLFILENAME       "ZLFileName"	/* Name of ZL file */
+#define WORDSIZE         "WordSize"	/* NumBytes in DSP Word */
+#define SHMSIZE          "SHMSize"	/* Size of SHM reservd on MPU */
+#define IVAEXTMEMSIZE    "IVAEXTMEMSize"	/* IVA External Memeory size  */
+#define TCWORDSWAP       "TCWordSwap"	/* Traffic Contoller Word Swap */
+#define DSPRESOURCES     "DspTMSResources"	/* C55 DSP resurces on OMAP */
+#define IVA1RESOURCES    "ARM7IvaResources"	/* ARM7 IVA resurces on OMAP */
+#define PHYSMEMPOOLBASE  "PhysicalMemBase"   /* Physical mem passed to driver */
+#define PHYSMEMPOOLSIZE  "PhysicalMemSize"   /* Physical mem passed to driver */
+
+#endif				/* DBREG_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbtype.h
@@ -0,0 +1,103 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dbtype.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dbtype.h ========
+ *  Description:
+ *      This header defines data types for DSP/BIOS Bridge APIs and device
+ *      driver modules. It also defines the Hungarian
+ *      prefix to use for each base type.
+ *
+ *
+ *! Revision History:
+ *! =================
+ *! 23-Nov-2002 gp: Purpose -> Description in file header.
+ *! 13-Feb-2001 kc: Name changed from ddsptype.h dbtype.h.
+ *! 09-Oct-2000 jeh Added CHARACTER.
+ *! 11-Aug-2000 ag: Added 'typedef void void'.
+ *! 08-Apr-2000 ww: Cloned.
+ */
+
+#ifndef DBTYPE_
+#define DBTYPE_
+
+/*============================================================================*/
+/*  Argument specification syntax                                             */
+/*============================================================================*/
+
+#ifndef IN
+#define IN			/* Following parameter is for input. */
+#endif
+
+#ifndef OUT
+#define OUT			/* Following parameter is for output. */
+#endif
+
+#ifndef OPTIONAL
+#define OPTIONAL	  /* Function may optionally use previous parameter. */
+#endif
+
+#ifndef CONST
+#define CONST   const
+#endif
+
+/*============================================================================*/
+/*  Boolean constants                                                         */
+/*============================================================================*/
+
+#ifndef FALSE
+#define FALSE   0
+#endif
+#ifndef TRUE
+#define TRUE    1
+#endif
+
+/*============================================================================*/
+/*  NULL    (Definition is language specific)                                 */
+/*============================================================================*/
+
+#ifndef NULL
+#define NULL    ((void *)0)	/* Null pointer. */
+#endif
+
+/*============================================================================*/
+/*  NULL character   (normally used for string termination)                   */
+/*============================================================================*/
+
+#ifndef NULL_CHAR
+#define NULL_CHAR    '\0'	/* Null character. */
+#endif
+
+/*============================================================================*/
+/*  Basic Type definitions (with Prefixes for Hungarian notation)             */
+/*============================================================================*/
+
+#ifndef OMAPBRIDGE_TYPES
+#define OMAPBRIDGE_TYPES
+typedef volatile unsigned short REG_UWORD16;
+#endif
+
+typedef void *HANDLE;		/* h    */
+
+#define TEXT(x) x
+
+#define DLLIMPORT
+#define DLLEXPORT
+
+/* Define DSPAPIDLL correctly in dspapi.h */
+#define _DSPSYSDLL32_
+
+#endif				/* DBTYPE_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/_dcd.h
@@ -0,0 +1,187 @@
+/*
+ * arch/arm/plat-omap/include/bridge/_dcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== _dcd.h ========
+ *  Description:
+ *      Includes the wrapper functions called directly by the
+ *      DeviceIOControl interface.
+ *
+ *  Public Functions:
+ *      WCD_CallDevIOCtl
+ *      WCD_Init
+ *      WCD_InitComplete2
+ *      WCD_Exit
+ *      <MOD>WRAP_*
+ *
+ *  Notes:
+ *      Compiled with CDECL calling convention.
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
+ *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
+ *! 30-Jan-2002 ag  Renamed CMMWRAP_AllocBuf to CMMWRAP_CallocBuf.
+ *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data to acquire PERF stats.
+ *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
+ *!                 NODEWRAP_GetMessageStream.
+ *! 10-Oct-2000 ag: Added user CMM wrappers.
+ *! 04-Aug-2000 rr: MEMWRAP and UTIL_Wrap added.
+ *! 27-Jul-2000 rr: NODEWRAP, STRMWRAP added.
+ *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
+ *! 03-Dec-1999 rr: WCD_InitComplete2 enabled for BRD_AutoStart.
+ *! 09-Nov-1999 kc: Added MEMRY.
+ *! 02-Nov-1999 ag: Added CHNL.
+ *! 08-Oct-1999 rr: Utilwrap_Testdll fxn added
+ *! 24-Sep-1999 rr: header changed from _wcd.h to _dcd.h
+ *! 09-Sep-1997 gp: Created.
+ */
+
+#ifndef _WCD_
+#define _WCD_
+
+#include <wcdioctl.h>
+
+/*
+ *  ======== WCD_CallDevIOCtl ========
+ *  Purpose:
+ *      Call the (wrapper) function for the corresponding WCD IOCTL.
+ *  Parameters:
+ *      cmd:        IOCTL id, base 0.
+ *      args:       Argument structure.
+ *      pResult:
+ *  Returns:
+ *      DSP_SOK if command called; DSP_EINVALIDARG if command not in IOCTL
+ *      table.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
+					   union Trapped_Args *args,
+					   u32 *pResult);
+
+/*
+ *  ======== WCD_Init ========
+ *  Purpose:
+ *      Initialize WCD modules, and export WCD services to WMD's.
+ *      This procedure is called when the class driver is loaded.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern bool WCD_Init();
+
+/*
+ *  ======== WCD_InitComplete2 ========
+ *  Purpose:
+ *      Perform any required WCD, and WMD initialization which
+ *      cannot not be performed in WCD_Init() or DEV_StartDevice() due
+ *      to the fact that some services are not yet
+ *      completely initialized.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Allow this device to load
+ *      DSP_EFAIL:      Failure.
+ *  Requires:
+ *      WCD initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS WCD_InitComplete2();
+
+/*
+ *  ======== WCD_Exit ========
+ *  Purpose:
+ *      Exit all modules initialized in WCD_Init().
+ *      This procedure is called when the class driver is unloaded.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      WCD_Init() was previously called.
+ *  Ensures:
+ *      Resources acquired in WCD_Init() are freed.
+ */
+	extern void WCD_Exit();
+
+/* MGR wrapper functions */
+	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args);
+	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args);
+	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args);
+	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args);
+	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args);
+
+#ifndef RES_CLEANUP_DISABLE
+	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args);
+#endif
+
+
+/* CPRC (Processor) wrapper Functions */
+	extern u32 PROCWRAP_Attach(union Trapped_Args *args);
+	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args);
+	extern u32 PROCWRAP_Detach(union Trapped_Args *args);
+	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args);
+	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args);
+	extern u32 PROCWRAP_GetState(union Trapped_Args *args);
+	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args);
+	extern u32 PROCWRAP_Load(union Trapped_Args *args);
+	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args);
+	extern u32 PROCWRAP_Start(union Trapped_Args *args);
+	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args);
+	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args);
+	extern u32 PROCWRAP_Map(union Trapped_Args *args);
+	extern u32 PROCWRAP_UnMap(union Trapped_Args *args);
+	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args);
+	extern u32 PROCWRAP_Stop(union Trapped_Args *args);
+	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args);
+
+/* NODE wrapper functions */
+	extern u32 NODEWRAP_Allocate(union Trapped_Args *args);
+	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args);
+	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args);
+	extern u32 NODEWRAP_Connect(union Trapped_Args *args);
+	extern u32 NODEWRAP_Create(union Trapped_Args *args);
+	extern u32 NODEWRAP_Delete(union Trapped_Args *args);
+	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args);
+	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args);
+	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args);
+	extern u32 NODEWRAP_Pause(union Trapped_Args *args);
+	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args);
+	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args);
+	extern u32 NODEWRAP_Run(union Trapped_Args *args);
+	extern u32 NODEWRAP_Terminate(union Trapped_Args *args);
+	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args);
+
+/* STRM wrapper functions */
+	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args);
+	extern u32 STRMWRAP_Close(union Trapped_Args *args);
+	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args);
+	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args);
+	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args);
+	extern u32 STRMWRAP_Idle(union Trapped_Args *args);
+	extern u32 STRMWRAP_Issue(union Trapped_Args *args);
+	extern u32 STRMWRAP_Open(union Trapped_Args *args);
+	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args);
+	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args);
+	extern u32 STRMWRAP_Select(union Trapped_Args *args);
+
+	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args);
+	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args);
+	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args);
+	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args);
+
+#endif				/* _WCD_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dehdefs.h
@@ -0,0 +1,42 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dehdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== dehdefs.h ========
+ *  Purpose:
+ *      Definition for mini-driver module DEH.
+ *
+ *! Revision History:
+ *! ================
+ *! 17-Dec-2001 ag: added #include <mbx_sh.h> for shared mailbox codes.
+ *! 10-Dec-2001 kc: added DEH error base value and error max value.
+ *! 11-Sep-2001 kc: created.
+ */
+
+#ifndef DEHDEFS_
+#define DEHDEFS_
+
+#include <mbx_sh.h>		/* shared mailbox codes */
+
+/* DEH object manager */
+	struct DEH_MGR;
+
+/* Magic code used to determine if DSP signaled exception. */
+#define DEH_BASE        MBX_DEH_BASE
+#define DEH_USERS_BASE  MBX_DEH_USERS_BASE
+#define DEH_LIMIT       MBX_DEH_LIMIT
+
+#endif				/* _DEHDEFS_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/devdefs.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/plat-omap/include/bridge/devdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== devdefs.h ========
+ *  Purpose:
+ *      Definition of common include typedef between wmd.h and dev.h. Required
+ *      to break circular dependency between WMD and DEV include files.
+ *
+ *! Revision History:
+ *! ================
+ *! 12-Nov-1996 gp: Renamed from dev1.h.
+ *! 30-May-1996 gp: Broke out from dev.h
+ */
+
+#ifndef DEVDEFS_
+#define DEVDEFS_
+
+/* WCD Device Object */
+	struct DEV_OBJECT;
+
+#endif				/* DEVDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -0,0 +1,785 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dev.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dev.h ========
+ *  Description:
+ *      'Bridge Mini-driver device operations.
+ *
+ *  Public Functions:
+ *      DEV_BrdWriteFxn
+ *      DEV_CreateDevice
+ *      DEV_Create2
+ *      DEV_Destroy2
+ *      DEV_DestroyDevice
+ *      DEV_GetChnlMgr
+ *      DEV_GetCmmMgr
+ *      DEV_GetCodMgr
+ *      DEV_GetDehMgr
+ *      DEV_GetDevNode
+ *      DEV_GetDSPWordSize
+ *      DEV_GetFirst
+ *      DEV_GetIntfFxns
+ *      DEV_GetIOMgr
+ *      DEV_GetMsgMgr
+ *      DEV_GetNext
+ *      DEV_GetNodeManager
+ *      DEV_GetSymbol
+ *      DEV_GetWMDContext
+ *      DEV_Exit
+ *      DEV_Init
+ *      DEV_InsertProcObject
+ *      DEV_IsLocked
+ *      DEV_NotifyClient
+ *      DEV_RegisterNotify
+ *      DEV_ReleaseCodMgr
+ *      DEV_RemoveDevice
+ *      DEV_RemoveProcObject
+ *      DEV_SetChnlMgr
+ *      DEV_SetMsgMgr
+ *      DEV_SetLockOwner
+ *      DEV_StartDevice
+ *
+ *! Revision History:
+ *! ================
+ *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature - Dev_GetDmmMgr
+ *! 09-Feb-2004 vp  Added functions required for IVA
+ *! 25-Feb-2003 swa PMGR Code Review changes incorporated
+ *! 05-Nov-2001 kc: Added DEV_GetDehMgr.
+ *! 05-Dec-2000 jeh Added DEV_SetMsgMgr.
+ *! 29-Nov-2000 rr: Incorporated code review changes.
+ *! 17-Nov-2000 jeh Added DEV_GetMsgMgr.
+ *! 05-Oct-2000 rr: DEV_Create2 & DEV_Destroy2 Added.
+ *! 02-Oct-2000 rr: Added DEV_GetNodeManager.
+ *! 11-Aug-2000 ag: Added DEV_GetCmmMgr() for shared memory management.
+ *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
+ *! 06-Jun-2000 jeh Added DEV_GetSymbol().
+ *! 05-Nov-1999 kc: Updated function prototypes.
+ *! 08-Oct-1997 cr: Added explicit CDECL function identifiers.
+ *! 07-Nov-1996 gp: Updated for code review.
+ *! 22-Oct-1996 gp: Added DEV_CleanupProcessState().
+ *! 29-May-1996 gp: Changed DEV_HDEVNODE --> CFG_HDEVNODE.
+ *! 18-May-1996 gp: Created.
+ */
+
+#ifndef DEV_
+#define DEV_
+
+/*  ----------------------------------- Module Dependent Headers */
+#include <chnldefs.h>
+#include <cmm.h>
+#include <cod.h>
+#include <dehdefs.h>
+#include <nodedefs.h>
+#include <dispdefs.h>
+#include <wmd.h>
+#include <dmm.h>
+#include <host_os.h>
+
+/*  ----------------------------------- This */
+#include <devdefs.h>
+
+
+/*
+ *  ======== DEV_BrdWriteFxn ========
+ *  Purpose:
+ *      Exported function to be used as the COD write function.  This function
+ *      is passed a handle to a DEV_hObject by ZL in pArb, then calls the
+ *      device's WMD_BRD_Write() function.
+ *  Parameters:
+ *      pArb:           Handle to a Device Object.
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via
+ *      pArb is invalid.
+ *  Requires:
+ *      DEV Initialized.
+ *      pHostBuf != NULL
+ *  Ensures:
+ */
+       extern u32 DEV_BrdWriteFxn(void *pArb,
+					   u32 ulDspAddr,
+					   void *pHostBuf,
+					   u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== DEV_CreateDevice ========
+ *  Purpose:
+ *      Called by the operating system to load the 'Bridge Mini Driver for a
+ *      'Bridge device.
+ *  Parameters:
+ *      phDevObject:    Ptr to location to receive the device object handle.
+ *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
+ *                      path is not provided, the file is loaded through
+ *                      'Bridge's module search path.
+ *      pHostConfig:    Host configuration information, to be passed down
+ *                      to the WMD when WMD_DEV_Create() is called.
+ *      pDspConfig:     DSP resources, to be passed down to the WMD when
+ *                      WMD_DEV_Create() is called.
+ *      hDevNode:       Platform (Windows) specific device node.
+ *  Returns:
+ *      DSP_SOK:            Module is loaded, device object has been created
+ *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
+ *                          for this hDevNode.
+ *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
+ *      LDR_E_NOMEMORY:         PELDR is out of resources.
+ *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
+ *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
+ *  Requires:
+ *      DEV Initialized.
+ *      phDevObject != NULL.
+ *      pstrWMDFileName != NULL.
+ *      pHostConfig != NULL.
+ *      pDspConfig != NULL.
+ *  Ensures:
+ *      DSP_SOK:  *phDevObject will contain handle to the new device object.
+ *      Otherwise, does not create the device object, ensures the WMD module is
+ *      unloaded, and sets *phDevObject to NULL.
+ */
+       extern DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT
+						 **phDevObject,
+						 IN CONST char *pstrWMDFileName,
+						 IN CONST struct CFG_HOSTRES
+						 *pHostConfig,
+						 IN CONST struct CFG_DSPRES
+						 *pDspConfig,
+						 struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_CreateIVADevice ========
+ *  Purpose:
+ *      Called by the operating system to load the 'Bridge Mini Driver for IVA.
+ *  Parameters:
+ *      phDevObject:    Ptr to location to receive the device object handle.
+ *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
+ *                      path is not provided, the file is loaded through
+ *                      'Bridge's module search path.
+ *      pHostConfig:    Host configuration information, to be passed down
+ *                      to the WMD when WMD_DEV_Create() is called.
+ *      pDspConfig:     DSP resources, to be passed down to the WMD when
+ *                      WMD_DEV_Create() is called.
+ *      hDevNode:       Platform (Windows) specific device node.
+ *  Returns:
+ *      DSP_SOK:            Module is loaded, device object has been created
+ *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
+ *                          for this hDevNode.
+ *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
+ *      LDR_E_NOMEMORY:         PELDR is out of resources.
+ *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
+ *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
+ *  Requires:
+ *      DEV Initialized.
+ *      phDevObject != NULL.
+ *      pstrWMDFileName != NULL.
+ *      pHostConfig != NULL.
+ *      pDspConfig != NULL.
+ *  Ensures:
+ *      DSP_SOK:  *phDevObject will contain handle to the new device object.
+ *      Otherwise, does not create the device object, ensures the WMD module is
+ *      unloaded, and sets *phDevObject to NULL.
+ */
+       extern DSP_STATUS DEV_CreateIVADevice(OUT struct DEV_OBJECT
+				**phDevObject,
+				IN CONST char *pstrWMDFileName,
+				IN CONST struct CFG_HOSTRES *pHostConfig,
+				IN CONST struct CFG_DSPRES *pDspConfig,
+				struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_Create2 ========
+ *  Purpose:
+ *      After successful loading of the image from WCD_InitComplete2
+ *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      the Node Manager and updates the DEV Object.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:    Successful Creation of Node Manager
+ *      DSP_EFAIL:  Some Error Occurred.
+ *  Requires:
+ *      DEV Initialized
+ *      Valid hDevObject
+ *  Ensures:
+ *      DSP_SOK and hDevObject->hNodeMgr != NULL
+ *      else    hDevObject->hNodeMgr == NULL
+ */
+       extern DSP_STATUS DEV_Create2(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_Destroy2 ========
+ *  Purpose:
+ *      Destroys the Node manager for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:    Successful Creation of Node Manager
+ *      DSP_EFAIL:  Some Error Occurred.
+ *  Requires:
+ *      DEV Initialized
+ *      Valid hDevObject
+ *  Ensures:
+ *      DSP_SOK and hDevObject->hNodeMgr == NULL
+ *      else    DSP_EFAIL.
+ */
+       extern DSP_STATUS DEV_Destroy2(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_DestroyDevice ========
+ *  Purpose:
+ *      Destroys the channel manager for this device, if any, calls
+ *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EFAIL:      The WMD failed it's WMD_DEV_Destroy() function.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT
+						  *hDevObject);
+
+/*
+ *  ======== DEV_GetChnlMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the channel manager created for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
+					       OUT struct CHNL_MGR **phMgr);
+
+/*
+ *  ======== DEV_GetCmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the shared memory manager created for this
+ *      device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct CMM_OBJECT **phMgr);
+
+/*
+ *  ======== DEV_GetDmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the dynamic memory manager created for this
+ *      device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct DMM_OBJECT **phMgr);
+
+/*
+ *  ======== DEV_GetCodMgr ========
+ *  Purpose:
+ *      Retrieve the COD manager create for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phCodMgr:      Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phCodMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phCodMgr contains a handle to a COD manager object.
+ *      else:           *phCodMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
+					     OUT struct COD_MANAGER **phCodMgr);
+
+/*
+ *  ======== DEV_GetDehMgr ========
+ *  Purpose:
+ *      Retrieve the DEH manager created for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      *phDehMgr:  Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EHANDLE:   Invalid hDevObject.
+ *  Requires:
+ *      phDehMgr != NULL.
+ *      DEH Initialized.
+ *  Ensures:
+ *      DSP_SOK:    *phDehMgr contains a handle to a DEH manager object.
+ *      else:       *phDehMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct DEH_MGR **phDehMgr);
+
+/*
+ *  ======== DEV_GetDevNode ========
+ *  Purpose:
+ *      Retrieve the platform specific device ID for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      phDevNode:      Ptr to location to get the device node handle.
+ *  Returns:
+ *      DSP_SOK:        In Win95, returns a DEVNODE in *hDevNode; In NT, ???
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phDevNode != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phDevNode contains a platform specific device ID;
+ *      else:           *phDevNode is NULL.
+ */
+       extern DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
+					OUT struct CFG_DEVNODE **phDevNode);
+
+/*
+ *  ======== DEV_GetDevType ========
+ *  Purpose:
+ *      Retrieve the platform specific device ID for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      phDevNode:      Ptr to location to get the device node handle.
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phDevNode != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phDevNode contains a platform specific device ID;
+ *      else:           *phDevNode is NULL.
+ */
+       extern DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject,
+					       u32 *devType);
+
+/*
+ *  ======== DEV_GetFirst ========
+ *  Purpose:
+ *      Retrieve the first Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DEV.
+ *  Parameters:
+ *  Returns:
+ *      NULL if there are no device objects stored; else
+ *      a valid DEV_HOBJECT.
+ *  Requires:
+ *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
+ *      internal device object list) may occur between calls to DEV_GetFirst
+ *      and DEV_GetNext.
+ *  Ensures:
+ *      The DEV_HOBJECT returned is valid.
+ *      A subsequent call to DEV_GetNext will return the next device object in
+ *      the list.
+ */
+       extern struct DEV_OBJECT *DEV_GetFirst();
+
+/*
+ *  ======== DEV_GetIntfFxns ========
+ *  Purpose:
+ *      Retrieve the WMD interface function structure for the loaded WMD.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *ppIntfFxns:    Ptr to location to store fxn interface.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      ppIntfFxns != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *ppIntfFxns contains a pointer to the WMD interface;
+ *      else:           *ppIntfFxns is NULL.
+ */
+       extern DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
+				OUT struct WMD_DRV_INTERFACE **ppIntfFxns);
+
+/*
+ *  ======== DEV_GetIOMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the IO manager created for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to an IO manager object.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
+					     OUT struct IO_MGR **phMgr);
+
+/*
+ *  ======== DEV_GetNext ========
+ *  Purpose:
+ *      Retrieve the next Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DEV, after having previously called
+ *      DEV_GetFirst() and zero or more DEV_GetNext
+ *  Parameters:
+ *      hDevObject: Handle to the device object returned from a previous
+ *                  call to DEV_GetFirst() or DEV_GetNext().
+ *  Returns:
+ *      NULL if there are no further device objects on the list or hDevObject
+ *      was invalid;
+ *      else the next valid DEV_HOBJECT in the list.
+ *  Requires:
+ *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
+ *      internal device object list) may occur between calls to DEV_GetFirst
+ *      and DEV_GetNext.
+ *  Ensures:
+ *      The DEV_HOBJECT returned is valid.
+ *      A subsequent call to DEV_GetNext will return the next device object in
+ *      the list.
+ */
+       extern struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT
+						    *hDevObject);
+
+/*
+ *  ========= DEV_GetMsgMgr ========
+ *  Purpose:
+ *      Retrieve the MSG Manager Handle from the DevObject.
+ *  Parameters:
+ *      hDevObject: Handle to the Dev Object
+ *      phMsgMgr:   Location where MSG Manager handle will be returned.
+ *  Returns:
+ *  Requires:
+ *      DEV Initialized.
+ *      Valid hDevObject.
+ *      phNodeMgr != NULL.
+ *  Ensures:
+ */
+       extern void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
+					OUT struct MSG_MGR **phMsgMgr);
+
+/*
+ *  ========= DEV_GetNodeManager ========
+ *  Purpose:
+ *      Retrieve the Node Manager Handle from the DevObject. It is an
+ *      accessor function
+ *  Parameters:
+ *      hDevObject:     Handle to the Dev Object
+ *      phNodeMgr:      Location where Handle to the Node Manager will be
+ *                      returned..
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EHANDLE:    Invalid Dev Object handle.
+ *  Requires:
+ *      DEV Initialized.
+ *      phNodeMgr is not null
+ *  Ensures:
+ *      DSP_SOK:        *phNodeMgr contains a handle to a Node manager object.
+ *      else:           *phNodeMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT
+					*hDevObject,
+					OUT struct NODE_MGR **phNodeMgr);
+
+/*
+ *  ======== DEV_GetSymbol ========
+ *  Purpose:
+ *      Get the value of a symbol in the currently loaded program.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      pstrSym:        Name of symbol to look up.
+ *      pulValue:       Ptr to symbol value.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      pstrSym != NULL.
+ *      pulValue != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *pulValue contains the symbol value;
+ */
+       extern DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
+					      IN CONST char *pstrSym,
+					      OUT u32 *pulValue);
+
+/*
+ *  ======== DEV_GetWMDContext ========
+ *  Purpose:
+ *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with DEV_CreateDevice()
+ *      *phWmdContext:  Ptr to location to store context handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phWmdContext != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phWmdContext contains context handle;
+ *      else:           *phWmdContext is NULL;
+ */
+       extern DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
+				OUT struct WMD_DEV_CONTEXT **phWmdContext);
+
+/*
+ *  ======== DEV_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DEV is initialized.
+ *  Ensures:
+ *      When reference count == 0, DEV's private resources are freed.
+ */
+       extern void DEV_Exit();
+
+/*
+ *  ======== DEV_Init ========
+ *  Purpose:
+ *      Initialize DEV's private state, keeping a reference count on each call.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public DEV functions.
+ */
+       extern bool DEV_Init();
+
+/*
+ *  ======== DEV_IsLocked ========
+ *  Purpose:
+ *      Predicate function to determine if the device has been
+ *      locked by a client for exclusive access.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:        TRUE: device has been locked.
+ *      DSP_SFALSE:     FALSE: device not locked.
+ *      DSP_EHANDLE:    hDevObject was invalid.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_IsLocked(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_InsertProcObject ========
+ *  Purpose:
+ *      Inserts the Processor Object into the List of PROC Objects
+ *      kept in the DEV Object
+ *  Parameters:
+ *      hProcObject:    Handle to the Proc Object
+ *      hDevObject      Handle to the Dev Object
+ *      bAttachedNew    Specifies if there are already processors attached
+ *  Returns:
+ *      DSP_SOK:        Successfully inserted into the list
+ *  Requires:
+ *      hProcObject is not NULL
+ *      hDevObject is a valid handle to the DEV.
+ *      DEV Initialized.
+ *      List(of Proc object in Dev) Exists.
+ *  Ensures:
+ *      DSP_SOK & the PROC Object is inserted and the list is not empty
+ *  Details:
+ *      If the List of Proc Object is empty bAttachedNew is TRUE, it indicated
+ *      this is the first Processor attaching.
+ *      If it is False, there are already processors attached.
+ */
+       extern DSP_STATUS DEV_InsertProcObject(IN struct DEV_OBJECT
+						     *hDevObject,
+						     IN u32 hProcObject,
+						     OUT bool *
+						     pbAlreadyAttached);
+
+/*
+ *  ======== DEV_RemoveProcObject ========
+ *  Purpose:
+ *      Search for and remove a Proc object from the given list maintained
+ *      by the DEV
+ *  Parameters:
+ *      pProcObject:        Ptr to ProcObject to insert.
+ *      pDevObject:         Ptr to Dev Object where the list is.
+ *      pbAlreadyAttached:  Ptr to return the bool
+ *  Returns:
+ *      DSP_SOK:            If successful.
+ *      DSP_EFAIL           Failure to Remove the PROC Object from the list
+ *  Requires:
+ *      DevObject is Valid
+ *      hProcObject != 0
+ *      pDevObject->procList != NULL
+ *      !LST_IsEmpty(pDevObject->procList)
+ *      pbAlreadyAttached !=NULL
+ *  Ensures:
+ *  Details:
+ *      List will be deleted when the DEV is destroyed.
+ *
+ */
+       extern DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT
+						     *hDevObject,
+						     u32 hProcObject);
+
+/*
+ *  ======== DEV_NotifyClients ========
+ *  Purpose:
+ *      Notify all clients of this device of a change in device status.
+ *      Clients may include multiple users of BRD, as well as CHNL.
+ *      This function is asychronous, and may be called by a timer event
+ *      set up by a watchdog timer.
+ *  Parameters:
+ *      hDevObject:  Handle to device object created with DEV_CreateDevice().
+ *      ulStatus:    A status word, most likely a BRD_STATUS.
+ *  Returns:
+ *      DSP_SOK:     All registered clients were asynchronously notified.
+ *      DSP_EINVALIDARG:   Invalid hDevObject.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK: Notifications are queued by the operating system to be
+ *      delivered to clients.  This function does not ensure that
+ *      the notifications will ever be delivered.
+ */
+       extern DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
+						  u32 ulStatus);
+
+
+
+/*
+ *  ======== DEV_RemoveDevice ========
+ *  Purpose:
+ *      Destroys the Device Object created by DEV_StartDevice.
+ *  Parameters:
+ *      hDevNode:       Device node as it is know to OS.
+ *  Returns:
+ *      DSP_SOK:        If success;
+ *      <error code>    Otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_SetChnlMgr ========
+ *  Purpose:
+ *      Set the channel manager for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      hMgr:           Handle to a channel manager, or NULL.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject,
+					       struct CHNL_MGR *hMgr);
+
+/*
+ *  ======== DEV_SetMsgMgr ========
+ *  Purpose:
+ *      Set the Message manager for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hMgr:       Handle to a message manager, or NULL.
+ *  Returns:
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject,
+					struct MSG_MGR *hMgr);
+
+/*
+ *  ======== DEV_StartDevice ========
+ *  Purpose:
+ *      Initializes the new device with the WinBRIDGE environment.  This
+ *      involves querying CM for allocated resources, querying the registry
+ *      for necessary dsp resources (requested in the INF file), and using
+ *      this information to create a WinBRIDGE device object.
+ *  Parameters:
+ *      hDevNode:       Device node as it is know to OS.
+ *  Returns:
+ *      DSP_SOK:        If success;
+ *      <error code>    Otherwise.
+ *  Requires:
+ *      DEV initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode);
+
+#endif				/* DEV_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dispdefs.h
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/plat-omap/include/bridge/dispdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dispdefs.h ========
+ *  Description:
+ *      Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
+ *! Revision History
+ *! ================
+ *! 08-Aug-2000 jeh     Added fields to DISP_ATTRS.
+ *! 06-Jul-2000 jeh     Created.
+ */
+
+#ifndef DISPDEFS_
+#define DISPDEFS_
+
+	struct DISP_OBJECT;
+
+/* Node Dispatcher attributes */
+	struct DISP_ATTRS {
+		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
+		/* Size of buffer for sending data to RMS */
+		u32 ulChnlBufSize;
+		DSP_PROCFAMILY procFamily;	/* eg, 5000 */
+		DSP_PROCTYPE procType;	/* eg, 5510 */
+		HANDLE hReserved1;	/* Reserved for future use. */
+		u32 hReserved2;	/* Reserved for future use. */
+	} ;
+
+#endif				/* DISPDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/disp.h
@@ -0,0 +1,236 @@
+/*
+ * arch/arm/plat-omap/include/bridge/disp.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== disp.h ========
+ *
+ *  Description:
+ *      DSP/BIOS Bridge Node Dispatcher.
+ *
+ *  Public Functions:
+ *      DISP_Create
+ *      DISP_Delete
+ *      DISP_Exit
+ *      DISP_Init
+ *      DISP_NodeChangePriority
+ *      DISP_NodeCreate
+ *      DISP_NodeDelete
+ *      DISP_NodeRun
+ *
+ *! Revision History:
+ *! =================
+ *! 28-Jan-2003 map     Removed DISP_DoCinit().
+ *! 15-May-2002 jeh     Added DISP_DoCinit().
+ *! 24-Apr-2002 jeh     Added DISP_MemWrite().
+ *! 07-Sep-2001 jeh     Added DISP_MemCopy().
+ *! 10-May-2001 jeh     Code review cleanup.
+ *! 08-Aug-2000 jeh     Removed DISP_NodeTerminate since it no longer uses RMS.
+ *! 17-Jul-2000 jeh     Updates to function headers.
+ *! 19-Jun-2000 jeh     Created.
+ */
+
+#ifndef DISP_
+#define DISP_
+
+#include <dbdefs.h>
+#include <nodedefs.h>
+#include <nodepriv.h>
+#include <dispdefs.h>
+
+/*
+ *  ======== DISP_Create ========
+ *  Create a NODE Dispatcher object. This object handles the creation,
+ *  deletion, and execution of nodes on the DSP target, through communication
+ *  with the Resource Manager Server running on the target. Each NODE
+ *  Manager object should have exactly one NODE Dispatcher.
+ *
+ *  Parameters:
+ *      phDispObject:   Location to store node dispatcher object on output.
+ *      hDevObject:     Device for this processor.
+ *      pDispAttrs:     Node dispatcher attributes.
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      DSP_EFAIL:              Unable to create dispatcher.
+ *  Requires:
+ *      DISP_Init() called.
+ *      pDispAttrs != NULL.
+ *      hDevObject != NULL.
+ *      phDispObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        IsValid(*phDispObject).
+ *      error:          *phDispObject == NULL.
+ */
+	extern DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct DISP_ATTRS *pDispAttrs);
+
+/*
+ *  ======== DISP_Delete ========
+ *  Delete the NODE Dispatcher.
+ *
+ *  Parameters:
+ *      hDispObject:  Node Dispatcher object.
+ *  Returns:
+ *  Requires:
+ *      DISP_Init() called.
+ *      Valid hDispObject.
+ *  Ensures:
+ *      hDispObject is invalid.
+ */
+	extern void DISP_Delete(struct DISP_OBJECT *hDispObject);
+
+/*
+ *  ======== DISP_Exit ========
+ *  Discontinue usage of DISP module.
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DISP_Init() previously called.
+ *  Ensures:
+ *      Any resources acquired in DISP_Init() will be freed when last DISP
+ *      client calls DISP_Exit().
+ */
+	extern void DISP_Exit();
+
+/*
+ *  ======== DISP_Init ========
+ *  Initialize the DISP module.
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool DISP_Init();
+
+/*
+ *  ======== DISP_NodeChangePriority ========
+ *  Change the priority of a node currently running on the target.
+ *
+ *  Parameters:
+ *      hDispObject:            Node Dispatcher object.
+ *      hNode:                  Node object representing a node currently
+ *                              allocated or running on the DSP.
+ *      ulFxnAddress:           Address of RMS function for changing priority.
+ *      nodeEnv:                Address of node's environment structure.
+ *      nPriority:              New priority level to set node's priority to.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_ETIMEOUT:           A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init() called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT
+						  *hDispObject,
+						  struct NODE_OBJECT *hNode,
+						  u32 ulFxnAddr,
+						  NODE_ENV nodeEnv,
+						  s32 nPriority);
+
+/*
+ *  ======== DISP_NodeCreate ========
+ *  Create a node on the DSP by remotely calling the node's create function.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node handle obtained from NODE_Allocate().
+ *      ulFxnAddr:      Address or RMS create node function.
+ *      ulCreateFxn:    Address of node's create function.
+ *      pArgs:          Arguments to pass to RMS node create function.
+ *      pNodeEnv:       Location to store node environment pointer on
+ *                      output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETASK:      Unable to create the node's task or process on the DSP.
+ *      DSP_ESTREAM:    Stream creation failure on the DSP.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *      DSP_EUSER:      A user-defined failure occurred.
+ *      DSP_EFAIL:      A failure occurred, unable to create node.
+ *  Requires:
+ *      DISP_Init() called.
+ *      Valid hDispObject.
+ *      pArgs != NULL.
+ *      hNode != NULL.
+ *      pNodeEnv != NULL.
+ *      NODE_GetType(hNode) != NODE_DEVICE.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDispObject,
+					  struct NODE_OBJECT *hNode,
+					  u32 ulFxnAddr,
+					  u32 ulCreateFxn,
+					  IN CONST struct NODE_CREATEARGS
+					  *pArgs,
+					  OUT NODE_ENV *pNodeEnv);
+
+/*
+ *  ======== DISP_NodeDelete ========
+ *  Delete a node on the DSP by remotely calling the node's delete function.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node object representing a node currently
+ *                      loaded on the DSP.
+ *      ulFxnAddr:      Address or RMS delete node function.
+ *      ulDeleteFxn:    Address of node's delete function.
+ *      nodeEnv:        Address of node's environment structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init() called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDispObject,
+					  struct NODE_OBJECT *hNode,
+					  u32 ulFxnAddr,
+					  u32 ulDeleteFxn, NODE_ENV nodeEnv);
+
+/*
+ *  ======== DISP_NodeRun ========
+ *  Start execution of a node's execute phase, or resume execution of a node
+ *  that has been suspended (via DISP_NodePause()) on the DSP.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node object representing a node to be executed
+ *                      on the DSP.
+ *      ulFxnAddr:      Address or RMS node execute function.
+ *      ulExecuteFxn:   Address of node's execute function.
+ *      nodeEnv:        Address of node's environment structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init() called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDispObject,
+				       struct NODE_OBJECT *hNode,
+				       u32 ulFxnAddr,
+				       u32 ulExecuteFxn, NODE_ENV nodeEnv);
+
+#endif				/* DISP_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dmm.h
@@ -0,0 +1,85 @@
+/*
+ * bridge/inc/dmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dmm.h ========
+ *  Purpose:
+ *      The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
+ *      space that can be directly mapped to any MPU buffer or memory region
+ *
+ *  Public Functions:
+ *
+ *! Revision History:
+ *! ================
+ *! 20-Feb-2004 sb: Created.
+ *!
+ */
+
+#ifndef DMM_
+#define DMM_
+
+#include <dbdefs.h>
+
+	struct DMM_OBJECT;
+
+/* DMM attributes used in DMM_Create() */
+	struct DMM_MGRATTRS {
+		u32 reserved;
+	} ;
+
+#define DMMPOOLSIZE      0x4000000
+
+/*
+ *  ======== DMM_GetHandle ========
+ *  Purpose:
+ *      Return the dynamic memory manager object for this device.
+ *      This is typically called from the client process.
+ */
+
+	extern DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
+					OUT struct DMM_OBJECT **phDmmMgr);
+
+	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
+					    u32 size,
+					    u32 *pRsvAddr);
+
+	extern DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr,
+					      u32 rsvAddr);
+
+	extern DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr,
+					u32 size);
+
+	extern DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr,
+					  u32 addr,
+					  u32 *pSize);
+
+	extern DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr);
+
+	extern DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr);
+
+	extern DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     IN CONST struct DMM_MGRATTRS *pMgrAttrs);
+
+	extern bool DMM_Init();
+
+	extern void DMM_Exit();
+
+	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
+						u32 addr, u32 size);
+	extern u32 *DMM_GetPhysicalAddrTable(void);
+#endif				/* DMM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dpc.h
@@ -0,0 +1,167 @@
+/*
+ * bridge/inc/dpc.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dpc.h ========
+ *  Purpose:
+ *      Deferred Procedure Call(DPC) Services.
+ *
+ *  Public Functions:
+ *      DPC_Cancel
+ *      DPC_Create
+ *      DPC_Destroy
+ *      DPC_Exit
+ *      DPC_Init
+ *      DPC_Schedule
+ *
+ *! Revision History:
+ *! ================
+ *! 31-Jan-2000 rr:  DPC_Destroy ensures Suceess and DPC Object is NULL.
+ *! 21-Jan-2000 ag:  Updated comments per code review.
+ *! 06-Jan-2000 ag:  Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
+ *! 14-Jan-1998 gp:  Added DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
+ *! 18-Aug-1997 cr:  Added explicit CDECL identifiers.
+ *! 28-Jul-1996 gp:  Created.
+ */
+
+#ifndef DPC_
+#define DPC_
+
+	struct DPC_OBJECT;
+
+/*
+ *  ======== DPC_PROC ========
+ *  Purpose:
+ *      Deferred processing routine.  Typically scheduled from an ISR to
+ *      complete I/O processing.
+ *  Parameters:
+ *      pRefData:   Ptr to user data: passed in via ISR_ScheduleDPC.
+ *  Returns:
+ *  Requires:
+ *      The DPC should not block, or otherwise acquire resources.
+ *      Interrupts to the processor are enabled.
+ *      DPC_PROC executes in a critical section.
+ *  Ensures:
+ *      This DPC will not be reenterred on the same thread.
+ *      However, the DPC may take hardware interrupts during execution.
+ *      Interrupts to the processor are enabled.
+ */
+       typedef void(*DPC_PROC) (void *pRefData);
+
+/*
+ *  ======== DPC_Cancel ========
+ *  Purpose:
+ *      Cancel a DPC previously scheduled by DPC_Schedule.
+ *  Parameters:
+ *      hDPC:           A DPC object handle created in DPC_Create().
+ *  Returns:
+ *      DSP_SOK:        Scheduled DPC, if any, is cancelled.
+ *      DSP_SFALSE:     No DPC is currently scheduled for execution.
+ *      DSP_EHANDLE:    Invalid hDPC.
+ *  Requires:
+ *  Ensures:
+ *      If the DPC has already executed, is executing, or was not yet
+ *      scheduled, this function will have no effect.
+ */
+       extern DSP_STATUS DPC_Cancel(IN struct DPC_OBJECT *hDPC);
+
+/*
+ *  ======== DPC_Create ========
+ *  Purpose:
+ *      Create a DPC object, allowing a client's own DPC procedure to be
+ *      scheduled for a call with client reference data.
+ *  Parameters:
+ *      phDPC:          Pointer to location to store DPC object.
+ *      pfnDPC:         Client's DPC procedure.
+ *      pRefData:       Pointer to user-defined reference data.
+ *  Returns:
+ *      DSP_SOK:        DPC object created.
+ *      DSP_EPOINTER:   phDPC == NULL or pfnDPC == NULL.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *  Requires:
+ *      Must not be called at interrupt time.
+ *  Ensures:
+ *      DSP_SOK: DPC object is created;
+ *      else: *phDPC is set to NULL.
+ */
+       extern DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC,
+					   IN DPC_PROC pfnDPC,
+					   IN void *pRefData);
+
+/*
+ *  ======== DPC_Destroy ========
+ *  Purpose:
+ *      Cancel the last scheduled DPC, and deallocate a DPC object previously
+ *      allocated with DPC_Create().Frees the Object only if the thread and
+ *      the events are terminated successfuly.
+ *  Parameters:
+ *      hDPC:           A DPC object handle created in DPC_Create().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDPC.
+ *  Requires:
+ *      All DPC's scheduled for the DPC object must have completed their
+ *      processing.
+ *  Ensures:
+ *      (SUCCESS && hDPC is NULL) or DSP_EFAILED status
+ */
+       extern DSP_STATUS DPC_Destroy(IN struct DPC_OBJECT *hDPC);
+
+/*
+ *  ======== DPC_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the DPC module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DPC_Init() was previously called.
+ *  Ensures:
+ *      Resources acquired in DPC_Init() are freed.
+ */
+       extern void DPC_Exit();
+
+/*
+ *  ======== DPC_Init ========
+ *  Purpose:
+ *      Initialize the DPC module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public DPC functions.
+ */
+       extern bool DPC_Init();
+
+/*
+ *  ======== DPC_Schedule ========
+ *  Purpose:
+ *      Schedule a deferred procedure call to be executed at a later time.
+ *      Latency and order of DPC execution is platform specific.
+ *  Parameters:
+ *      hDPC:           A DPC object handle created in DPC_Create().
+ *  Returns:
+ *      DSP_SOK:        An event is scheduled for deferred processing.
+ *      DSP_EHANDLE:    Invalid hDPC.
+ *  Requires:
+ *      See requirements for DPC_PROC.
+ *  Ensures:
+ *      DSP_SOK:        The DPC will not be called before this function returns.
+ */
+       extern DSP_STATUS DPC_Schedule(IN struct DPC_OBJECT *hDPC);
+
+#endif				/* DPC_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
@@ -0,0 +1,34 @@
+/*
+ * bridge/inc/drvdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== drvdefs.h ========
+ *  Purpose:
+ *      Definition of common include typedef between wmd.h and drv.h.
+ *
+ *! Revision History:
+ *! ================
+ *! 17-Jul-2000 rr: Created
+ */
+
+#ifndef DRVDEFS_
+#define DRVDEFS_
+
+/* WCD Driver Object */
+	struct DRV_OBJECT;
+
+#endif				/* DRVDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -0,0 +1,434 @@
+/*
+ * bridge/inc/drv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== drv.h ========
+ *  Purpose:
+ *      DRV Resource allocation module. Driver Object gets Created
+ *      at the time of Loading. It holds the List of Device Objects
+ *      in the Syste,
+ *
+ *  Public Functions:
+ *      DRV_Create
+ *      DRV_Destroy
+ *      DRV_Exit
+ *      DRV_GetDevObject
+ *      DRV_GetDevExtension
+ *      DRV_GetFirstDevObject
+ *      DRV_GetNextDevObject
+ *      DRV_GetNextDevExtension
+ *      DRV_Init
+ *      DRV_InsertDevObject
+ *      DRV_RemoveDevObject
+ *      DRV_RequestResources
+ *      DRV_ReleaseResources
+ *
+ *! Revision History
+ *! ================
+ *! 10-Feb-2004 vp:  Added OMAP24xx specific definitions.
+ *! 14-Aug-2000 rr:  Cleaned up.
+ *! 27-Jul-2000 rr:  DRV_RequestResources split into two(Request and Release)
+ *!                  Device extension created to hold the DevNodeString.
+ *! 17-Jul-2000 rr:  Driver Object holds the list of Device Objects.
+ *!                  Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
+ *!                  DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
+ *! 12-Nov-1999 rr:  New Flag defines for DRV_ASSIGN and DRV_RELEASE
+ *! 25-Oct-1999 rr:  Resource Structure removed.
+ *! 15-Oct-1999 rr:  New Resource structure created.
+ *! 05-Oct-1999 rr:  Added DRV_RequestResources
+ *!                  Removed fxn'sDRV_RegisterMiniDriver(),
+ *!		     DRV_UnRegisterMiniDriver()
+ *!                  Removed Structures DSP_DRIVER & DRV_EXTENSION.
+ *!
+ *! 24-Sep-1999 rr:  Added DRV_EXTENSION and DSP_DRIVER structures.
+ *!
+ */
+
+#ifndef DRV_
+#define DRV_
+
+#include <devdefs.h>
+
+#include <drvdefs.h>
+
+#define DRV_ASSIGN     1
+#define DRV_RELEASE    0
+
+#ifdef CONFIG_ARCH_OMAP3430
+
+/* Provide the DSP Internal memory windows that can be accessed from L3 address
+ * space */
+
+#define OMAP_GEM_BASE   0x107F8000
+#define OMAP_DSP_SIZE   0x00720000
+
+/* MEM1 is L2 RAM + L2 Cache space */
+#define OMAP_DSP_MEM1_BASE 0x5C7F8000
+#define OMAP_DSP_MEM1_SIZE 0x18000
+#define OMAP_DSP_GEM1_BASE 0x107F8000
+
+
+/* MEM2 is L1P RAM/CACHE space */
+#define OMAP_DSP_MEM2_BASE 0x5CE00000
+#define OMAP_DSP_MEM2_SIZE 0x8000
+#define OMAP_DSP_GEM2_BASE 0x10E00000
+
+/* MEM3 is L1D RAM/CACHE space */
+#define OMAP_DSP_MEM3_BASE 0x5CF04000
+#define OMAP_DSP_MEM3_SIZE 0x14000
+#define OMAP_DSP_GEM3_BASE 0x10F04000
+
+
+#define OMAP_IVA2_PRM_BASE 0x48306000
+#define OMAP_IVA2_PRM_SIZE 0x1000
+
+#define OMAP_IVA2_CM_BASE 0x48004000
+#define OMAP_IVA2_CM_SIZE 0x1000
+
+#define OMAP_PER_CM_BASE 0x48005000
+#define OMAP_PER_CM_SIZE 0x1000
+
+#define OMAP_SYSC_BASE 0x48002000
+#define OMAP_SYSC_SIZE 0x1000
+
+#define OMAP_MBOX_BASE 0x48094000
+#define OMAP_MBOX_SIZE 0x1000
+
+#define OMAP_DMMU_BASE 0x5D000000
+#define OMAP_DMMU_SIZE 0x1000
+
+#define OMAP_PRCM_VDD1_DOMAIN 1
+#define OMAP_PRCM_VDD2_DOMAIN 2
+
+#endif
+
+#ifndef RES_CLEANUP_DISABLE
+
+/* GPP PROCESS CLEANUP Data structures */
+
+/* New structure (member of process context) abstracts NODE resource info */
+struct NODE_RES_OBJECT {
+	DSP_HNODE       hNode;
+	s32            nodeAllocated; /* Node status */
+	s32            heapAllocated; /* Heap status */
+	s32            streamsAllocated; /* Streams status */
+	struct NODE_RES_OBJECT         *next;
+} ;
+
+/* New structure (member of process context) abstracts DMM resource info */
+struct DMM_RES_OBJECT {
+	s32            dmmAllocated; /* DMM status */
+	u32           ulMpuAddr;
+	u32           ulDSPAddr;
+	u32           ulDSPResAddr;
+	u32           dmmSize;
+	HANDLE          hProcessor;
+	struct DMM_RES_OBJECT  *next;
+} ;
+
+/* New structure (member of process context) abstracts DMM resource info */
+struct DSPHEAP_RES_OBJECT {
+	s32            heapAllocated; /* DMM status */
+	u32           ulMpuAddr;
+	u32           ulDSPAddr;
+	u32           ulDSPResAddr;
+	u32           heapSize;
+	HANDLE          hProcessor;
+	struct DSPHEAP_RES_OBJECT  *next;
+} ;
+
+/* New structure (member of process context) abstracts stream resource info */
+struct STRM_RES_OBJECT {
+	s32                    streamAllocated; /* Stream status */
+	DSP_HSTREAM             hStream;
+	u32                    uNumBufs;
+	u32                    uDir;
+	struct STRM_RES_OBJECT         *next;
+} ;
+
+/* Overall Bridge process resource usage state */
+enum GPP_PROC_RES_STATE {
+	PROC_RES_ALLOCATED,
+	PROC_RES_FREED
+} ;
+
+/* Process Context */
+struct PROCESS_CONTEXT{
+	/* Process State */
+	enum GPP_PROC_RES_STATE resState;
+
+	/* Process ID (Same as UNIX process ID) */
+	u32 pid;
+
+	/* Pointer to next process context
+	* (To maintain a linked list of process contexts) */
+	struct PROCESS_CONTEXT *next;
+
+	/* Processor info to which the process is related */
+	DSP_HPROCESSOR hProcessor;
+
+	/* DSP Node resources */
+	struct NODE_RES_OBJECT *pNodeList;
+
+	/* DMM resources */
+	struct DMM_RES_OBJECT *pDMMList;
+
+	/* DSP Heap resources */
+	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
+
+	/* Stream resources */
+	struct STRM_RES_OBJECT *pSTRMList;
+} ;
+#endif
+
+/*
+ *  ======== DRV_Create ========
+ *  Purpose:
+ *      Creates the Driver Object. This is done during the driver loading.
+ *      There is only one Driver Object in the DSP/BIOS Bridge.
+ *  Parameters:
+ *      phDrvObject:    Location to store created DRV Object handle.
+ *  Returns:
+ *      DSP_SOK:        Sucess
+ *      DSP_EMEMORY:    Failed in Memory allocation
+ *      DSP_EFAIL:      General Failure
+ *  Requires:
+ *      DRV Initialized (cRefs > 0 )
+ *      phDrvObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        - *phDrvObject is a valid DRV interface to the device.
+ *                      - List of DevObject Created and Initialized.
+ *                      - List of DevNode String created and intialized.
+ *                      - Registry is updated with the DRV Object.
+ *      !DSP_SOK:       DRV Object not created
+ *  Details:
+ *      There is one Driver Object for the Driver representing
+ *      the driver itself. It contains the list of device
+ *      Objects and the list of Device Extensions in the system.
+ *      Also it can hold other neccessary
+ *      information in its storage area.
+ */
+	extern DSP_STATUS DRV_Create(struct DRV_OBJECT **phDrvObject);
+
+/*
+ *  ======== DRV_Destroy ========
+ *  Purpose:
+ *      destroys the Dev Object list, DrvExt list
+ *      and destroy the DRV object
+ *      Called upon driver unLoading.or unsuccesful loading of the driver.
+ *  Parameters:
+ *      hDrvObject:     Handle to Driver object .
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to destroy DRV Object
+ *  Requires:
+ *      DRV Initialized (cRegs > 0 )
+ *      hDrvObject is not NULL and a valid DRV handle .
+ *      List of DevObject is Empty.
+ *      List of DrvExt is Empty
+ *  Ensures:
+ *      DSP_SOK:        - DRV Object destroyed and hDrvObject is not a valid
+ *                        DRV handle.
+ *                      - Registry is updated with "0" as the DRV Object.
+ */
+	extern DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDrvObject);
+
+/*
+ *  ======== DRV_Exit ========
+ *  Purpose:
+ *      Exit the DRV module, freeing any modules initialized in DRV_Init.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+	extern void DRV_Exit();
+
+/*
+ *  ======== DRV_GetFirstDevObject ========
+ *  Purpose:
+ *      Returns the Ptr to the FirstDev Object in the List
+ *  Parameters:
+ *  Requires:
+ *      DRV Initialized
+ *  Returns:
+ *      dwDevObject:  Ptr to the First Dev Object as a u32
+ *      0 if it fails to retrieve the First Dev Object
+ *  Ensures:
+ */
+	extern u32 DRV_GetFirstDevObject();
+
+/*
+ *  ======== DRV_GetFirstDevExtension ========
+ *  Purpose:
+ *      Returns the Ptr to the First Device Extension in the List
+ *  Parameters:
+ *  Requires:
+ *      DRV Initialized
+ *  Returns:
+ *      dwDevExtension:     Ptr to the First Device Extension as a u32
+ *      0:                  Failed to Get the Device Extension
+ *  Ensures:
+ */
+	extern u32 DRV_GetFirstDevExtension();
+
+/*
+ *  ======== DRV_GetDevObject ========
+ *  Purpose:
+ *      Given a index, returns a handle to DevObject from the list
+ *  Parameters:
+ *      hDrvObject:     Handle to the Manager
+ *      phDevObject:    Location to store the Dev Handle
+ *  Requires:
+ *      DRV Initialized
+ *      uIndex >= 0
+ *      hDrvObject is not NULL and Valid DRV Object
+ *      phDevObject is not NULL
+ *      Device Object List not Empty
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EFAIL:      Failed to Get the Dev Object
+ *  Ensures:
+ *      DSP_SOK:        *phDevObject != NULL
+ *      DSP_EFAIL:      *phDevObject = NULL
+ */
+	extern DSP_STATUS DRV_GetDevObject(u32 uIndex,
+					   struct DRV_OBJECT *hDrvObject,
+					   struct DEV_OBJECT **phDevObject);
+
+/*
+ *  ======== DRV_GetNextDevObject ========
+ *  Purpose:
+ *      Returns the Ptr to the Next Device Object from the the List
+ *  Parameters:
+ *      hDevObject:     Handle to the Device Object
+ *  Requires:
+ *      DRV Initialized
+ *      hDevObject != 0
+ *  Returns:
+ *      dwDevObject:    Ptr to the Next Dev Object as a u32
+ *      0:              If it fail to get the next Dev Object.
+ *  Ensures:
+ */
+	extern u32 DRV_GetNextDevObject(u32 hDevObject);
+
+/*
+ *  ======== DRV_GetNextDevExtension ========
+ *  Purpose:
+ *      Returns the Ptr to the Next Device Extension from the the List
+ *  Parameters:
+ *      hDevExtension:      Handle to the Device Extension
+ *  Requires:
+ *      DRV Initialized
+ *      hDevExtension != 0.
+ *  Returns:
+ *      dwDevExtension:     Ptr to the Next Dev Extension
+ *      0:                  If it fail to Get the next Dev Extension
+ *  Ensures:
+ */
+	extern u32 DRV_GetNextDevExtension(u32 hDevExtension);
+
+/*
+ *  ======== DRV_Init ========
+ *  Purpose:
+ *      Initialize the DRV module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS DRV_Init();
+
+/*
+ *  ======== DRV_InsertDevObject ========
+ *  Purpose:
+ *      Insert a DeviceObject into the list of Driver object.
+ *  Parameters:
+ *      hDrvObject:     Handle to DrvObject
+ *      hDevObject:     Handle to DeviceObject to insert.
+ *  Returns:
+ *      DSP_SOK:        If successful.
+ *      DSP_EFAIL:      General Failure:
+ *  Requires:
+ *      hDrvObject != NULL and Valid DRV Handle.
+ *      hDevObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Device Object is inserted and the List is not empty.
+ */
+	extern DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDrvObject,
+					      struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DRV_RemoveDevObject ========
+ *  Purpose:
+ *      Search for and remove a Device object from the given list of Device Obj
+ *      objects.
+ *  Parameters:
+ *      hDrvObject:     Handle to DrvObject
+ *      hDevObject:     Handle to DevObject to Remove
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to find pDevObject.
+ *  Requires:
+ *      hDrvObject != NULL and a Valid DRV Handle.
+ *      hDevObject != NULL.
+ *      List exists and is not empty.
+ *  Ensures:
+ *      List either does not exist (NULL), or is not empty if it does exist.
+*/
+	extern DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDrvObject,
+					      struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DRV_RequestResources ========
+ *  Purpose:
+ *      Assigns the Resources or Releases them.
+ *  Parameters:
+ *      dwContext:          Path to the driver Registry Key.
+ *      pDevNodeString:     Ptr to DevNode String stored in the Device Ext.
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ *      The Resources are assigned based on Bus type.
+ *      The hardware is initialized. Resource information is
+ *      gathered from the Registry(ISA, PCMCIA)or scanned(PCI)
+ *      Resource structure is stored in the registry which will be
+ *      later used by the CFG module.
+ */
+	extern DSP_STATUS DRV_RequestResources(IN u32 dwContext,
+					       OUT u32 *pDevNodeString);
+
+/*
+ *  ======== DRV_ReleaseResources ========
+ *  Purpose:
+ *      Assigns the Resources or Releases them.
+ *  Parameters:
+ *      dwContext:      Path to the driver Registry Key.
+ *      hDrvObject:     Handle to the Driver Object.
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ *      The Resources are released based on Bus type.
+ *      Resource structure is deleted from the registry
+ */
+	extern DSP_STATUS DRV_ReleaseResources(IN u32 dwContext,
+					       struct DRV_OBJECT *hDrvObject);
+
+#endif				/* DRV_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspdrv.h
@@ -0,0 +1,106 @@
+/*
+ * bridge/inc/dspdrv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== dspdrv.h ========
+ *  Purpose:
+ *      This is the Stream Interface for the DDSP Class driver.
+ *      All Device operations are performed via DeviceIOControl.
+ *      Read, Seek and Write not used.
+ *
+ *  Public Functions
+ *      DSP_Close
+ *      DSP_Deinit
+ *      DSP_Init
+ *      DSP_IOControl
+ *      DSP_Open
+ *      DSP_PowerUp
+ *      DSP_PowerDown
+ *
+ *! Revision History
+ *! ================
+ *! 28-Jan-2000 rr: Type void changed to Void.
+ *! 02-Dec-1999 rr: MAX_DEV define moved from wcdce.c file.Code cleaned up.
+ *! 12-Nov-1999 rr: "#include<wncnxerr.h> removed.
+ *! 05-Oct-1999 rr  Renamed the file name to wcdce.h Removed Bus Specific
+ *!                 code and #defines to PCCARD.h.
+ *! 24-Sep-1999 rr  Changed the DSP_COMMON_WINDOW_SIZE to 0x4000(16k) for the
+ *!                 Memory windows.
+ *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet driver.
+ *!
+ */
+
+#if !defined __DSPDRV_h__
+#define __DSPDRV_h__
+
+#define MAX_DEV     10		/* Max support of 10 devices */
+
+/*
+ *  ======== DSP_Close ========
+ *  Purpose:
+ *      Called when the client application/driver unloads the DDSP DLL. Upon
+ *      unloading, the DDSP DLL will call CloseFile().
+ *  Parameters:
+ *      dwDeviceContext:    Handle returned by XXX_Open used to identify
+ *                          the open context of the device
+ *  Returns:
+ *      TRUE indicates the device is successfully closed. FALSE indicates
+ *      otherwise.
+ *  Requires:
+ *      dwOpenContext!= NULL.
+ *  Ensures:The Application instance owned objects are cleaned up.
+ */
+extern bool DSP_Close(u32 dwDeviceContext);
+
+/*
+ *  ======== DSP_Deinit ========
+ *  Purpose:
+ *      This function is called by Device Manager to de-initialize a device.
+ *      This function is not called by applications.
+ *  Parameters:
+ *      dwDeviceContext:Handle to the device context. The XXX_Init function
+ *      creates and returns this identifier.
+ *  Returns:
+ *      TRUE indicates the device successfully de-initialized. Otherwise it
+ *      returns FALSE.
+ *  Requires:
+ *      dwDeviceContext!= NULL. For a built in device this should never
+ *      get called.
+ *  Ensures:
+ */
+extern bool DSP_Deinit(u32 dwDeviceContext);
+
+/*
+ *  ======== DSP_Init ========
+ *  Purpose:
+ *      This function is called by Device Manager to initialize a device.
+ *      This function is not called by applications
+ *  Parameters:
+ *      dwContext:  Specifies a pointer to a string containing the registry
+ *                  path to the active key for the stream interface driver.
+ *                  HKEY_LOCAL_MACHINE\Drivers\Active
+ *  Returns:
+ *      Returns a handle to the device context created. This is the our actual
+ *      Device Object representing the DSP Device instance.
+ *  Requires:
+ *  Ensures:
+ *      Succeeded:  device context > 0
+ *      Failed:     device Context = 0
+ */
+extern u32 DSP_Init(OUT u32 *initStatus);
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
@@ -0,0 +1,505 @@
+/*
+ * bridge/inc/dynamic_loader.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef _DYNAMIC_LOADER_H_
+#define _DYNAMIC_LOADER_H_
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/*
+ * Dynamic Loader
+ *
+ * The function of the dynamic loader is to load a "module" containing
+ * instructions for a "target" processor into that processor.  In the process
+ * it assigns memory for the module, resolves symbol references made by the
+ * module, and remembers symbols defined by the module.
+ *
+ * The dynamic loader is parameterized for a particular system by 4 classes
+ * that supply the module and system specific functions it requires
+ */
+	/* The read functions for the module image to be loaded */
+	struct Dynamic_Loader_Stream;
+
+	/* This class defines "host" symbol and support functions */
+	struct Dynamic_Loader_Sym;
+
+	/* This class defines the allocator for "target" memory */
+	struct Dynamic_Loader_Allocate;
+
+	/* This class defines the copy-into-target-memory functions */
+	struct Dynamic_Loader_Initialize;
+
+/*
+ * Option flags to modify the behavior of module loading
+ */
+#define DLOAD_INITBSS 0x1	/* initialize BSS sections to zero */
+#define DLOAD_BIGEND 0x2	/* require big-endian load module */
+#define DLOAD_LITTLE 0x4	/* require little-endian load module */
+
+	typedef void *DLOAD_mhandle;	/* module handle for loaded modules */
+
+/*****************************************************************************
+ * Procedure Dynamic_Load_Module
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *  init    Target-side memory initialization, or NULL for symbol read only
+ *  options Option flags DLOAD_*
+ *  mhandle A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *  The module image is read using *module.  Target storage for the new image is
+ * obtained from *alloc.  Symbols defined and referenced by the module are
+ * managed using *syms.  The image is then relocated and references resolved
+ * as necessary, and the resulting executable bits are placed into target memory
+ * using *init.
+ *
+ * Returns:
+ *  On a successful load, a module handle is placed in *mhandle, and zero is
+ * returned.  On error, the number of errors detected is returned.  Individual
+ * errors are reported during the load process using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Load_Module(
+				       /* the source for the module image*/
+				       struct Dynamic_Loader_Stream *module,
+				       /* host support for symbols and storage*/
+				       struct Dynamic_Loader_Sym *syms,
+				       /* the target memory allocator*/
+				       struct Dynamic_Loader_Allocate *alloc,
+				       /* the target memory initializer*/
+				       struct Dynamic_Loader_Initialize *init,
+				       unsigned options,       /* option flags*/
+				       /* the returned module handle*/
+				       DLOAD_mhandle *mhandle
+	    );
+
+/*****************************************************************************
+ * Procedure Dynamic_Open_Module
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *  init    Target-side memory initialization, or NULL for symbol read only
+ *  options Option flags DLOAD_*
+ *  mhandle A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *  The module image is read using *module.  Target storage for the new image is
+ * obtained from *alloc.  Symbols defined and referenced by the module are
+ * managed using *syms.  The image is then relocated and references resolved
+ * as necessary, and the resulting executable bits are placed into target memory
+ * using *init.
+ *
+ * Returns:
+ *  On a successful load, a module handle is placed in *mhandle, and zero is
+ * returned.  On error, the number of errors detected is returned.  Individual
+ * errors are reported during the load process using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Open_Module(
+				      /* the source for the module image */
+				      struct Dynamic_Loader_Stream *module,
+				      /* host support for symbols and storage */
+				      struct Dynamic_Loader_Sym *syms,
+				      /* the target memory allocator */
+				      struct Dynamic_Loader_Allocate *alloc,
+				      /* the target memory initializer */
+				      struct Dynamic_Loader_Initialize *init,
+				      unsigned options, /* option flags */
+				      /* the returned module handle */
+				      DLOAD_mhandle *mhandle
+	);
+
+/*****************************************************************************
+ * Procedure Dynamic_Unload_Module
+ *
+ * Parameters:
+ *  mhandle A module handle from Dynamic_Load_Module
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *
+ * Effect:
+ *  The module specified by mhandle is unloaded.  Unloading causes all
+ * target memory to be deallocated, all symbols defined by the module to
+ * be purged, and any host-side storage used by the dynamic loader for
+ * this module to be released.
+ *
+ * Returns:
+ *  Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Unload_Module(DLOAD_mhandle mhandle,	/* the module
+								 * handle*/
+					 /* host support for symbols and
+					  * storage */
+					 struct Dynamic_Loader_Sym *syms,
+					 /* the target memory allocator*/
+					 struct Dynamic_Loader_Allocate *alloc,
+					 /* the target memory initializer*/
+					 struct Dynamic_Loader_Initialize *init
+	    );
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader for input of the module image
+ *****************************************************************************
+ *****************************************************************************/
+	struct Dynamic_Loader_Stream {
+/* public: */
+    /*************************************************************************
+     * read_buffer
+     *
+     * PARAMETERS :
+     *  buffer  Pointer to the buffer to fill
+     *  bufsiz  Amount of data desired in sizeof() units
+     *
+     * EFFECT :
+     *  Reads the specified amount of data from the module input stream
+     * into the specified buffer.  Returns the amount of data read in sizeof()
+     * units (which if less than the specification, represents an error).
+     *
+     * NOTES:
+     *  In release 1 increments the file position by the number of bytes read
+     *
+     *************************************************************************/
+		int (*read_buffer) (struct Dynamic_Loader_Stream *thisptr,
+				    void *buffer, unsigned bufsiz);
+
+    /*************************************************************************
+     * set_file_posn (release 1 only)
+     *
+     * PARAMETERS :
+     *  posn  Desired file position relative to start of file in sizeof() units.
+     *
+     * EFFECT :
+     *  Adjusts the internal state of the stream object so that the next
+     * read_buffer call will begin to read at the specified offset from
+     * the beginning of the input module.  Returns 0 for success, non-zero
+     * for failure.
+     *
+     *************************************************************************/
+		int (*set_file_posn) (struct Dynamic_Loader_Stream *thisptr,
+					/* to be eliminated in release 2*/
+					unsigned int posn);
+
+	};
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader for symbol table support and
+ * miscellaneous host-side functions
+ *****************************************************************************
+ *****************************************************************************/
+
+	typedef u32 LDR_ADDR;
+
+/*
+ * the structure of a symbol known to the dynamic loader
+ */
+	struct dynload_symbol {
+		LDR_ADDR value;
+	} ;
+
+	struct Dynamic_Loader_Sym {
+/* public: */
+    /*************************************************************************
+     * Find_Matching_Symbol
+     *
+     * PARAMETERS :
+     *  name    The name of the desired symbol
+     *
+     * EFFECT :
+     *  Locates a symbol matching the name specified.  A pointer to the
+     * symbol is returned if it exists; 0 is returned if no such symbol is
+     * found.
+     *
+     *************************************************************************/
+		struct dynload_symbol *(*Find_Matching_Symbol)
+			(struct Dynamic_Loader_Sym *
+							 thisptr,
+							 const char *name);
+
+    /*************************************************************************
+     * Add_To_Symbol_Table
+     *
+     * PARAMETERS :
+     *  nname       Pointer to the name of the new symbol
+     *  moduleid    An opaque module id assigned by the dynamic loader
+     *
+     * EFFECT :
+     *  The new symbol is added to the table.  A pointer to the symbol is
+     * returned, or NULL is returned for failure.
+     *
+     * NOTES:
+     *  It is permissible for this function to return NULL; the effect is that
+     * the named symbol will not be available to resolve references in
+     * subsequent loads.  Returning NULL will not cause the current load
+     * to fail.
+     *************************************************************************/
+		struct dynload_symbol *(*Add_To_Symbol_Table)
+						(struct Dynamic_Loader_Sym *
+							thisptr,
+							const char *nname,
+							unsigned moduleid);
+
+    /*************************************************************************
+     * Purge_Symbol_Table
+     *
+     * PARAMETERS :
+     *  moduleid    An opaque module id assigned by the dynamic loader
+     *
+     * EFFECT :
+     *  Each symbol in the symbol table whose moduleid matches the argument
+     * is removed from the table.
+     *************************************************************************/
+		void (*Purge_Symbol_Table) (struct Dynamic_Loader_Sym *thisptr,
+					    unsigned moduleid);
+
+    /*************************************************************************
+     * Allocate
+     *
+     * PARAMETERS :
+     *  memsiz  size of desired memory in sizeof() units
+     *
+     * EFFECT :
+     *  Returns a pointer to some "host" memory for use by the dynamic
+     * loader, or NULL for failure.
+     * This function is serves as a replaceable form of "malloc" to
+     * allow the user to configure the memory usage of the dynamic loader.
+     *************************************************************************/
+		void *(*Allocate) (struct Dynamic_Loader_Sym *thisptr,
+				   unsigned memsiz);
+
+    /*************************************************************************
+     * Deallocate
+     *
+     * PARAMETERS :
+     *  memptr  pointer to previously allocated memory
+     *
+     * EFFECT :
+     *  Releases the previously allocated "host" memory.
+     *************************************************************************/
+		void (*Deallocate) (struct Dynamic_Loader_Sym *thisptr,
+				    void *memptr);
+
+    /*************************************************************************
+     * Error_Report
+     *
+     * PARAMETERS :
+     *  errstr  pointer to an error string
+     *  args    additional arguments
+     *
+     * EFFECT :
+     *  This function provides an error reporting interface for the dynamic
+     * loader.  The error string and arguments are designed as for the
+     * library function vprintf.
+     *************************************************************************/
+		void (*Error_Report) (struct Dynamic_Loader_Sym *thisptr,
+				      const char *errstr, va_list args);
+
+	};			/* class Dynamic_Loader_Sym */
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader to allocate and deallocate target memory.
+ *****************************************************************************
+ *****************************************************************************/
+
+	struct LDR_SECTION_INFO {
+		/* Name of the memory section assigned at build time */
+		const char *name;
+		LDR_ADDR run_addr;	/* execution address of the section */
+		LDR_ADDR load_addr;	/* load address of the section */
+		LDR_ADDR size;	/* size of the section in addressable units */
+#ifndef _BIG_ENDIAN
+		u16 page;	/* memory page or view */
+		u16 type;	/* one of the section types below */
+#else
+		u16 type;	/* one of the section types below */
+		u16 page;	/* memory page or view */
+#endif
+		/* a context field for use by Dynamic_Loader_Allocate;
+		 *   ignored but maintained by the dynamic loader */
+		u32 context;
+	} ;
+
+/* use this macro to extract type of section from LDR_SECTION_INFO.type field */
+#define DLOAD_SECTION_TYPE(typeinfo) (typeinfo & 0xF)
+
+/* type of section to be allocated */
+#define DLOAD_TEXT 0
+#define DLOAD_DATA 1
+#define DLOAD_BSS 2
+	/* internal use only, run-time cinit will be of type DLOAD_DATA */
+#define DLOAD_CINIT 3
+
+	struct Dynamic_Loader_Allocate {
+/* public: */
+
+    /*************************************************************************
+    * Function allocate
+    *
+    * Parameters:
+    *   info        A pointer to an information block for the section
+    *   align       The alignment of the storage in target AUs
+    *
+    * Effect:
+    *   Allocates target memory for the specified section and fills in the
+    * load_addr and run_addr fields of the section info structure. Returns TRUE
+    * for success, FALSE for failure.
+    *
+    * Notes:
+    *   Frequently load_addr and run_addr are the same, but if they are not
+    * load_addr is used with Dynamic_Loader_Initialize, and run_addr is
+    * used for almost all relocations.  This function should always initialize
+    * both fields.
+    *************************************************************************/
+		int (*Allocate) (struct Dynamic_Loader_Allocate *thisptr,
+				 struct LDR_SECTION_INFO *info, unsigned align);
+
+    /*************************************************************************
+    * Function deallocate
+    *
+    * Parameters:
+    *   info        A pointer to an information block for the section
+    *
+    * Effect:
+    *   Releases the target memory previously allocated.
+    *
+    * Notes:
+    * The content of the info->name field is undefined on call to this function.
+    *************************************************************************/
+		void (*Deallocate) (struct Dynamic_Loader_Allocate *thisptr,
+				    struct LDR_SECTION_INFO *info);
+
+	};			/* class Dynamic_Loader_Allocate */
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader to load data into a target.  This class
+ * provides the interface-specific functions needed to load data.
+ *****************************************************************************
+ *****************************************************************************/
+
+	struct Dynamic_Loader_Initialize {
+/* public: */
+    /*************************************************************************
+    * Function connect
+    *
+    * Parameters:
+    *   none
+    *
+    * Effect:
+    *   Connect to the initialization interface. Returns TRUE for success,
+    * FALSE for failure.
+    *
+    * Notes:
+    *   This function is called prior to use of any other functions in
+    * this interface.
+    *************************************************************************/
+		int (*connect) (struct Dynamic_Loader_Initialize *thisptr);
+
+    /*************************************************************************
+    * Function readmem
+    *
+    * Parameters:
+    *   bufr        Pointer to a word-aligned buffer for the result
+    *   locn        Target address of first data element
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be read in sizeof() units
+    *
+    * Effect:
+    *   Fills the specified buffer with data from the target.  Returns TRUE for
+    * success, FALSE for failure.
+    *************************************************************************/
+		int (*readmem) (struct Dynamic_Loader_Initialize *thisptr,
+				void *bufr,
+				LDR_ADDR locn,
+				struct LDR_SECTION_INFO *info,
+				unsigned bytsiz);
+
+    /*************************************************************************
+    * Function writemem
+    *
+    * Parameters:
+    *   bufr        Pointer to a word-aligned buffer of data
+    *   locn        Target address of first data element to be written
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be written in sizeof() units
+    *
+    * Effect:
+    *   Writes the specified buffer to the target.  Returns TRUE for success,
+    * FALSE for failure.
+    *************************************************************************/
+		int (*writemem) (struct Dynamic_Loader_Initialize *thisptr,
+				 void *bufr,
+				 LDR_ADDR locn,
+				 struct LDR_SECTION_INFO *info,
+				 unsigned bytsiz);
+
+    /*************************************************************************
+    * Function fillmem
+    *
+    * Parameters:
+    *   locn        Target address of first data element to be written
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be written in sizeof() units
+    *   val         Value to be written in each byte
+    * Effect:
+    *   Fills the specified area of target memory.  Returns TRUE for success,
+    * FALSE for failure.
+    *************************************************************************/
+		int (*fillmem) (struct Dynamic_Loader_Initialize *thisptr,
+				LDR_ADDR locn, struct LDR_SECTION_INFO *info,
+				unsigned bytsiz, unsigned val);
+
+    /*************************************************************************
+    * Function execute
+    *
+    * Parameters:
+    *   start       Starting address
+    *
+    * Effect:
+    *   The target code at the specified starting address is executed.
+    *
+    * Notes:
+    *   This function is called at the end of the dynamic load process
+    * if the input module has specified a starting address.
+    *************************************************************************/
+		int (*execute) (struct Dynamic_Loader_Initialize *thisptr,
+				LDR_ADDR start);
+
+    /*************************************************************************
+    * Function release
+    *
+    * Parameters:
+    *   none
+    *
+    * Effect:
+    *   Releases the connection to the load interface.
+    *
+    * Notes:
+    *   This function is called at the end of the dynamic load process.
+    *************************************************************************/
+		void (*release) (struct Dynamic_Loader_Initialize *thisptr);
+
+	};			/* class Dynamic_Loader_Initialize */
+
+#endif				/* _DYNAMIC_LOADER_H_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/errbase.h
@@ -0,0 +1,509 @@
+/*
+ * bridge/inc/errbase.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== errbase.h ========
+ *  Description:
+ *      Central repository for DSP/BIOS Bridge error and status code.
+ *
+ *  Error codes are of the form:
+ *      [<MODULE>]_E<ERRORCODE>
+ *
+ *  Success codes are of the form:
+ *      [<MODULE>]_S<SUCCESSCODE>
+ *
+ *! Revision History:
+ *! ================
+ *! 24-Jan-2003 map Added DSP_SALREADYLOADED for persistent library checking
+ *! 23-Nov-2002 gp: Minor comment cleanup.
+ *! 13-May-2002 sg  Added DSP_SALREADYASLEEP and DSP_SALREADYWAKE.
+ *! 18-Feb-2002 mk: Added DSP_EOVERLAYMEMORY, EFWRITE, ENOSECT.
+ *! 31-Jan-2002 mk: Added definitions of DSP_STRUE and DSP_SFALSE.
+ *! 29-Jan-2002 mk: Added definition of CFG_E_INSUFFICIENTBUFSIZE.
+ *! 24-Oct-2001 sp: Consolidated all the error codes into this file.
+ *! 24-Jul-2001 mk: Type-casted all definitions of WSX_STATUS types for
+ *!                 removal of compile warnings.
+ *! 22-Nov-1999 kc: Changes from code review.
+ *! 18-Aug-1999 rr: Ported From WSX.
+ *! 29-May-1996 gp: Removed WCD_ and WMD_ error ranges. Redefined format of
+ *!                 error codes.
+ *! 10-May-1996 gp: Created.
+ */
+
+#ifndef ERRBASE_
+#define ERRBASE_
+
+/* Base of generic errors and component errors */
+#define DSP_SBASE               (DSP_STATUS)0x00008000
+#define DSP_EBASE               (DSP_STATUS)0x80008000
+
+#define DSP_COMP_EBASE          (DSP_STATUS)0x80040200
+#define DSP_COMP_ELAST          (DSP_STATUS)0x80047fff
+
+/* SUCCESS Codes */
+
+/* Generic success code */
+#define DSP_SOK                     (DSP_SBASE + 0)
+
+/* GPP is already attached to this DSP processor */
+#define DSP_SALREADYATTACHED        (DSP_SBASE + 1)
+
+/* This is the last object available for enumeration. */
+#define DSP_SENUMCOMPLETE           (DSP_SBASE + 2)
+
+/* The DSP is already asleep. */
+#define DSP_SALREADYASLEEP          (DSP_SBASE + 3)
+
+/* The DSP is already awake. */
+#define DSP_SALREADYAWAKE           (DSP_SBASE + 4)
+
+/* TRUE */
+#define DSP_STRUE                   (DSP_SBASE + 5)
+
+/* FALSE */
+#define DSP_SFALSE                  (DSP_SBASE + 6)
+
+/* A library contains no dependent library references */
+#define DSP_SNODEPENDENTLIBS        (DSP_SBASE + 7)
+
+/* A persistent library is already loaded by the dynamic loader */
+#define DSP_SALREADYLOADED          (DSP_SBASE + 8)
+
+/* Some error occured, but it is OK to continue */
+#define DSP_OKTO_CONTINUE          (DSP_SBASE + 9)
+
+/* FAILURE Codes */
+
+/* The caller does not have access privileges to call this function */
+#define DSP_EACCESSDENIED           (DSP_EBASE + 0)
+
+/* The Specified Connection already exists */
+#define DSP_EALREADYCONNECTED       (DSP_EBASE + 1)
+
+/* The GPP must be detached from the DSP before this function is called */
+#define DSP_EATTACHED               (DSP_EBASE + 2)
+
+/* During enumeration a change in the number or properties of the objects
+ * has occurred. */
+#define DSP_ECHANGEDURINGENUM       (DSP_EBASE + 3)
+
+/* An error occurred while parsing the DSP executable file */
+#define DSP_ECORRUPTFILE            (DSP_EBASE + 4)
+
+/* A failure occurred during a delete operation */
+#define DSP_EDELETE                 (DSP_EBASE + 5)
+
+/* The specified direction is invalid */
+#define DSP_EDIRECTION              (DSP_EBASE + 6)
+
+/* A stream has been issued the maximum number of buffers allowed in the
+ * stream at once ;  buffers must be reclaimed from the stream before any
+ * more can be issued. */
+#define DSP_ESTREAMFULL             (DSP_EBASE + 7)
+
+/* A general failure occurred */
+#define DSP_EFAIL                   (DSP_EBASE + 8)
+
+/* The specified executable file could not be found. */
+#define DSP_EFILE                   (DSP_EBASE + 9)
+
+/* The specified handle is invalid. */
+#define DSP_EHANDLE                 (DSP_EBASE + 0xa)
+
+/* An invalid argument was specified. */
+#define DSP_EINVALIDARG             (DSP_EBASE + 0xb)
+
+/* A memory allocation failure occurred. */
+#define DSP_EMEMORY                 (DSP_EBASE + 0xc)
+
+/* The requested operation is invalid for this node type. */
+#define DSP_ENODETYPE               (DSP_EBASE + 0xd)
+
+/* No error text was found for the specified error code. */
+#define DSP_ENOERRTEXT              (DSP_EBASE + 0xe)
+
+/* No more connections can be made for this node. */
+#define DSP_ENOMORECONNECTIONS      (DSP_EBASE + 0xf)
+
+/* The indicated operation is not supported. */
+#define DSP_ENOTIMPL                (DSP_EBASE + 0x10)
+
+/* I/O is currently pending. */
+#define DSP_EPENDING                (DSP_EBASE + 0x11)
+
+/* An invalid pointer was specified. */
+#define DSP_EPOINTER                (DSP_EBASE + 0x12)
+
+/* A parameter is specified outside its valid range. */
+#define DSP_ERANGE                  (DSP_EBASE + 0x13)
+
+/* An invalid size parameter was specified. */
+#define DSP_ESIZE                   (DSP_EBASE + 0x14)
+
+/* A stream creation failure occurred on the DSP. */
+#define DSP_ESTREAM                 (DSP_EBASE + 0x15)
+
+/* A task creation failure occurred on the DSP. */
+#define DSP_ETASK                   (DSP_EBASE + 0x16)
+
+/* A timeout occurred before the requested operation could complete. */
+
+#define DSP_ETIMEOUT                (DSP_EBASE + 0x17)
+
+/* A data truncation occurred, e.g., when requesting a descriptive error
+ * string, not enough space was allocated for the complete error message. */
+
+#define DSP_ETRUNCATED              (DSP_EBASE + 0x18)
+
+/* A parameter is invalid. */
+#define DSP_EVALUE                  (DSP_EBASE + 0x1a)
+
+/* The state of the specified object is incorrect for the requested
+ * operation. */
+#define DSP_EWRONGSTATE             (DSP_EBASE + 0x1b)
+
+/* Symbol not found in the COFF file.  DSPNode_Create will return this if
+ * the iAlg function table for an xDAIS socket is not found in the COFF file.
+ * In this case, force the symbol to be linked into the COFF file.
+ * DSPNode_Create, DSPNode_Execute, and DSPNode_Delete will return this if
+ * the create, execute, or delete phase function, respectively, could not be
+ * found in the COFF file. */
+#define DSP_ESYMBOL                 (DSP_EBASE + 0x1c)
+
+/* UUID not found in registry.  */
+#define DSP_EUUID                   (DSP_EBASE + 0x1d)
+
+/* Unable to read content of DCD data section ; this is typically caused by
+ * improperly configured nodes. */
+#define DSP_EDCDREADSECT            (DSP_EBASE + 0x1e)
+
+/* Unable to decode DCD data section content ; this is typically caused by
+ * changes to DSP/BIOS Bridge data structures. */
+#define DSP_EDCDPARSESECT           (DSP_EBASE + 0x1f)
+
+/* Unable to get pointer to DCD data section ; this is typically caused by
+ * improperly configured UUIDs. */
+#define DSP_EDCDGETSECT             (DSP_EBASE + 0x20)
+
+/* Unable to load file containing DCD data section ; this is typically
+ * caused by a missing COFF file. */
+#define DSP_EDCDLOADBASE            (DSP_EBASE + 0x21)
+
+/* The specified COFF file does not contain a valid node registration
+ * section. */
+#define DSP_EDCDNOAUTOREGISTER      (DSP_EBASE + 0x22)
+
+/* A requested resource is not available. */
+#define DSP_ERESOURCE               (DSP_EBASE + 0x28)
+
+/* A critical error has occurred, and the DSP is being re-started. */
+#define DSP_ERESTART                (DSP_EBASE + 0x29)
+
+/* A DSP memory free operation failed. */
+#define DSP_EFREE                   (DSP_EBASE + 0x2a)
+
+/* A DSP I/O free operation failed. */
+#define DSP_EIOFREE                 (DSP_EBASE + 0x2b)
+
+/* Multiple instances are not allowed. */
+#define DSP_EMULINST                (DSP_EBASE + 0x2c)
+
+/* A specified entity was not found.  */
+#define DSP_ENOTFOUND               (DSP_EBASE + 0x2d)
+
+/* A DSP I/O resource is not available. */
+#define DSP_EOUTOFIO                (DSP_EBASE + 0x2e)
+
+/* A shared memory buffer contained in a message or stream could not be
+ * mapped to the GPP client process's virtual space. */
+#define DSP_ETRANSLATE              (DSP_EBASE + 0x2f)
+
+/* File or section load write function failed to write to DSP */
+#define DSP_EFWRITE                 (DSP_EBASE + 0x31)
+
+/* Unable to find a named section in DSP executable */
+#define DSP_ENOSECT                 (DSP_EBASE + 0x32)
+
+/* Unable to open file */
+#define DSP_EFOPEN                  (DSP_EBASE + 0x33)
+
+/* Unable to read file */
+#define DSP_EFREAD                  (DSP_EBASE + 0x34)
+
+/* A non-existent memory segment identifier was specified */
+#define DSP_EOVERLAYMEMORY          (DSP_EBASE + 0x37)
+
+/* Invalid segment ID */
+#define DSP_EBADSEGID               (DSP_EBASE + 0x38)
+
+/* Invalid alignment */
+#define DSP_EALIGNMENT               (DSP_EBASE + 0x39)
+
+/* Invalid stream mode */
+#define DSP_ESTRMMODE               (DSP_EBASE + 0x3a)
+
+/* Nodes not connected */
+#define DSP_ENOTCONNECTED           (DSP_EBASE + 0x3b)
+
+/* Not shared memory */
+#define DSP_ENOTSHAREDMEM           (DSP_EBASE + 0x3c)
+
+/* Error occurred in a dynamic loader library function */
+#define DSP_EDYNLOAD                (DSP_EBASE + 0x3d)
+
+/* Device in 'sleep/suspend' mode due to DPM */
+#define DSP_EDPMSUSPEND             (DSP_EBASE + 0x3e)
+
+/* A node-specific error has occurred. */
+#define DSP_EUSER1                  (DSP_EBASE + 0x40)
+#define DSP_EUSER2                  (DSP_EBASE + 0x41)
+#define DSP_EUSER3                  (DSP_EBASE + 0x42)
+#define DSP_EUSER4                  (DSP_EBASE + 0x43)
+#define DSP_EUSER5                  (DSP_EBASE + 0x44)
+#define DSP_EUSER6                  (DSP_EBASE + 0x45)
+#define DSP_EUSER7                  (DSP_EBASE + 0x46)
+#define DSP_EUSER8                  (DSP_EBASE + 0x47)
+#define DSP_EUSER9                  (DSP_EBASE + 0x48)
+#define DSP_EUSER10                 (DSP_EBASE + 0x49)
+#define DSP_EUSER11                 (DSP_EBASE + 0x4a)
+#define DSP_EUSER12                 (DSP_EBASE + 0x4b)
+#define DSP_EUSER13                 (DSP_EBASE + 0x4c)
+#define DSP_EUSER14                 (DSP_EBASE + 0x4d)
+#define DSP_EUSER15                 (DSP_EBASE + 0x4e)
+#define DSP_EUSER16                 (DSP_EBASE + 0x4f)
+
+/* FAILURE Codes : DEV */
+#define DEV_EBASE                   (DSP_COMP_EBASE + 0x000)
+
+/* The mini-driver expected a newer version of the class driver. */
+#define DEV_E_NEWWMD                (DEV_EBASE + 0x00)
+
+/* WMD_DRV_Entry function returned a NULL function interface table. */
+#define DEV_E_NULLWMDINTF           (DEV_EBASE + 0x01)
+
+/* FAILURE Codes : LDR */
+#define LDR_EBASE                   (DSP_COMP_EBASE + 0x100)
+
+/* Insufficient memory to export class driver services. */
+#define LDR_E_NOMEMORY              (LDR_EBASE + 0x00)
+
+/* Unable to find WMD file in system directory. */
+#define LDR_E_FILEUNABLETOOPEN      (LDR_EBASE + 0x01)
+
+/* FAILURE Codes : CFG */
+#define CFG_EBASE                   (DSP_COMP_EBASE + 0x200)
+
+/* Invalid pointer passed into a configuration module function */
+#define CFG_E_INVALIDPOINTER        (CFG_EBASE + 0x00)
+
+/* Invalid device node handle passed into a configuration module function. */
+#define CFG_E_INVALIDHDEVNODE       (CFG_EBASE + 0x01)
+
+/* Unable to retrieve resource information from the registry. */
+#define CFG_E_RESOURCENOTAVAIL      (CFG_EBASE + 0x02)
+
+/* Unable to find board name key in registry. */
+#define CFG_E_INVALIDBOARDNAME      (CFG_EBASE + 0x03)
+
+/* Unable to find a device node in registry with given unit number. */
+#define CFG_E_INVALIDUNITNUM        (CFG_EBASE + 0x04)
+
+/* Insufficient buffer size */
+#define CFG_E_INSUFFICIENTBUFSIZE   (CFG_EBASE + 0x05)
+
+/* FAILURE Codes : BRD */
+#define BRD_EBASE                   (DSP_COMP_EBASE + 0x300)
+
+/* Board client does not have sufficient access rights for this operation. */
+#define BRD_E_ACCESSDENIED          (BRD_EBASE + 0x00)
+
+/* Unable to find trace buffer symbols in the DSP executable COFF file. */
+#define BRD_E_NOTRACEBUFFER         (BRD_EBASE + 0x01)
+
+/* Attempted to auto-start board, but no default DSP executable configured. */
+#define BRD_E_NOEXEC                (BRD_EBASE + 0x02)
+
+/* The operation failed because it was started from a wrong state */
+#define BRD_E_WRONGSTATE            (BRD_EBASE + 0x03)
+
+/* FAILURE Codes : COD */
+#define COD_EBASE                   (DSP_COMP_EBASE + 0x400)
+
+/* No symbol table is loaded for this board. */
+#define COD_E_NOSYMBOLSLOADED       (COD_EBASE + 0x00)
+
+/* Symbol not found in for this board. */
+#define COD_E_SYMBOLNOTFOUND        (COD_EBASE + 0x01)
+
+/* ZL DLL module is not exporting the correct function interface. */
+#define COD_E_NOZLFUNCTIONS         (COD_EBASE + 0x02)
+
+/* Unable to initialize the ZL COFF parsing module. */
+#define COD_E_ZLCREATEFAILED        (COD_EBASE + 0x03)
+
+/* Unable to open DSP executable COFF file. */
+#define COD_E_OPENFAILED            (COD_EBASE + 0x04)
+
+/* Unable to parse DSP executable COFF file. */
+#define COD_E_LOADFAILED            (COD_EBASE + 0x05)
+
+/* Unable to read DSP executable COFF file. */
+#define COD_E_READFAILED            (COD_EBASE + 0x06)
+
+/* FAILURE Codes : CHNL */
+#define CHNL_EBASE                  (DSP_COMP_EBASE + 0x500)
+
+/* Attempt to created channel manager with too many channels. */
+#define CHNL_E_MAXCHANNELS          (CHNL_EBASE + 0x00)
+
+/* No channel manager exists for this mini-driver. */
+#define CHNL_E_NOMGR                (CHNL_EBASE + 0x01)
+
+/* No free channels are available. */
+#define CHNL_E_OUTOFSTREAMS         (CHNL_EBASE + 0x02)
+
+/* Channel ID is out of range. */
+#define CHNL_E_BADCHANID            (CHNL_EBASE + 0x03)
+
+/* Channel is already in use. */
+#define CHNL_E_CHANBUSY             (CHNL_EBASE + 0x04)
+
+/* Invalid channel mode argument. */
+#define CHNL_E_BADMODE              (CHNL_EBASE + 0x05)
+
+/* dwTimeOut parameter was CHNL_IOCNOWAIT, yet no I/O completions were
+ * queued. */
+#define CHNL_E_NOIOC                (CHNL_EBASE + 0x06)
+
+/* I/O has been cancelled on this channel. */
+#define CHNL_E_CANCELLED            (CHNL_EBASE + 0x07)
+
+/* End of stream was already requested on this output channel. */
+#define CHNL_E_EOS                  (CHNL_EBASE + 0x09)
+
+/* Unable to create the channel event object. */
+#define CHNL_E_CREATEEVENT          (CHNL_EBASE + 0x0A)
+
+/* Board name and unit number do not identify a valid board name. */
+#define CHNL_E_BRDID                (CHNL_EBASE + 0x0B)
+
+/* Invalid IRQ configured for this WMD for this system. */
+#define CHNL_E_INVALIDIRQ           (CHNL_EBASE + 0x0C)
+
+/* DSP word size of zero configured for this device. */
+#define CHNL_E_INVALIDWORDSIZE      (CHNL_EBASE + 0x0D)
+
+/* A zero length memory base was specified for a shared memory class driver. */
+#define CHNL_E_INVALIDMEMBASE       (CHNL_EBASE + 0x0E)
+
+/* Memory map is not configured, or unable to map physical to linear
+ * address. */
+#define CHNL_E_NOMEMMAP             (CHNL_EBASE + 0x0F)
+
+/* Attempted to create a channel manager  when one already exists. */
+#define CHNL_E_MGREXISTS            (CHNL_EBASE + 0x10)
+
+/* Unable to plug channel ISR for configured IRQ. */
+#define CHNL_E_ISR                  (CHNL_EBASE + 0x11)
+
+/* No free I/O request packets are available. */
+#define CHNL_E_NOIORPS              (CHNL_EBASE + 0x12)
+
+/* Buffer size is larger than the size of physical channel. */
+#define CHNL_E_BUFSIZE              (CHNL_EBASE + 0x13)
+
+/* User cannot mark end of stream on an input channel. */
+#define CHNL_E_NOEOS                (CHNL_EBASE + 0x14)
+
+/* Wait for flush operation on an output channel timed out. */
+#define CHNL_E_WAITTIMEOUT          (CHNL_EBASE + 0x15)
+
+/* User supplied hEvent must be specified with pstrEventName attribute */
+#define CHNL_E_BADUSEREVENT         (CHNL_EBASE + 0x16)
+
+/* Illegal user event name specified */
+#define CHNL_E_USEREVENTNAME        (CHNL_EBASE + 0x17)
+
+/* Unable to prepare buffer specified */
+#define CHNL_E_PREPFAILED           (CHNL_EBASE + 0x18)
+
+/* Unable to Unprepare buffer specified */
+#define CHNL_E_UNPREPFAILED         (CHNL_EBASE + 0x19)
+
+/* FAILURE Codes : SYNC */
+#define SYNC_EBASE                  (DSP_COMP_EBASE + 0x600)
+
+/* Wait on a kernel event failed. */
+#define SYNC_E_FAIL                 (SYNC_EBASE + 0x00)
+
+/* Timeout expired while waiting for event to be signalled. */
+#define SYNC_E_TIMEOUT              (SYNC_EBASE + 0x01)
+
+/* FAILURE Codes : WMD */
+#define WMD_EBASE                   (DSP_COMP_EBASE + 0x700)
+
+/* A test of hardware assumptions or integrity failed. */
+#define WMD_E_HARDWARE              (WMD_EBASE + 0x00)
+
+/* One or more configuration parameters violated WMD hardware assumptions. */
+#define WMD_E_BADCONFIG             (WMD_EBASE + 0x01)
+
+/* Timeout occurred waiting for a response from the hardware. */
+#define WMD_E_TIMEOUT               (WMD_EBASE + 0x02)
+
+/* FAILURE Codes : REG */
+#define REG_EBASE                   (DSP_COMP_EBASE + 0x800)
+
+/* Invalid subkey parameter. */
+#define REG_E_INVALIDSUBKEY         (REG_EBASE + 0x00)
+
+/* Invalid entry parameter. */
+#define REG_E_INVALIDENTRY          (REG_EBASE + 0x01)
+
+/* No more registry values. */
+#define REG_E_NOMOREITEMS           (REG_EBASE + 0x02)
+
+/* Insufficient space to hold data in registry value. */
+#define REG_E_MOREDATA              (REG_EBASE + 0x03)
+
+/* FAILURE Codes : KFILE */
+#define KFILE_EBASE                 (DSP_COMP_EBASE + 0x900)
+
+/* Invalid file handle. */
+#define E_KFILE_INVALIDHANDLE       (KFILE_EBASE + 0x01)
+
+/* Bad file name. */
+#define E_KFILE_BADFILENAME         (KFILE_EBASE + 0x02)
+
+/* Invalid file mode. */
+#define E_KFILE_INVALIDMODE         (KFILE_EBASE + 0x03)
+
+/* No resources available. */
+#define E_KFILE_NORESOURCES         (KFILE_EBASE + 0x04)
+
+/* Invalid file buffer        . */
+#define E_KFILE_INVALIDBUFFER       (KFILE_EBASE + 0x05)
+
+/* Bad origin argument. */
+#define E_KFILE_BADORIGINFLAG       (KFILE_EBASE + 0x06)
+
+/* Invalid file offset value. */
+#define E_KFILE_INVALIDOFFSET       (KFILE_EBASE + 0x07)
+
+/* General KFILE error condition */
+#define E_KFILE_ERROR               (KFILE_EBASE + 0x08)
+
+#endif				/* ERRBASE_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gb.h
@@ -0,0 +1,85 @@
+/*
+ * bridge/inc/gb.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== gb.h ========
+ *  Generic bitmap manager.
+ *
+ *! Revision History
+ *! ================
+ */
+
+#ifndef GB_
+#define GB_
+
+#define GB_NOBITS (~0)
+#include <host_os.h>
+typedef s32 GB_BitNum;
+struct GB_TMap;
+
+/*
+ *  ======== GB_clear ========
+ *  Clear the bit in position bitn in the bitmap map.  Bit positions are
+ *  zero based.
+ */
+
+extern void GB_clear(struct GB_TMap *map, GB_BitNum bitn);
+
+/*
+ *  ======== GB_create ========
+ *  Create a bit map with len bits.  Initially all bits are cleared.
+ */
+
+extern struct GB_TMap *GB_create(GB_BitNum len);
+
+/*
+ *  ======== GB_delete ========
+ *  Delete previously created bit map
+ */
+
+extern void GB_delete(struct GB_TMap *map);
+
+/*
+ *  ======== GB_findandset ========
+ *  Finds a clear bit, sets it, and returns the position
+ */
+
+extern GB_BitNum GB_findandset(struct GB_TMap *map);
+
+/*
+ *  ======== GB_minclear ========
+ *  GB_minclear returns the minimum clear bit position.  If no bit is
+ *  clear, GB_minclear returns -1.
+ */
+extern GB_BitNum GB_minclear(struct GB_TMap *map);
+
+/*
+ *  ======== GB_set ========
+ *  Set the bit in position bitn in the bitmap map.  Bit positions are
+ *  zero based.
+ */
+
+extern void GB_set(struct GB_TMap *map, GB_BitNum bitn);
+
+/*
+ *  ======== GB_test ========
+ *  Returns TRUE if the bit in position bitn is set in map; otherwise
+ *  GB_test returns FALSE.  Bit positions are zero based.
+ */
+
+extern bool GB_test(struct GB_TMap *map, GB_BitNum bitn);
+
+#endif				/*GB_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/getsection.h
@@ -0,0 +1,118 @@
+/*
+ * bridge/inc/getsection.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+#ifndef _GETSECTION_H_
+#define _GETSECTION_H_
+
+
+#include "dynamic_loader.h"
+
+/*
+ * Get Section Information
+ *
+ * This file provides an API add-on to the dynamic loader that allows the user
+ * to query section information and extract section data from dynamic load
+ * modules.
+ *
+ * NOTE:
+ * Functions in this API assume that the supplied Dynamic_Loader_Stream object
+ * supports the set_file_posn method.
+ */
+
+	/* opaque handle for module information */
+	typedef void *DLOAD_module_info;
+
+/*
+ * Procedure DLOAD_module_open
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side malloc/free and error reporting functions.
+ *          Other methods are unused.
+ *
+ * Effect:
+ *  Reads header information from a dynamic loader module using the specified
+ * stream object, and returns a handle for the module information.  This
+ * handle may be used in subsequent query calls to obtain information
+ * contained in the module.
+ *
+ * Returns:
+ *  NULL if an error is encountered, otherwise a module handle for use
+ * in subsequent operations.
+ */
+	extern DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream
+						   *module,
+						   struct Dynamic_Loader_Sym
+						   *syms);
+
+/*
+ * Procedure DLOAD_GetSectionInfo
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *  sectionName Pointer to the string name of the section desired
+ *  sectionInfo Address of a section info structure pointer to be initialized
+ *
+ * Effect:
+ *  Finds the specified section in the module information, and fills in
+ * the provided LDR_SECTION_INFO structure.
+ *
+ * Returns:
+ *  TRUE for success, FALSE for section not found
+ */
+	extern int DLOAD_GetSectionInfo(DLOAD_module_info minfo,
+					const char *sectionName,
+					const struct LDR_SECTION_INFO
+					** const sectionInfo);
+
+/*
+ * Procedure DLOAD_GetSection
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *  sectionInfo Pointer to a section info structure for the desired section
+ *  sectionData Buffer to contain the section initialized data
+ *
+ * Effect:
+ *  Copies the initialized data for the specified section into the
+ * supplied buffer.
+ *
+ * Returns:
+ *  TRUE for success, FALSE for section not found
+ */
+	extern int DLOAD_GetSection(DLOAD_module_info minfo,
+				    const struct LDR_SECTION_INFO *sectionInfo,
+				    void *sectionData);
+
+/*
+ * Procedure DLOAD_module_close
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *
+ * Effect:
+ *  Releases any storage associated with the module handle.  On return,
+ * the module handle is invalid.
+ *
+ * Returns:
+ *  Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report(), where syms was
+ * an argument to DLOAD_module_open
+ */
+	extern void DLOAD_module_close(DLOAD_module_info minfo);
+
+#endif				/* _GETSECTION_H_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gh.h
@@ -0,0 +1,37 @@
+/*
+ * bridge/inc/gh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== gh.h ========
+ *
+ *! Revision History
+ *! ================
+ */
+
+#ifndef GH_
+#define GH_
+#include <host_os.h>
+
+extern struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
+		u16(*hash) (void *, u16), bool(*match) (void *, void *),
+		void(*delete) (void *));
+extern void GH_delete(struct GH_THashTab *hashTab);
+extern void GH_exit(void);
+extern void *GH_find(struct GH_THashTab *hashTab, void *key);
+extern void GH_init(void);
+extern void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value);
+#endif				/* GH_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gs.h
@@ -0,0 +1,64 @@
+/*
+ * bridge/inc/gs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== gs.h ========
+ *  Memory allocation/release wrappers.  This module allows clients to
+ *  avoid OS spacific issues related to memory allocation.  It also provides
+ *  simple diagnostic capabilities to assist in the detection of memory
+ *  leaks.
+ *! Revision History
+ *! ================
+ */
+
+#ifndef GS_
+#define GS_
+
+/*
+ *  ======== GS_alloc ========
+ *  Alloc size bytes of space.  Returns pointer to space
+ *  allocated, otherwise NULL.
+ */
+extern void *GS_alloc(u32 size);
+
+/*
+ *  ======== GS_exit ========
+ *  Module exit.  Do not change to "#define GS_init()"; in
+ *  some environments this operation must actually do some work!
+ */
+extern void GS_exit(void);
+
+/*
+ *  ======== GS_free ========
+ *  Free space allocated by GS_alloc() or GS_calloc().
+ */
+extern void GS_free(void *ptr);
+
+/*
+ *  ======== GS_frees ========
+ *  Free space allocated by GS_alloc() or GS_calloc() and assert that
+ *  the size of the allocation is size bytes.
+ */
+extern void GS_frees(void *ptr, u32 size);
+
+/*
+ *  ======== GS_init ========
+ *  Module initialization.  Do not change to "#define GS_init()"; in
+ *  some environments this operation must actually do some work!
+ */
+extern void GS_init(void);
+
+#endif				/*GS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gt.h
@@ -0,0 +1,315 @@
+/*
+ * bridge/inc/gt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== gt.h ========
+ *  Purpose:
+ *      There are two definitions that affect which portions of trace
+ *      are acutally compiled into the client: GT_TRACE and GT_ASSERT. If
+ *      GT_TRACE is set to 0 then all trace statements (except for assertions)
+ *      will be compiled out of the client. If GT_ASSERT is set to 0 then
+ *      assertions will be compiled out of the client. GT_ASSERT can not be
+ *      set to 0 unless GT_TRACE is also set to 0 (i.e. GT_TRACE == 1 implies
+ *      GT_ASSERT == 1).
+ *
+ *! Revision History
+ *! ================
+ *! 02-Feb-2000 rr: Renamed this file to gtce.h. GT CLASS and trace definitions
+ *!                 are WinCE Specific.
+ *! 03-Jan-1997	ge	Replaced "GT_" prefix to GT_Config structure members
+ *!                 to eliminate preprocessor confusion with other macros.
+ */
+#include <linux/types.h>
+#ifndef GT_
+#define GT_
+
+#ifndef GT_TRACE
+#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
+#endif
+
+#include <host_os.h>
+
+#if !defined(GT_ASSERT) || GT_TRACE
+#define GT_ASSERT 1
+#endif
+
+struct GT_Config {
+	Fxn PRINTFXN;
+	Fxn PIDFXN;
+	Fxn TIDFXN;
+	Fxn ERRORFXN;
+};
+
+extern struct GT_Config *GT;
+
+struct GT_Mask {
+	char *modName;
+	u8 *flags;
+} ;
+
+/*
+ *  New GT Class defenitions.
+ *
+ *  The following are the explanations and how it could be used in the code
+ *
+ *  -   GT_ENTER    On Entry to Functions
+ *
+ *  -   GT_1CLASS   Display level of debugging status- Object/Automatic
+ *                  variables
+ *  -   GT_2CLASS   ---- do ----
+ *
+ *  -   GT_3CLASS   ---- do ---- + It can be used(recommended) for debug
+ *		    status in the ISR, IST
+ *  -   GT_4CLASS   ---- do ----
+ *
+ *  -   GT_5CLASS   Display entry for module init/exit functions
+ *
+ *  -   GT_6CLASS   Warn whenever SERVICES function fails
+ *
+ *  -   GT_7CLASS   Warn failure of Critical failures
+ *
+ */
+
+#define GT_ENTER	((u8)0x01)
+#define GT_1CLASS	((u8)0x02)
+#define GT_2CLASS	((u8)0x04)
+#define GT_3CLASS	((u8)0x08)
+#define GT_4CLASS	((u8)0x10)
+#define GT_5CLASS	((u8)0x20)
+#define GT_6CLASS	((u8)0x40)
+#define GT_7CLASS	((u8)0x80)
+
+#ifdef _LINT_
+
+/* LINTLIBRARY */
+
+/*
+ *  ======== GT_assert ========
+ */
+/* ARGSUSED */
+void GT_assert(struct GT_Mask mask, s32 expr)
+{
+}
+
+/*
+ *  ======== GT_config ========
+ */
+/* ARGSUSED */
+void GT_config(struct GT_Config config)
+{
+}
+
+/*
+ *  ======== GT_create ========
+ */
+/* ARGSUSED */
+void GT_create(struct GT_Mask *mask, char *modName)
+{
+}
+
+/*
+ *  ======== GT_curLine ========
+ *  Purpose:
+ *      Returns the current source code line number. Is useful for performing
+ *      branch testing using trace.  For example,
+ *
+ *      GT_1trace(curTrace, GT_1CLASS,
+ *          "in module XX_mod, executing line %u\n", GT_curLine());
+ */
+/* ARGSUSED */
+u16 GT_curLine(void)
+{
+	return (u16)NULL;
+}
+
+/*
+ *  ======== GT_exit ========
+ */
+/* ARGSUSED */
+void GT_exit(void)
+{
+}
+
+/*
+ *  ======== GT_init ========
+ */
+/* ARGSUSED */
+void GT_init(void)
+{
+}
+
+/*
+ *  ======== GT_query ========
+ */
+/* ARGSUSED */
+bool GT_query(struct GT_Mask mask, u8 class)
+{
+	return false;
+}
+
+/*
+ *  ======== GT_set ========
+ *  sets trace mask according to settings
+ */
+
+/* ARGSUSED */
+void GT_set(char *settings)
+{
+}
+
+/*
+ *  ======== GT_setprintf ========
+ *  sets printf function
+ */
+
+/* ARGSUSED */
+void GT_setprintf(Fxn fxn)
+{
+}
+
+/* ARGSUSED */
+void GT_0trace(struct GT_Mask mask, u8 class, char *format)
+{
+}
+
+/* ARGSUSED */
+void GT_1trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+/* ARGSUSED */
+void GT_2trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+/* ARGSUSED */
+void GT_3trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+/* ARGSUSED */
+void GT_4trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+/* ARGSUSED */
+void GT_5trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+/* ARGSUSED */
+void GT_6trace(struct GT_Mask mask, u8 class, char *format, ...)
+{
+}
+
+#else
+
+#define	GT_BOUND    26		/* 26 letters in alphabet */
+
+extern void _GT_create(struct GT_Mask *mask, char *modName);
+
+#define GT_exit()
+
+extern void GT_init(void);
+extern void _GT_set(char *str);
+extern s32 _GT_trace(struct GT_Mask *mask, char *format, ...);
+
+#if GT_ASSERT == 0
+
+#define GT_assert(mask, expr)
+#define GT_config(config)
+#define GT_configInit(config)
+#define GT_seterror(fxn)
+
+#else
+
+extern struct GT_Config _GT_params;
+
+#define GT_assert(mask, expr) \
+	(!(expr) ? \
+	    printk("assertion violation: %s, line %d\n", \
+			    __FILE__, __LINE__), NULL : NULL)
+
+#define GT_config(config)     (_GT_params = *(config))
+#define GT_configInit(config) (*(config) = _GT_params)
+#define GT_seterror(fxn)      (_GT_params.ERRORFXN = (Fxn)(fxn))
+
+#endif
+
+#if GT_TRACE == 0
+
+#define GT_curLine()                ((u16)__LINE__)
+#define GT_create(mask, modName)
+#define GT_exit()
+#define GT_init()
+#define GT_set(settings)
+#define GT_setprintf(fxn)
+
+#define GT_query(mask, class)     false
+
+#define GT_0trace(mask, class, format)
+#define GT_1trace(mask, class, format, arg1)
+#define GT_2trace(mask, class, format, arg1, arg2)
+#define GT_3trace(mask, class, format, arg1, arg2, arg3)
+#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4)
+#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5)
+#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6)
+
+#else				/* GT_TRACE == 1 */
+
+
+#define GT_create(mask, modName)    _GT_create((mask), (modName))
+#define GT_curLine()                ((u16)__LINE__)
+#define GT_set(settings)          _GT_set(settings)
+#define GT_setprintf(fxn)         (_GT_params.PRINTFXN = (Fxn)(fxn))
+
+#define GT_query(mask, class) ((*(mask).flags & (class)))
+
+#define GT_0trace(mask, class, format) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format)) : 0)
+
+#define GT_1trace(mask, class, format, arg1) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1)) : 0)
+
+#define GT_2trace(mask, class, format, arg1, arg2) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1), (arg2)) : 0)
+
+#define GT_3trace(mask, class, format, arg1, arg2, arg3) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3)) : 0)
+
+#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4)) : 0)
+
+#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5)) : 0)
+
+#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6) \
+    ((*(mask).flags & (class)) ? \
+    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5), \
+	(arg6)) : 0)
+
+#endif				/* GT_TRACE */
+
+#endif				/* _LINT_ */
+
+#endif				/* GTCE_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/host_os.h
@@ -0,0 +1,81 @@
+/*
+ * bridge/inc/host_os.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== windows.h ========
+ *
+ *! Revision History
+ *! ================
+ *! 08-Mar-2004 sb Added cacheflush.h to support Dynamic Memory Mapping feature
+ *! 16-Feb-2004 sb Added headers required for consistent_alloc
+ */
+
+#ifndef _HOST_OS_H_
+#define _HOST_OS_H_
+
+#include <linux/autoconf.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/syscalls.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <dbtype.h>
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+#include <mach/clock.h>
+#ifdef CONFIG_ARCH_OMAP3430
+#include <linux/clk.h>
+#endif
+#endif
+
+#include <linux/pagemap.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+
+/*  ----------------------------------- Macros */
+
+#define SEEK_SET        0	/* Seek from beginning of file.  */
+#define SEEK_CUR        1	/* Seek from current position.  */
+#define SEEK_END        2	/* Seek from end of file.  */
+
+/* TODO -- Remove, once BP defines them */
+#ifdef CONFIG_ARCH_OMAP3430
+#define INT_MAIL_MPU_IRQ        26
+#define INT_DSP_MMU_IRQ        28
+#endif
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/iodefs.h
@@ -0,0 +1,45 @@
+/*
+ * bridge/inc/iodefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== iodefs.h ========
+ *  Description:
+ *      System-wide channel objects and constants.
+ *
+ *! Revision History:
+ *! ================
+ *! 07-Nov-2000 jeh     Created.
+ */
+
+#ifndef IODEFS_
+#define IODEFS_
+
+#define IO_MAXIRQ   0xff	/* Arbitrarily large number. */
+
+/* IO Objects: */
+	struct IO_MGR;
+
+/* IO manager attributes: */
+	struct IO_ATTRS {
+		u8 bIRQ;	/* Channel's I/O IRQ number. */
+		bool fShared;	/* TRUE if the IRQ is shareable. */
+		u32 uWordSize;	/* DSP Word size. */
+		u32 dwSMBase;	/* Physical base address of shared memory. */
+		u32 uSMLength;	/* Size (in bytes) of shared memory. */
+	} ;
+
+#endif				/* IODEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/io.h
@@ -0,0 +1,132 @@
+/*
+ * bridge/inc/io.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== io.h ========
+ *  Description:
+ *      The io module manages IO between CHNL and MSG.
+ *
+ *  Public Functions:
+ *      IO_Create
+ *      IO_Destroy
+ *      IO_Exit
+ *      IO_Init
+ *      IO_OnLoaded
+ *
+ *
+ *! Revision History:
+ *! ================
+ *! 07-Nov-2000 jeh     Created.
+ */
+
+#ifndef IO_
+#define IO_
+
+#include <cfgdefs.h>
+#include <devdefs.h>
+
+#include <iodefs.h>
+
+/*
+ *  ======== IO_Create ========
+ *  Purpose:
+ *      Create an IO manager object, responsible for managing IO between
+ *      CHNL and MSG.
+ *  Parameters:
+ *      phChnlMgr:              Location to store a channel manager object on
+ *                              output.
+ *      hDevObject:             Handle to a device object.
+ *      pMgrAttrs:              IO manager attributes.
+ *      pMgrAttrs->bIRQ:        I/O IRQ number.
+ *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
+ *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
+ *  Requires:
+ *      IO_Init() called.
+ *      phIOMgr != NULL.
+ *      pMgrAttrs != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr,
+				    struct DEV_OBJECT *hDevObject,
+				    IN CONST struct IO_ATTRS *pMgrAttrs);
+
+/*
+ *  ======== IO_Destroy ========
+ *  Purpose:
+ *      Destroy the IO manager.
+ *  Parameters:
+ *      hIOMgr:         IOmanager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hIOMgr was invalid.
+ *  Requires:
+ *      IO_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== IO_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the IO module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      IO_Init() previously called.
+ *  Ensures:
+ *      Resources, if any acquired in IO_Init(), are freed when the last
+ *      client of IO calls IO_Exit().
+ */
+	extern void IO_Exit(void);
+
+/*
+ *  ======== IO_Init ========
+ *  Purpose:
+ *      Initialize the IO module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occurred.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CHNL functions.
+ */
+	extern bool IO_Init(void);
+
+/*
+ *  ======== IO_OnLoaded ========
+ *  Purpose:
+ *      Called when a program is loaded so IO manager can update its
+ *      internal state.
+ *  Parameters:
+ *      hIOMgr:         IOmanager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hIOMgr was invalid.
+ *  Requires:
+ *      IO_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_OnLoaded(struct IO_MGR *hIOMgr);
+
+#endif				/* CHNL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/io_sm.h
@@ -0,0 +1,338 @@
+/*
+ * bridge/inc/io_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== io_sm.h ========
+ *  Description:
+ *      IO dispatcher for a shared memory channel driver.
+ *      Also, includes macros to simulate SHM via port io calls.
+ *
+ *  Public Functions:
+ *      IO_Dispatch
+ *      IO_DPC
+ *      IO_ISR
+ *      IO_RequestChnl
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 01-Mar-2004 vp: Added IVA releated functions.
+ *! 23-Apr-2003 sb: Fixed mailbox deadlock
+ *! 06-Feb-2003 kc  Added IO_DDMAClearChnlDesc and IO_DDZCClearChnlDesc.
+ *! 21-Dec-2001 ag  Removed unused param in IO_DDMAInitChnlDesc().
+ *                  Updated comments. Removed #ifdef CHNL_NOIPCINTR.
+ *! 05-Nov-2001 kc  Updated IO_CALLISR macro.
+ *! 01-May-2001 jeh Removed IO_RequestMsg.
+ *! 29-Mar-2001 ag  Added #ifdef CHNL_NOIPCINTR.
+ *! 04-Dec-2000 jeh Added IO_RequestMsg.
+ *! 26-Oct-2000 jeh Added IO_GetLong, IO_SetLong, IO_ReadValueLong, and
+ *!                 IO_WriteValueLong, for passing arg in SHM structure.
+ *! 20-Jan-2000 ag: Updated header comments per code review.
+ *! 05-Jan-2000 ag: Text format clean-up.
+ *! 02-Nov-1999 ag: Updated header descriptions.
+ *! 25-May-1999 jg: Removed assumption of 4 bytes / word.
+ *! 12-Aug-1996 gp: Created.
+ */
+
+#ifndef IOSM_
+#define IOSM_
+
+#include <_chnl_sm.h>
+#include <host_os.h>
+
+#include <iodefs.h>
+
+#define IO_INPUT            0
+#define IO_OUTPUT           1
+#define IO_SERVICE          2
+#define IO_MAXSERVICE       IO_SERVICE
+
+#define IO_MGRSIGNATURE     0x494f4D43	/* "IOGR" */
+
+#define DSPFieldAddr(type, field, base, wordsize) \
+    ((((s32)&(((type *)0)->field)) / wordsize) + (u32)base)
+
+/* Access can be different SM access word size (e.g. 16/32 bit words) */
+#define IO_SetValue(pContext, type, base, field, value) (base->field = value)
+#define IO_GetValue(pContext, type, base, field)	(base->field)
+#define IO_OrValue(pContext, type, base, field, value)  (base->field |= value)
+#define IO_AndValue(pContext, type, base, field, value) (base->field &= value)
+#define IO_SetLong(pContext, type, base, field, value)  (base->field = value)
+#define IO_GetLong(pContext, type, base, field)         (base->field)
+
+#define IO_DisableInterrupt(h)  CHNLSM_DisableInterrupt(h)
+#define IO_EnableInterrupt(h)   CHNLSM_EnableInterrupt(h)
+#define IO_InterruptDSP(h)      CHNLSM_InterruptDSP(h)
+#define IO_InterruptDSP2(h, v)  CHNLSM_InterruptDSP2(h, v)
+#define IO_CALLDPC(h)           CHNLSM_DPC(h)
+#define IO_CALLISR(h, pFlag, pwMBRegVal)   CHNLSM_ISR(h, pFlag, pwMBRegVal)
+
+/*
+ *  ======== IO_CancelChnl ========
+ *  Purpose:
+ *      Cancel IO on a given channel.
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *      ulChnl:     Index of channel to cancel IO on.
+ *  Returns:
+ *  Requires:
+ *      Valid hIOMgr.
+ *  Ensures:
+ */
+	extern void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl);
+
+/*
+ *  ======== IO_DPC ========
+ *  Purpose:
+ *      Deferred procedure call for shared memory channel driver ISR.  Carries
+ *      out the dispatch of I/O.
+ *  Parameters:
+ *      pRefData:   Pointer to reference data registered via a call to
+ *                  DPC_Create().
+ *  Returns:
+ *  Requires:
+ *      Must not block.
+ *      Must not acquire resources.
+ *      All data touched must be locked in memory if running in kernel mode.
+ *  Ensures:
+ *      Non-preemptible (but interruptible).
+ */
+	extern void IO_DPC(IN OUT void *pRefData);
+
+/*
+ *  ======== IO_ISR ========
+ *  Purpose:
+ *      Main interrupt handler for the shared memory WMD channel manager.
+ *      Calls the WMD's CHNLSM_ISR to determine if this interrupt is ours, then
+ *      schedules a DPC to dispatch I/O..
+ *  Parameters:
+ *      pRefData:   Pointer to the channel manager object for this board.
+ *                  Set in an initial call to ISR_Install().
+ *  Returns:
+ *      TRUE if interrupt handled; FALSE otherwise.
+ *  Requires:
+ *      Must be in locked memory if executing in kernel mode.
+ *      Must only call functions which are in locked memory if Kernel mode.
+ *      Must only call asynchronous services.
+ *      Interrupts are disabled and EOI for this interrupt has been sent.
+ *  Ensures:
+ */
+       irqreturn_t IO_ISR(int irq, IN void *pRefData);
+/*
+ *  ======== IO_RequestChnl ========
+ *  Purpose:
+ *      Request I/O from the DSP. Sets flags in shared memory, then interrupts
+ *      the DSP.
+ *  Parameters:
+ *      hIOMgr:     IO manager handle.
+ *      pChnl:      Ptr to the channel requesting I/O.
+ *      iMode:      Mode of channel: {IO_INPUT | IO_OUTPUT}.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *  Ensures:
+ */
+	extern void IO_RequestChnl(struct IO_MGR *hIOMgr,
+				   struct CHNL_OBJECT *pChnl,
+				   u32 iMode, OUT u16 *pwMbVal);
+
+/*
+ *  ======== IO_Schedule ========
+ *  Purpose:
+ *      Schedule DPC for IO.
+ *  Parameters:
+ *      pIOMgr:     Ptr to a I/O manager.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *  Ensures:
+ */
+	extern void IO_Schedule(struct IO_MGR *hIOMgr);
+
+/*
+ * DSP-DMA IO functions
+ */
+
+/*
+ *  ======== IO_DDMAInitChnlDesc ========
+ *  Purpose:
+ *      Initialize DSP DMA channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uDDMAChnlId:    DDMA channel identifier.
+ *      uNumDesc:       Number of buffer descriptors(equals # of IOReqs &
+ *                      Chirps)
+ *      pDsp:           Dsp address;
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXDDMACHNLS
+ *     uNumDesc > 0
+ *     pVa != NULL
+ *     pDspPa != NULL
+ *
+ *  Ensures:
+ */
+	extern void IO_DDMAInitChnlDesc(struct IO_MGR *hIOMgr, u32 uDDMAChnlId,
+					u32 uNumDesc, void *pDsp);
+
+/*
+ *  ======== IO_DDMAClearChnlDesc ========
+ *  Purpose:
+ *      Clear DSP DMA channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uDDMAChnlId:    DDMA channel identifier.
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXDDMACHNLS
+ *  Ensures:
+ */
+	extern void IO_DDMAClearChnlDesc(struct IO_MGR *hIOMgr,
+					 u32 uDDMAChnlId);
+
+/*
+ *  ======== IO_DDMARequestChnl ========
+ *  Purpose:
+ *      Request channel DSP-DMA from the DSP. Sets up SM descriptors and
+ *      control fields in shared memory.
+ *  Parameters:
+ *      hIOMgr:     Handle to a I/O manager.
+ *      pChnl:      Ptr to channel object
+ *      pChirp:     Ptr to channel i/o request packet.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *      pChnl->cIOReqs > 0
+ *      pChirp != NULL
+ *  Ensures:
+ */
+	extern void IO_DDMARequestChnl(struct IO_MGR *hIOMgr,
+				       struct CHNL_OBJECT *pChnl,
+				       struct CHNL_IRP *pChirp,
+				       OUT u16 *pwMbVal);
+
+/*
+ * Zero-copy IO functions
+ */
+
+/*
+ *  ======== IO_DDZCInitChnlDesc ========
+ *  Purpose:
+ *      Initialize ZCPY channel descriptor.
+ *  Parameters:
+ *      hIOMgr:     Handle to a I/O manager.
+ *      uZId:       zero-copy channel identifier.
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXZCPYCHNLS
+ *     hIOMgr != Null
+ *  Ensures:
+ */
+	extern void IO_DDZCInitChnlDesc(struct IO_MGR *hIOMgr, u32 uZId);
+
+/*
+ *  ======== IO_DDZCClearChnlDesc ========
+ *  Purpose:
+ *      Clear DSP ZC channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uChnlId:        ZC channel identifier.
+ *  Returns:
+ *  Requires:
+ *      hIOMgr is valid
+ *      uChnlId < DDMA_MAXZCPYCHNLS
+ *  Ensures:
+ */
+	extern void IO_DDZCClearChnlDesc(struct IO_MGR *hIOMgr, u32 uChnlId);
+
+/*
+ *  ======== IO_DDZCRequestChnl ========
+ *  Purpose:
+ *      Request zero-copy channel transfer. Sets up SM descriptors and
+ *      control fields in shared memory.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      pChnl:          Ptr to channel object
+ *      pChirp:         Ptr to channel i/o request packet.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *      pChnl->cIOReqs > 0
+ *      pChirp != NULL
+ *  Ensures:
+ */
+	extern void IO_DDZCRequestChnl(struct IO_MGR *hIOMgr,
+				       struct CHNL_OBJECT *pChnl,
+				       struct CHNL_IRP *pChirp,
+				       OUT u16 *pwMbVal);
+
+/*
+ *  ======== IO_SHMsetting ========
+ *  Purpose:
+ *      Sets the shared memory setting
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      desc:             Shared memory type
+ *      pArgs:          Ptr to SHM setting
+ *  Returns:
+ *  Requires:
+ *      hIOMgr != NULL
+ *      pArgs != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr,
+					IN enum SHM_DESCTYPE desc,
+					IN void *pArgs);
+
+/*
+ *  Misc functions for the CHNL_IO shared memory library:
+ */
+
+/* Maximum channel bufsize that can be used. */
+	extern u32 IO_BufSize(struct IO_MGR *hIOMgr);
+
+	extern u32 IO_ReadValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr);
+
+	extern void IO_WriteValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr, u32 dwValue);
+
+	extern u32 IO_ReadValueLong(struct WMD_DEV_CONTEXT *hDevContext,
+				      u32 dwDSPAddr);
+
+	extern void IO_WriteValueLong(struct WMD_DEV_CONTEXT *hDevContext,
+				      u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_OrSetValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_AndSetValue(struct WMD_DEV_CONTEXT *hDevContext,
+				   u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
+
+       extern void IO_SM_init(void);
+
+/*
+ *  ========PrintDspTraceBuffer ========
+ *      Print DSP tracebuffer.
+ */
+       extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
+                                               *hWmdContext);
+
+#endif				/* IOSM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/kfile.h
@@ -0,0 +1,216 @@
+/*
+ * bridge/inc/kfile.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== kfile.h ========
+ *  Purpose:
+ *      Provide file I/O management capabilities.
+ *
+ *  Public Functions:
+ *      KFILE_Close
+ *      KFILE_Exit
+ *      KFILE_Init
+ *      KFILE_Open
+ *      KFILE_Read
+ *      KFILE_Seek
+ *      KFILE_Tell
+ *      KFILE_Write
+ *
+ *  Notes:
+ *      The KFILE module is not like most of the other DSP/BIOS Bridge modules
+ *      in that it doesn't return WSX_STATUS type values.  Rather, it's
+ *      prototypes are meant to match the stdio file prototypes
+ *      (ie, fopen, fclose, etc.).
+ *
+ *! Revision History
+ *! ================
+ *! 29-Oct-1999 kc:  Clean up for code review.
+ *! 07-Jan-1998 cr:  Clean up for code review.
+ *! 15-Aug-1997 cr:  Added E_KFILE_ERROR for general error condition.
+ *! 04-Aug-1997 cr:  Added explicit CDECL descriptions.
+ *! 11-Nov-1996 cr:  Implemented changes based on code review.
+ *! 05-Nov-1996 cr:  Cleaned up for code review.
+ *! 29-May-1996 gp:  Added requirement that size != 0 in _Write() and _Read().
+ *! 28-May-1996 mg:  Changed return values for Read/Write.
+ *! 14-Dec-1995 cr:  Created.
+ */
+
+#ifndef KFILE_
+#define KFILE_
+
+/*
+ *  Constants for KFILE_Seek.  Note that these MUST be the same definitions as
+ *  those defined for fseek.
+ */
+#define KFILE_SEEK_SET          0x00	/* seek from beginning of file */
+#define KFILE_SEEK_CUR          0x01	/* seek from current position */
+#define KFILE_SEEK_END          0x02	/* seek from end of file */
+
+	struct KFILE_FileObj;
+
+/*
+ *  ======== KFILE_Close ========
+ *  Purpose:
+ *      This function closes a file's stream.
+ *  Parameters:
+ *      hFile:      Handle of the file stream returned by KFILE_Open.
+ *  Returns:
+ *      E_KFILE_INVALIDHANDLE:  bad handle.
+ *      0:                      success.
+ *      E_KFILE_ERROR:          unable to close specified handle.
+ *  Requires:
+ *      KFILE initialized.
+ *  Ensures:
+ */
+	extern s32 KFILE_Close(IN struct KFILE_FileObj *hFile);
+
+/*
+ *  ======== KFILE_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      KFILE initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void KFILE_Exit();
+
+/*
+ *  ======== KFILE_Init ========
+ *  Purpose:
+ *      Initializes private state of KFILE module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success, else FALSE.
+ *  Requires:
+ *  Ensures:
+ *      KFILE initialized.
+ */
+	extern bool KFILE_Init();
+
+/*
+ *  ======== KFILE_Open ========
+ *  Purpose:
+ *      Opens a file for use.
+ *  Parameters:
+ *      pszFileName:    Full path to name of the file to open.
+ *      pszMode:        String containing open status.  Only the first
+ *                      character of the string is examined, for either
+ *                      "r" (read) or "w" (write) mode.
+ *  Returns:
+ *      A valid file handle if success, else NULL.
+ *  Requires:
+ *      - KFILE initialized.
+ *      - pszMode != NULL.
+ *      - pszFileName != NULL.
+ *  Ensures:
+ */
+	extern struct KFILE_FileObj *KFILE_Open(IN CONST char *filename,
+				       IN CONST char *mode);
+
+/*
+ *  ======== KFILE_Read ========
+ *  Purpose:
+ *      This function reads a specified number of bytes into a buffer.
+ *  Parameters:
+ *      pBuffer:    Array to which the file data is copied.
+ *      cSize:      Number of characters in each object.
+ *      cCount:     Number of objects to read in.
+ *      hFile:      Handle of the file stream returned by KFILE_Open.
+ *  Returns:
+ *      E_KFILE_INVALIDHANDLE:  bad file handle.
+ *      E_KFILE_ERROR:          general failure.
+ *      > 0:                    success; # of objects read from file.
+ *  Requires:
+ *      KFILE initialized.
+ *      pBuffer is a valid pointer.
+ *  Ensures:
+ */
+	extern s32 KFILE_Read(OUT void *buffer,
+			      IN s32 size, IN s32 count,
+			      IN struct KFILE_FileObj *hFile);
+
+/*
+ *  ======== KFILE_Seek ========
+ *  Purpose:
+ *      This function sets the file position indicator.  NOTE:  we don't
+ *      support seeking beyond the boundaries of a file.
+ *  Parameters:
+ *      hFile:      Handle of the file stream returned by KFILE_Open.
+ *      offset:     Number of bytes from the origin to move.
+ *      origin:     File reference point, one of the following values:
+ *                  KFILE_SEEK_SET:  Seek from beginning of file.
+ *                  KFILE_SEEK_CUR:  Seek from current position.
+ *                  KFILE_SEEK_END:  Seek from end of file.
+ *  Returns:
+ *      0: success.
+ *      E_KFILE_INVALIDHANDLE:  bad handle.
+ *      E_KFILE_BADORIGIN:      invalid origin paramater.
+ *      E_KFILE_ERROR:          general failure.
+ *  Requires:
+ *      KFILE initialized.
+ *  Ensures:
+ */
+	extern s32 KFILE_Seek(IN struct KFILE_FileObj *hFile,
+			      IN s32 offset, IN s32 origin);
+
+/*
+ *  ======== KFILE_Tell ========
+ *  Purpose:
+ *      This function reports the current value of the position indicator.
+ *  Parameters:
+ *      hFile:          Handle of the file stream returned by KFILE_Open.
+ *  Return value:
+ *      > 0: success; returns # of bytes the position indicator is from
+ *           beginning of file.
+ *      E_KFILE_ERROR:          general failure.
+ *      E_KFILE_INVALIDHANDLE:  bad file handle.
+ *  Requires:
+ *      KFILE initialized.
+ *  Ensures:
+ */
+	extern s32 KFILE_Tell(IN struct KFILE_FileObj *hFile);
+
+/*
+ *  ======== KFILE_Write ========
+ *  Purpose:
+ *      This function writes a number of objects to the stream.
+ *  Parameters:
+ *      pBuffer:    Array from which the file data is written.
+ *      cSize:      Number of characters in each object.
+ *      cCount:     Number of objects to write out.
+ *      hFile:      Handle of the file stream returned by KFILE_Open.
+ *  Returns:
+ *      E_KFILE_INVALIDHANDLE:  bad file handle.
+ *      E_KFILE_ERROR:          general failure.
+ *      > 0:                    success; # of objects written to file.
+ *  Requires:
+ *      KFILE initialized.
+ *      pBuffer != NULL.
+ *  Postcondition:
+ *      The file position indicator is advanced by the number of
+ *      characters written.
+ */
+	extern s32 KFILE_Write(OUT void *buffer,
+			       IN s32 size,
+			       IN s32 count,
+			       IN struct KFILE_FileObj *hFile);
+
+#endif				/* KFILE_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/ldr.h
@@ -0,0 +1,51 @@
+/*
+ * bridge/inc/ldr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== ldr.h ========
+ *  Purpose:
+ *      Provide module loading services and symbol export services.
+ *
+ *  Public Functions:
+ *      LDR_Exit
+ *      LDR_FreeModule
+ *      LDR_GetProcAddress
+ *      LDR_Init
+ *      LDR_LoadModule
+ *
+ *  Notes:
+ *      This service is meant to be used by modules of the DSP/BIOS Bridge
+ *       class driver.
+ *
+ *! Revision History:
+ *! ================
+ *! 22-Nov-1999 kc: Changes from code review.
+ *! 12-Nov-1999 kc: Removed declaration of unused loader object.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 12-Jan-1998 cr: Cleaned up for code review.
+ *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
+ *! 11-Nov-1996 cr: Cleaned up for code review.
+ *! 16-May-1996 gp: Created.
+ */
+
+#ifndef LDR_
+#define LDR_
+
+/* Loader objects: */
+	struct LDR_MODULE;
+
+#endif				/* LDR_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/list.h
@@ -0,0 +1,296 @@
+/*
+ * bridge/inc/list.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== list.h ========
+ *  Purpose:
+ *      Declarations of list management control structures and definitions
+ *      of inline list management functions.
+ *
+ *  Public Functions:
+ *      LST_Create
+ *      LST_Delete
+ *      LST_Exit
+ *      LST_First
+ *      LST_GetHead
+ *      LST_InitElem
+ *      LST_Init
+ *      LST_InsertBefore
+ *      LST_IsEmpty
+ *      LST_Next
+ *      LST_PutTail
+ *      LST_RemoveElem
+ *
+ *  Notes:
+ *
+ *! Revision History
+ *! ================
+ *! 10-Aug-2000 ag:  Added LST_InsertBefore().
+ *! 29-Oct-1999 kc:  Cleaned up for code review.
+ *! 16-Aug-1997 cr:  added explicit identifiers.
+ *! 10-Aug-1996 gp:  Acquired from SMM for WinSPOX v.1.1; renamed identifiers.
+ *! 21-Oct-1994 dh4: Cleaned / commented for code review.
+ *! 08-Jun-1994 dh4: Converted to SPM (added extern "C").
+ */
+
+#ifndef LIST_
+#define LIST_
+
+#include <host_os.h>
+
+#define LST_IsEmpty(l)      (((l)->head.next == &(l)->head))
+
+	struct LST_ELEM {
+		struct LST_ELEM *next;
+		struct LST_ELEM *prev;
+		struct LST_ELEM *self;
+	} ;
+
+	struct LST_LIST {
+		struct LST_ELEM head;
+	} ;
+
+/*
+ *  ======== LST_Create ========
+ *  Purpose:
+ *      Allocates and initializes a circular list.
+ *  Details:
+ *      Uses portable MEM_Calloc() function to allocate a list containing
+ *      a single element and initializes that element to indicate that it
+ *      is the "end of the list" (i.e., the list is empty).
+ *      An empty list is indicated by the "next" pointer in the element
+ *      at the head of the list pointing to the head of the list, itself.
+ *  Parameters:
+ *  Returns:
+ *      Pointer to beginning of created list (success)
+ *      NULL --> Allocation failed
+ *  Requires:
+ *      LST initialized.
+ *  Ensures:
+ *  Notes:
+ *      The created list contains a single element.  This element is the
+ *      "empty" element, because its "next" and "prev" pointers point at
+ *      the same location (the element itself).
+ */
+	extern struct LST_LIST *LST_Create();
+
+/*
+ *  ======== LST_Delete ========
+ *  Purpose:
+ *      Removes a list by freeing its control structure's memory space.
+ *  Details:
+ *      Uses portable MEM_Free() function to deallocate the memory
+ *      block pointed at by the input parameter.
+ *  Parameters:
+ *      pList:  Pointer to list control structure of list to be deleted
+ *  Returns:
+ *      Void
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *  Ensures:
+ *  Notes:
+ *      Must ONLY be used for empty lists, because it does not walk the
+ *      chain of list elements.  Calling this function on a non-empty list
+ *      will cause a memory leak.
+ */
+	extern void LST_Delete(IN struct LST_LIST *pList);
+
+/*
+ *  ======== LST_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      LST initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void LST_Exit();
+
+/*
+ *  ======== LST_First ========
+ *  Purpose:
+ *      Returns a pointer to the first element of the list, or NULL if the list
+ *      is empty.
+ *  Parameters:
+ *      pList:  Pointer to list control structure.
+ *  Returns:
+ *      Pointer to first list element, or NULL.
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *  Ensures:
+ */
+	extern struct LST_ELEM *LST_First(IN struct LST_LIST *pList);
+
+/*
+ *  ======== LST_GetHead ========
+ *  Purpose:
+ *      Pops the head off the list and returns a pointer to it.
+ *  Details:
+ *      If the list is empty, returns NULL.
+ *      Else, removes the element at the head of the list, making the next
+ *      element the head of the list.
+ *      The head is removed by making the tail element of the list point its
+ *      "next" pointer at the next element after the head, and by making the
+ *      "prev" pointer of the next element after the head point at the tail
+ *      element.  So the next element after the head becomes the new head of
+ *      the list.
+ *  Parameters:
+ *      pList:  Pointer to list control structure of list whose head
+ *              element is to be removed
+ *  Returns:
+ *      Pointer to element that was at the head of the list (success)
+ *      NULL          No elements in list
+ *  Requires:
+ *      - head.self must be correctly set to &head.
+ *      - LST initialized.
+ *      - pList != NULL.
+ *  Ensures:
+ *  Notes:
+ *      Because the tail of the list points forward (its "next" pointer) to
+ *      the head of the list, and the head of the list points backward (its
+ *      "prev" pointer) to the tail of the list, this list is circular.
+ */
+	extern struct LST_ELEM *LST_GetHead(IN struct LST_LIST *pList);
+
+/*
+ *  ======== LST_Init ========
+ *  Purpose:
+ *      Initializes private state of LST module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ *      LST initialized.
+ */
+	extern bool LST_Init();
+
+/*
+ *  ======== LST_InitElem ========
+ *  Purpose:
+ *      Initializes a list element to default (cleared) values
+ *  Details:
+ *  Parameters:
+ *      pElem:  Pointer to list element to be reset
+ *  Returns:
+ *  Requires:
+ *      LST initialized.
+ *  Ensures:
+ *  Notes:
+ *      This function must not be called to "reset" an element in the middle
+ *      of a list chain -- that would break the chain.
+ *
+ */
+	extern void LST_InitElem(IN struct LST_ELEM *pListElem);
+
+/*
+ *  ======== LST_InsertBefore ========
+ *  Purpose:
+ *     Insert the element before the existing element.
+ *  Parameters:
+ *      pList:          Pointer to list control structure.
+ *      pElem:          Pointer to element in list to insert.
+ *      pElemExisting:  Pointer to existing list element.
+ *  Returns:
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pElem != NULL.
+ *      - pElemExisting != NULL.
+ *  Ensures:
+ */
+	extern void LST_InsertBefore(IN struct LST_LIST *pList,
+				     IN struct LST_ELEM *pElem,
+				     IN struct LST_ELEM *pElemExisting);
+
+/*
+ *  ======== LST_Next ========
+ *  Purpose:
+ *      Returns a pointer to the next element of the list, or NULL if the next
+ *      element is the head of the list or the list is empty.
+ *  Parameters:
+ *      pList:      Pointer to list control structure.
+ *      pCurElem:   Pointer to element in list to remove.
+ *  Returns:
+ *      Pointer to list element, or NULL.
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pCurElem != NULL.
+ *  Ensures:
+ */
+	extern struct LST_ELEM *LST_Next(IN struct LST_LIST *pList,
+					 IN struct LST_ELEM *pCurElem);
+
+/*
+ *  ======== LST_PutTail ========
+ *  Purpose:
+ *      Adds the specified element to the tail of the list
+ *  Details:
+ *      Sets new element's "prev" pointer to the address previously held by
+ *      the head element's prev pointer.  This is the previous tail member of
+ *      the list.
+ *      Sets the new head's prev pointer to the address of the element.
+ *      Sets next pointer of the previous tail member of the list to point to
+ *      the new element (rather than the head, which it had been pointing at).
+ *      Sets new element's next pointer to the address of the head element.
+ *      Sets head's prev pointer to the address of the new element.
+ *  Parameters:
+ *      pList:  Pointer to list control structure to which *pElem will be
+ *              added
+ *      pElem:  Pointer to list element to be added
+ *  Returns:
+ *      Void
+ *  Requires:
+ *      *pElem and *pList must both exist.
+ *      pElem->self = pElem before pElem is passed to this function.
+ *      LST initialized.
+ *  Ensures:
+ *  Notes:
+ *      Because the tail is always "just before" the head of the list (the
+ *      tail's "next" pointer points at the head of the list, and the head's
+ *      "prev" pointer points at the tail of the list), the list is circular.
+ *  Warning: if pElem->self is not set beforehand, LST_GetHead() will
+ *      return an erroneous pointer when it is called for this element.
+ */
+	extern void LST_PutTail(IN struct LST_LIST *pList,
+				IN struct LST_ELEM *pListElem);
+
+/*
+ *  ======== LST_RemoveElem ========
+ *  Purpose:
+ *      Removes (unlinks) the given element from the list, if the list is not
+ *      empty.  Does not free the list element.
+ *  Parameters:
+ *      pList:      Pointer to list control structure.
+ *      pCurElem:   Pointer to element in list to remove.
+ *  Returns:
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pCurElem != NULL.
+ *  Ensures:
+ */
+extern void LST_RemoveElem(IN struct LST_LIST *pList,
+			   IN struct LST_ELEM *pCurElem);
+
+#endif				/* LIST_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
@@ -0,0 +1,213 @@
+/*
+ * bridge/inc/mbx_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== mbx_sh.h ========
+ *  Definitions for shared mailbox cmd/data values.(used on both
+ *     the GPP and DSP sides).
+ *
+ *  Bridge usage of OMAP mailbox 1 is determined by the "class" of the
+ *     mailbox interrupt's cmd value received. The class value are defined
+ *     as a bit (10 thru 15) being set.
+ *
+ *  Note: Only 16 bits of each  is used. Other 16 bit data reg available.
+ *
+ *   16 bit Mbx bit defns:
+ *
+ * A). Exception/Error handling (Module DEH) : class = 0.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|0|0|x|x|x|x|x|x|x|x|x|x|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *
+ *
+ * B: DSP-DMA link driver channels (DDMA) : class = 1.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|0|1|b|b|b|b|b|c|c|c|c|c|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where b -> buffer index  (32 DDMA buffers/chnl max)
+ *         c -> channel Id    (32 DDMA chnls max)
+ *
+ *
+ *
+ *
+ * C: Proc-copy link driver channels (PCPY) : class = 2.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|1|0|x|x|x|x|x|x|x|x|x|x|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *
+ * D: Zero-copy link driver channels (DDZC) : class = 4.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|1|0|0|x|x|x|x|x|c|c|c|c|c|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where x -> not used
+ *         c -> channel Id    (32 ZCPY chnls max)
+ *
+ *
+ * E: Power management : class = 8.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|1|0|0|0|x|x|x|x|x|c|c|c|c|c|
+
+ * 	0010 00xx xxxc cccc
+ *	0010 00nn pppp qqqq
+ *	nn:
+ *	00 = reserved
+ *	01 = pwr state change
+ *	10 = opp pre-change
+ *	11 = opp post-change
+ *
+ *	if nn = pwr state change:
+ *	pppp = don't care
+ *	qqqq:
+ *	0010 = hibernate
+ *	0010 0001 0000 0010
+ *	0110 = retention
+ *	0010 0001 0000 0110
+ *	others reserved
+ *
+ *	if nn = opp pre-change:
+ *	pppp = current opp
+ *	qqqq = next opp
+ *
+ *	if nn = opp post-change:
+ *	pppp = prev opp
+ *	qqqq = current opp
+ *
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where x -> not used
+ *         c -> Power management command
+ *
+ *
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Sep-2002 mr  Added DEH reset const
+ *! 24-Apr-2002 sg  Added more PM commands.
+ *! 04-Mar-2002 gv  Added MBX_PM_CLASS
+ *! 22-Jan-2002 ag  Bug fix in MBX_SETZCPYVAL(x) macro.
+ *! 21-Dec-2001 ag  Added bit masks defns.
+ *! 17-Dec-2001 ag: created.
+ */
+
+#ifndef _MBX_SH_H
+#define _MBX_SH_H
+
+#define MBX_CLASS_MSK      0xFC00	/* Class bits are 10 thru 15 */
+#define MBX_VALUE_MSK      0x03FF	/* Value is 0 thru 9 */
+
+#define MBX_DEH_CLASS      0x0000	/* DEH owns Mbx INTR */
+#define MBX_DDMA_CLASS     0x0400	/* DSP-DMA link drvr chnls owns INTR */
+#define MBX_PCPY_CLASS     0x0800	/* PROC-COPY  " */
+#define MBX_ZCPY_CLASS     0x1000	/* ZERO-COPY  " */
+#define MBX_PM_CLASS       0x2000	/* Power Management */
+#define MBX_DBG_CLASS      0x4000	/* For debugging purpose */
+
+/*
+ * Exception Handler codes
+ * Magic code used to determine if DSP signaled exception.
+ */
+#define MBX_DEH_BASE        0x0
+#define MBX_DEH_USERS_BASE  0x100	/* 256 */
+#define MBX_DEH_LIMIT       0x3FF	/* 1023 */
+#define MBX_DEH_RESET       0x101	/* DSP RESET (DEH) */
+#define MBX_DEH_EMMU        0X103 /*DSP MMU FAULT RECOVERY*/
+
+/*
+ *  Link driver command/status codes.
+ */
+/* DSP-DMA */
+#define MBX_DDMA_NUMCHNLBITS 5	/* # chnl Id: # bits available */
+#define MBX_DDMA_CHNLSHIFT   0	/* # of bits to shift */
+#define MBX_DDMA_CHNLMSK     0x01F	/* bits 0 thru 4 */
+
+#define MBX_DDMA_NUMBUFBITS  5	/* buffer index: # of bits avail */
+#define MBX_DDMA_BUFSHIFT    (MBX_DDMA_NUMCHNLBITS + MBX_DDMA_CHNLSHIFT)
+#define MBX_DDMA_BUFMSK      0x3E0	/* bits 5 thru 9 */
+
+/* Zero-Copy */
+#define MBX_ZCPY_NUMCHNLBITS 5	/* # chnl Id: # bits available */
+#define MBX_ZCPY_CHNLSHIFT   0	/* # of bits to shift */
+#define MBX_ZCPY_CHNLMSK     0x01F	/* bits 0 thru 4 */
+
+/*  Power Management Commands */
+#define MBX_PM_DSPIDLE                  (MBX_PM_CLASS + 0x0)
+#define MBX_PM_DSPWAKEUP                (MBX_PM_CLASS + 0x1)
+#define MBX_PM_EMERGENCYSLEEP           (MBX_PM_CLASS + 0x2)
+#define MBX_PM_SLEEPUNTILRESTART        (MBX_PM_CLASS + 0x3)
+#define MBX_PM_DSPGLOBALIDLE_OFF        (MBX_PM_CLASS + 0x4)
+#define MBX_PM_DSPGLOBALIDLE_ON         (MBX_PM_CLASS + 0x5)
+#define MBX_PM_SETPOINT_PRENOTIFY       (MBX_PM_CLASS + 0x6)
+#define MBX_PM_SETPOINT_POSTNOTIFY      (MBX_PM_CLASS + 0x7)
+#define MBX_PM_DSPRETN                  (MBX_PM_CLASS + 0x8)
+#define MBX_PM_DSPRETENTION        (MBX_PM_CLASS + 0x8)
+#define MBX_PM_DSPHIBERNATE        (MBX_PM_CLASS + 0x9)
+#define MBX_PM_HIBERNATE_EN        (MBX_PM_CLASS + 0xA)
+#define MBX_PM_OPP_REQ                  (MBX_PM_CLASS + 0xB)
+#define MBX_PM_OPP_CHG                  (MBX_PM_CLASS + 0xC)
+
+#define MBX_PM_TYPE_MASK 0x0300
+#define MBX_PM_TYPE_PWR_CHNG 0x0100
+#define MBX_PM_TYPE_OPP_PRECHNG 0x0200
+#define MBX_PM_TYPE_OPP_POSTCHNG 0x0300
+#define MBX_PM_TYPE_OPP_MASK 0x0300
+#define MBX_PM_OPP_PRECHNG (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG)
+/* DSP to MPU */
+#define MBX_PM_OPP_CHNG(OPP) (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG | (OPP))
+#define MBX_PM_RET (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0006)
+#define MBX_PM_HIB (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0002)
+#define MBX_PM_OPP_1 0
+#define MBX_PM_OPP_2 1
+#define MBX_PM_OPP_3 2
+#define MBX_PM_OPP_4 3
+#define MBX_OLDOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
+#define MBX_NEWOPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
+#define MBX_PREVOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
+#define MBX_CUROPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
+
+/* Bridge Debug Commands */
+#define MBX_DBG_SYSPRINTF       (MBX_DBG_CLASS + 0x0)
+
+/*
+ * Useful macros
+ */
+/* DSP-DMA channel */
+#define MBX_SETDDMAVAL(x, y)  (MBX_DDMA_CLASS | (x << MBX_DDMA_BUFSHIFT) | \
+	(y << MBX_DDMA_CHNLSHIFT))
+
+/* Zero-Copy channel */
+#define MBX_SETZCPYVAL(x)  (MBX_ZCPY_CLASS | (x << MBX_ZCPY_CHNLSHIFT))
+
+#endif				/* _MBX_SH_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/memdefs.h
@@ -0,0 +1,52 @@
+/*
+ * bridge/inc/memdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== memdefs.h ========
+ *  Purpose:
+ *      Global MEM constants and types, shared between WSX, WCD, and WMD.
+ *
+ *! Revision History:
+ *! ================
+ *! 28-Aug-2001 ag:  Added MEM_[SET][GET]VIRTUALSEGID.
+ *! 10-Aug-1999 kc:  Based on wsx-c18.
+ *! 15-Nov-1996 gp:  Renamed from wsxmem.h and moved to kwinos.
+ *! 21-Aug-1996 cr:  Created from mem.h.
+ */
+
+#ifndef MEMDEFS_
+#define MEMDEFS_
+
+/* Memory Pool Attributes: */
+	enum MEM_POOLATTRS {
+		MEM_PAGED = 0,
+		MEM_NONPAGED = 1,
+		MEM_LARGEVIRTMEM = 2
+	} ;
+
+/*
+ *  MEM_VIRTUALSEGID is used by Node & Strm to access virtual address space in
+ *  the correct client process context.
+ */
+#define MEM_SETVIRTUALSEGID     0x10000000
+#define MEM_GETVIRTUALSEGID     0x20000000
+#define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
+
+#define TO_VIRTUAL_UNCACHED(x) x
+#define INTREG_TO_VIRTUAL_UNCACHED(x) x
+
+#endif				/* MEMDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -0,0 +1,340 @@
+/*
+ * bridge/inc/mem.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== mem.h ========
+ *  Purpose:
+ *      Memory management and address mapping services for the DSP/BIOS Bridge
+ *      class driver and mini-driver.
+ *
+ *  Public Functions:
+ *      MEM_Alloc
+ *      MEM_AllocObject
+ *      MEM_AllocPhysMem
+ *      MEM_Calloc
+ *      MEM_Exit
+ *      MEM_FlushCache
+ *      MEM_Free
+ *      MEM_FreeObject
+ *      MEM_FreePhysMem
+ *      MEM_GetNumPages
+ *      MEM_Init
+ *      MEM_IsValidHandle
+ *      MEM_LinearAddress
+ *      MEM_PageLock
+ *      MEM_PageUnlock
+ *      MEM_UnMapLinearAddress
+ *      MEM_VirtualToPhysical
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
+ *! 01-Sep-2001 ag: Cleaned up notes for MEM_LinearAddress() does not
+ *!                   require phys address to be page aligned!
+ *! 02-Dec-1999 rr: stdwin.h included for retail build
+ *! 12-Nov-1999 kc: Added warning about use of MEM_LinearAddress.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 10-Aug-1999 kc: Based on wsx-c18.
+ *! 07-Jan-1998 gp: Added MEM_AllocUMB and MEM_UMBFree for User Mapped Buffers
+ *!                 used by WMD_CHNL.
+ *! 23-Dec-1997 cr: Code review cleanup, removed dead Ring 3 code.
+ *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
+ *! 01-Nov-1996 gp: Updated based on code review.
+ *! 04-Sep-1996 gp: Added MEM_PageLock() and MEM_PageUnlock() services.
+ *! 14-Aug-1996 mg: Added MEM_GetPhysAddr() and MEM_GetNumPages()
+ *! 25-Jul-1996 gp: Added MEM_IsValidHandle() macro.
+ *! 10-May-1996 gp: Added MEM_Calloc().
+ *! 25-Apr-1996 gp: Added MEM_PhysicalAddress()
+ *! 17-Apr-1996 gp: Added MEM_Exit function; updated to latest naming standard.
+ *! 08-Apr-1996 gp: Created.
+ */
+
+#ifndef MEM_
+#define MEM_
+
+#include <host_os.h>
+#include <memdefs.h>
+
+/*
+ *  ======== MEM_Alloc ========
+ *  Purpose:
+ *      Allocate memory from the paged or non-paged pools.
+ *  Parameters:
+ *      cBytes: Number of bytes to allocate.
+ *      type:   Type of memory to allocate; one of:
+ *              MEM_PAGED: Allocate from pageable memory.
+ *              MEM_NONPAGED: Allocate from page locked memory.
+ *  Returns:
+ *      Pointer to a block of memory;
+ *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      not one of MEM_PAGED or MEM_NONPAGED.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.
+ */
+	extern void *MEM_Alloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+
+/*
+ *  ======== MEM_AllocObject ========
+ *  Purpose:
+ *      Allocate an object, and set it's signature.
+ *  Parameters:
+ *      pObj:       Pointer to the new object.
+ *      Obj:        Type of the object to allocate.
+ *      Signature:  Magic field value.  Must be non-zero.
+ *  Returns:
+ *  Requires:
+ *      Same requirements as MEM_Calloc(); and
+ *      The object structure has a dwSignature field.  The compiler ensures
+ *      this requirement.
+ *  Ensures:
+ *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
+ */
+#define MEM_AllocObject(pObj, Obj, Signature)           \
+{                                                       \
+    pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);       \
+    if (pObj) {                                         \
+	pObj->dwSignature = Signature;                  \
+    }                                                   \
+}
+
+/*  ======== MEM_AllocPhysMem ========
+ *  Purpose:
+ *      Allocate physically contiguous, uncached memory
+ *  Parameters:
+ *      cBytes:     Number of bytes to allocate.
+ *      ulAlign:    Alignment Mask.
+ *      pPhysicalAddress: Physical address of allocated memory.
+ *  Returns:
+ *      Pointer to a block of memory;
+ *      NULL if memory couldn't be allocated, or if cBytes == 0.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.  Returned physical address refers to physical
+ *      location of memory.
+ */
+	extern void *MEM_AllocPhysMem(IN u32 cBytes,
+				      IN u32 ulAlign,
+				      OUT u32 *pPhysicalAddress);
+
+/*
+ *  ======== MEM_Calloc ========
+ *  Purpose:
+ *      Allocate zero-initialized memory from the paged or non-paged pools.
+ *  Parameters:
+ *      cBytes: Number of bytes to allocate.
+ *      type:   Type of memory to allocate; one of:
+ *              MEM_PAGED:   Allocate from pageable memory.
+ *              MEM_NONPAGED: Allocate from page locked memory.
+ *  Returns:
+ *      Pointer to a block of zeroed memory;
+ *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      not one of MEM_PAGED or MEM_NONPAGED.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block
+ *      of the size requested.
+ */
+	extern void *MEM_Calloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+
+/*
+ *  ======== MEM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MEM is initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void MEM_Exit();
+
+/*
+ *  ======== MEM_FlushCache ========
+ *  Purpose:
+ *      Performs system cache sync with discard
+ *  Parameters:
+ *      pMemBuf:    Pointer to memory region to be flushed.
+ *      pMemBuf:    Size of the memory region to be flushed.
+ *  Returns:
+ *  Requires:
+ *      MEM is initialized.
+ *  Ensures:
+ *      Cache is synchronized
+ */
+	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+
+/*
+ *  ======== MEM_Free ========
+ *  Purpose:
+ *      Free the given block of system memory.
+ *  Parameters:
+ *      pMemBuf:    Pointer to memory allocated by MEM_Calloc/Alloc().
+ *  Returns:
+ *  Requires:
+ *      MEM initialized.
+ *      pMemBuf is a valid memory address returned by MEM_Calloc/Alloc().
+ *  Ensures:
+ *      pMemBuf is no longer a valid pointer to memory.
+ */
+	extern void MEM_Free(IN void *pMemBuf);
+
+/*
+ *  ======== MEM_FreePhysMem ========
+ *  Purpose:
+ *      Free the given block of physically contiguous memory.
+ *  Parameters:
+ *      pVirtualAddress:  Pointer to virtual memory region allocated
+ *      by MEM_AllocPhysMem().
+ *      pPhysicalAddress:  Pointer to physical memory region  allocated
+ *      by MEM_AllocPhysMem().
+ *      cBytes:  Size of the memory region allocated by MEM_AllocPhysMem().
+ *  Returns:
+ *  Requires:
+ *      MEM initialized.
+ *      pVirtualAddress is a valid memory address returned by
+ *          MEM_AllocPhysMem()
+ *  Ensures:
+ *      pVirtualAddress is no longer a valid pointer to memory.
+ */
+	extern void MEM_FreePhysMem(void *pVirtualAddress,
+				    u32 pPhysicalAddress, u32 cBytes);
+
+/*
+ *  ======== MEM_FreeObject ========
+ *  Purpose:
+ *      Utility macro to invalidate an object's signature, and deallocate it.
+ *  Parameters:
+ *      pObj:   Pointer to the object to free.
+ *  Returns:
+ *  Requires:
+ *      Same requirements as MEM_Free().
+ *  Ensures:
+ *      A subsequent call to MEM_IsValidHandle() will fail for this object.
+ */
+#define MEM_FreeObject(pObj)    \
+{                               \
+    pObj->dwSignature = 0x00;   \
+    MEM_Free(pObj);             \
+}
+
+/*
+ *  ======== MEM_GetNumPages ========
+ *  Purpose:
+ *      Calculate the number of pages corresponding to the supplied buffer.
+ *  Parameters:
+ *      pAddr:  Linear (virtual) address of the buffer.
+ *      cBytes: Number of bytes in the buffer.
+ *  Returns:
+ *      Number of pages.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      If cBytes > 0, number of pages returned > 0.
+ */
+	extern s32 MEM_GetNumPages(IN void *pAddr, IN u32 cBytes);
+
+/*
+ *  ======== MEM_Init ========
+ *  Purpose:
+ *      Initializes private state of MEM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      MEM initialized.
+ */
+	extern bool MEM_Init();
+
+/*
+ *  ======== MEM_IsValidHandle ========
+ *  Purpose:
+ *      Validate the object handle.
+ *  Parameters:
+ *      hObj:   Handle to object created with MEM_AllocObject().
+ *      Sig:    Expected signature u32.
+ *  Returns:
+ *      TRUE if handle is valid; FALSE otherwise.
+ *  Requires:
+ *      The object structure has a dwSignature field. Ensured by compiler.
+ *  Ensures:
+ */
+#define MEM_IsValidHandle(hObj, Sig)                \
+     ((hObj != NULL) && (hObj->dwSignature == Sig))
+
+/*
+ *  ======== MEM_LinearAddress ========
+ *  Purpose:
+ *      Get the linear address corresponding to the given physical address.
+ *  Parameters:
+ *      pPhysAddr:  Physical address to be mapped.
+ *      cBytes:     Number of bytes in physical range to map.
+ *  Returns:
+ *      The corresponding linear address, or NULL if unsuccessful.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *  Notes:
+ *      If valid linear address is returned, be sure to call
+ *      MEM_UnmapLinearAddress().
+ */
+#define MEM_LinearAddress(pPhyAddr, cBytes) pPhyAddr
+
+/*
+ *  ======== MEM_UnmapLinearAddress ========
+ *  Purpose:
+ *      Unmap the linear address mapped in MEM_LinearAddress.
+ *  Parameters:
+ *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LinearAddress()).
+ *  Returns:
+ *  Requires:
+ *      - MEM initialized.
+ *      - pBaseAddr is a valid linear address mapped in MEM_LinearAddress.
+ *  Ensures:
+ *      - pBaseAddr no longer points to a valid linear address.
+ */
+#define MEM_UnmapLinearAddress(pBaseAddr)
+
+/*
+ *  ======== MEM_ExtPhysPoolInit ========
+ *  Purpose:
+ *      Uses the physical memory chunk passed for internal consitent memory
+ *      allocations.
+ *      physical address based on the page frame address.
+ *  Parameters:
+ *      poolPhysBase  starting address of the physical memory pool.
+ *      poolSize      size of the physical memory pool.
+ *  Returns:
+ *      none.
+ *  Requires:
+ *      - MEM initialized.
+ *      - valid physical address for the base and size > 0
+ */
+	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
+					IN u32 poolSize);
+
+#endif				/* MEM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mgr.h
@@ -0,0 +1,234 @@
+/*
+ * bridge/inc/mgr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== mgr.h ========
+ *  Description:
+ *      This is the Class driver RM module interface.
+ *
+ *  Public Functions:
+ *      MGR_Create
+ *      MGR_Destroy
+ *      MGR_EnumNodeInfo
+ *      MGR_EnumProcessorInfo
+ *      MGR_Exit
+ *      MGR_GetDCDHandle
+ *      MGR_Init
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 15-Oct-2002 kc: Removed legacy PERF definitions.
+ *! 11-Jul-2001 jeh Added CFG_HDEVNODE parameter to MGR_Create().
+ *! 22-Nov-2000 kc: Added MGR_GetPerfData for acquiring PERF stats.
+ *! 03-Nov-2000 rr: Added MGR_GetDCDHandle. Modified after code review.
+ *! 25-Sep-2000 rr: Updated to Version 0.9
+ *! 14-Aug-2000 rr: Cleaned up.
+ *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
+ *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types).
+ *! 20-Jun-2000 rr: Created.
+ */
+
+#ifndef MGR_
+#define MGR_
+
+#include <mgrpriv.h>
+
+#define MAX_EVENTS 32
+
+/*
+ *  ======== MGR_WaitForBridgeEvents ========
+ *  Purpose:
+ *      Block on any Bridge event(s)
+ *  Parameters:
+ *      aNotifications  : array of pointers to notification objects.
+ *      uCount          : number of elements in above array
+ *      puIndex         : index of signaled event object
+ *      uTimeout        : timeout interval in milliseocnds
+ *  Returns:
+ *      DSP_SOK         : Success.
+ *      DSP_ETIMEOUT    : Wait timed out. *puIndex is undetermined.
+ *  Details:
+ */
+
+	DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION
+					   **aNotifications,
+					   u32 uCount, OUT u32 *puIndex,
+					   u32 uTimeout);
+
+/*
+ *  ======== MGR_Create ========
+ *  Purpose:
+ *      Creates the Manager Object. This is done during the driver loading.
+ *      There is only one Manager Object in the DSP/BIOS Bridge.
+ *  Parameters:
+ *      phMgrObject:    Location to store created MGR Object handle.
+ *      hDevNode:       Device object as known to Windows system.
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EMEMORY:    Failed to Create the Object
+ *      DSP_EFAIL:      General Failure
+ *  Requires:
+ *      MGR Initialized (cRefs > 0 )
+ *      phMgrObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *phMgrObject is a valid MGR interface to the device.
+ *                      MGR Object stores the DCD Manager Handle.
+ *                      MGR Object stored in the Regsitry.
+ *      !DSP_SOK:       MGR Object not created
+ *  Details:
+ *      DCD Dll is loaded and MGR Object stores the handle of the DLL.
+ */
+	extern DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **hMgrObject,
+				     struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== MGR_Destroy ========
+ *  Purpose:
+ *      Destroys the MGR object. Called upon driver unloading.
+ *  Parameters:
+ *      hMgrObject:     Handle to Manager object .
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *                      DCD Manager freed; MGR Object destroyed;
+ *                      MGR Object deleted from the Registry.
+ *      DSP_EFAIL:      Failed to destroy MGR Object
+ *  Requires:
+ *      MGR Initialized (cRefs > 0 )
+ *      hMgrObject is a valid MGR handle .
+ *  Ensures:
+ *      DSP_SOK:        MGR Object destroyed and hMgrObject is Invalid MGR
+ *                      Handle.
+ */
+	extern DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject);
+
+/*
+ *  ======== MGR_EnumNodeInfo ========
+ *  Purpose:
+ *      Enumerate and get configuration information about nodes configured
+ *      in the node database.
+ *  Parameters:
+ *      uNode:              The node index (base 0).
+ *      pNDBProps:          Ptr to the DSP_NDBPROPS structure for output.
+ *      uNDBPropsSize:      Size of the DSP_NDBPROPS structure.
+ *      puNumNodes:         Location where the number of nodes configured
+ *                          in the database will be returned.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EINVALIDARG:    Parameter uNode is > than the number of nodes.
+ *                          configutred in the system
+ *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
+ *                              the number of nodes configured or in the
+ *                              the properties of the enumerated nodes.
+ *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *  Requires:
+ *      pNDBPROPS is not null
+ *      uNDBPropsSize >= sizeof(DSP_NDBPROPS)
+ *      puNumNodes is not null
+ *      MGR Initialized (cRefs > 0 )
+ *  Ensures:
+ *      SUCCESS on successful retreival of data and *puNumNodes > 0 OR
+ *      DSP_FAILED  && *puNumNodes == 0.
+ *  Details:
+ */
+	extern DSP_STATUS MGR_EnumNodeInfo(u32 uNode,
+					   OUT struct DSP_NDBPROPS *pNDBProps,
+					   u32 uNDBPropsSize,
+					   OUT u32 *puNumNodes);
+
+/*
+ *  ======== MGR_EnumProcessorInfo ========
+ *  Purpose:
+ *      Enumerate and get configuration information about available DSP
+ *      processors
+ *  Parameters:
+ *      uProcessor:         The processor index (zero-based).
+ *      pProcessorInfo:     Ptr to the DSP_PROCESSORINFO structure .
+ *      uProcessorInfoSize: Size of DSP_PROCESSORINFO structure.
+ *      puNumProcs:         Location where the number of DSPs configured
+ *                          in the database will be returned
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EINVALIDARG:    Parameter uProcessor is > than the number of
+ *                          DSP Processors in the system.
+ *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *  Requires:
+ *      pProcessorInfo is not null
+ *      puNumProcs is not null
+ *      uProcessorInfoSize >= sizeof(DSP_PROCESSORINFO)
+ *      MGR Initialized (cRefs > 0 )
+ *  Ensures:
+ *      SUCCESS on successful retreival of data and *puNumProcs > 0 OR
+ *      DSP_FAILED && *puNumProcs == 0.
+ *  Details:
+ */
+	extern DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
+						OUT struct DSP_PROCESSORINFO *
+						pProcessorInfo,
+						u32 uProcessorInfoSize,
+						OUT u32 *puNumProcs);
+/*
+ *  ======== MGR_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MGR is initialized.
+ *  Ensures:
+ *      When reference count == 0, MGR's private resources are freed.
+ */
+       extern void MGR_Exit();
+
+/*
+ *  ======== MGR_GetDCDHandle ========
+ *  Purpose:
+ *      Retrieves the MGR handle. Accessor Function
+ *  Parameters:
+ *      hMGRHandle:     Handle to the Manager Object
+ *      phDCDHandle:    Ptr to receive the DCD Handle.
+ *  Returns:
+ *      DSP_SOK:        Sucess
+ *      DSP_EFAIL:      Failure to get the Handle
+ *  Requires:
+ *      MGR is initialized.
+ *      phDCDHandle != NULL
+ *  Ensures:
+ *      DSP_SOK and *phDCDHandle != NULL ||
+ *      DSP_EFAIL and *phDCDHandle == NULL
+ */
+       extern DSP_STATUS MGR_GetDCDHandle(IN struct MGR_OBJECT
+						 *hMGRHandle,
+						 OUT u32 *phDCDHandle);
+
+/*
+ *  ======== MGR_Init ========
+ *  Purpose:
+ *      Initialize MGR's private state, keeping a reference count on each
+ *      call. Intializes the DCD.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public MGR functions.
+ */
+       extern bool MGR_Init();
+
+#endif				/* MGR_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
@@ -0,0 +1,55 @@
+/*
+ * bridge/inc/mgrpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== mgrpriv.h ========
+ *  Description:
+ *      Global MGR constants and types, shared by PROC, MGR, and WCD.
+ *
+ *! Revision History:
+ *! ================
+ *! 29-July-2001 ag: added MGR_PROCESSOREXTINFO.
+ *! 05-July-2000 rr: Created
+ */
+
+#ifndef MGRPRIV_
+#define MGRPRIV_
+
+/*
+ * OMAP1510 specific
+ */
+#define MGR_MAXTLBENTRIES  32
+
+/* RM MGR Object */
+	struct MGR_OBJECT;
+
+	struct MGR_TLBENTRY {
+		u32 ulDspVirt;	/* DSP virtual address */
+		u32 ulGppPhys;	/* GPP physical address */
+	} ;
+
+/*
+ *  The DSP_PROCESSOREXTINFO structure describes additional extended
+ *  capabilities of a DSP processor not exposed to user.
+ */
+	struct MGR_PROCESSOREXTINFO {
+		struct DSP_PROCESSORINFO tyBasic;    /* user processor info */
+		/* private dsp mmu entries */
+		struct MGR_TLBENTRY tyTlb[MGR_MAXTLBENTRIES];
+	} ;
+
+#endif				/* MGRPRIV_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/msgdefs.h
@@ -0,0 +1,43 @@
+/*
+ * bridge/inc/msgdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== msgdefs.h ========
+ *  Description:
+ *      Global MSG constants and types.
+ *
+ *! Revision History
+ *! ================
+ *! 09-May-2001 jeh Removed MSG_TODSP, MSG_FROMDSP.
+ *! 17-Nov-2000 jeh Added MSGMGR_SIGNATURE.
+ *! 12-Sep-2000 jeh Created.
+ */
+
+#ifndef MSGDEFS_
+#define MSGDEFS_
+
+#define MSGMGR_SIGNATURE    0x4d47534d	/* "MGSM" */
+
+/* MSG Objects: */
+	struct MSG_MGR;
+	struct MSG_QUEUE;
+
+/* Function prototype for callback to be called on RMS_EXIT message received */
+       typedef void(*MSG_ONEXIT) (HANDLE h, s32 nStatus);
+
+#endif				/* MSGDEFS_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/msg.h
@@ -0,0 +1,106 @@
+/*
+ * bridge/inc/msg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== msg.h ========
+ *  Description:
+ *      DSP/BIOS Bridge MSG Module.
+ *
+ *  Public Functions:
+ *      MSG_Create
+ *      MSG_Delete
+ *      MSG_Exit
+ *      MSG_Init
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! =================
+ *! 17-Nov-2000 jeh     Removed MSG_Get, MSG_Put, MSG_CreateQueue,
+ *!                     MSG_DeleteQueue, and MSG_RegisterNotify, since these
+ *!                     are now part of mini-driver.
+ *! 12-Sep-2000 jeh     Created.
+ */
+
+#ifndef MSG_
+#define MSG_
+
+#include <devdefs.h>
+#include <msgdefs.h>
+
+/*
+ *  ======== MSG_Create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object. The MSG manager must be created before
+ *      the IO Manager.
+ *  Parameters:
+ *      phMsgMgr:           Location to store MSG manager handle on output.
+ *      hDevObject:         The device object.
+ *      msgCallback:        Called whenever an RMS_EXIT message is received.
+ *  Returns:
+ *  Requires:
+ *      MSG_Init() called.
+ *      phMsgMgr != NULL.
+ *      hDevObject != NULL.
+ *      msgCallback != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     MSG_ONEXIT msgCallback);
+
+/*
+ *  ======== MSG_Delete ========
+ *  Purpose:
+ *      Delete a MSG manager allocated in MSG_Create().
+ *  Parameters:
+ *      hMsgMgr:            Handle returned from MSG_Create().
+ *  Returns:
+ *  Requires:
+ *      MSG_Init() called.
+ *      Valid hMsgMgr.
+ *  Ensures:
+ */
+	extern void MSG_Delete(struct MSG_MGR *hMsgMgr);
+
+/*
+ *  ======== MSG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of MSG module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MSG_Init() successfully called before.
+ *  Ensures:
+ *      Any resources acquired in MSG_Init() will be freed when last MSG
+ *      client calls MSG_Exit().
+ */
+	extern void MSG_Exit();
+
+/*
+ *  ======== MSG_Init ========
+ *  Purpose:
+ *      Initialize the MSG module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool MSG_Init();
+
+#endif				/* MSG_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
@@ -0,0 +1,307 @@
+/*
+ * bridge/inc/nldrdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== nldrdefs.h ========
+ *  Description:
+ *      Global Dynamic + static/overlay Node loader (NLDR) constants and types.
+ *
+ *! Revision History
+ *! ================
+ *! 07-Apr-2003 map     Consolidated dldrdefs.h into nldrdefs.h
+ *! 05-Aug-2002 jeh     Created.
+ */
+
+#ifndef NLDRDEFS_
+#define NLDRDEFS_
+
+#include <dbdcddef.h>
+#include <devdefs.h>
+
+#define NLDR_MAXPATHLENGTH       255
+/* NLDR Objects: */
+	struct  NLDR_OBJECT;
+	struct NLDR_NODEOBJECT;
+
+/*
+ *  ======== NLDR_LOADTYPE ========
+ *  Load types for a node. Must match values in node.h55.
+ */
+	enum NLDR_LOADTYPE {
+		NLDR_STATICLOAD,	/* Linked in base image, not overlay */
+		NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
+		NLDR_OVLYLOAD	/* Linked in base image, overlay node */
+	} ;
+
+/*
+ *  ======== NLDR_OVLYFXN ========
+ *  Causes code or data to be copied from load address to run address. This
+ *  is the "COD_WRITEFXN" that gets passed to the DBLL_Library and is used as
+ *  the ZL write function.
+ *
+ *  Parameters:
+ *      pPrivRef:       Handle to identify the node.
+ *      ulDspRunAddr:   Run address of code or data.
+ *      ulDspLoadAddr:  Load address of code or data.
+ *      ulNumBytes:     Number of (GPP) bytes to copy.
+ *      nMemSpace:      RMS_CODE or RMS_DATA.
+ *  Returns:
+ *      ulNumBytes:     Success.
+ *      0:              Failure.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef u32(*NLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
+					     u32 ulDspLoadAddr,
+					     u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== NLDR_WRITEFXN ========
+ *  Write memory function. Used for dynamic load writes.
+ *  Parameters:
+ *      pPrivRef:       Handle to identify the node.
+ *      ulDspAddr:      Address of code or data.
+ *      pBuf:           Code or data to be written
+ *      ulNumBytes:     Number of (GPP) bytes to write.
+ *      nMemSpace:      DBLL_DATA or DBLL_CODE.
+ *  Returns:
+ *      ulNumBytes:     Success.
+ *      0:              Failure.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef u32(*NLDR_WRITEFXN) (void *pPrivRef,
+					      u32 ulDspAddr, void *pBuf,
+					      u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== NLDR_ATTRS ========
+ *  Attributes passed to NLDR_Create function.
+ */
+	struct NLDR_ATTRS {
+		NLDR_OVLYFXN pfnOvly;
+		NLDR_WRITEFXN pfnWrite;
+		u16 usDSPWordSize;
+		u16 usDSPMauSize;
+	} ;
+
+/*
+ *  ======== NLDR_PHASE ========
+ *  Indicates node create, delete, or execute phase function.
+ */
+	enum NLDR_PHASE {
+		NLDR_CREATE,
+		NLDR_DELETE,
+		NLDR_EXECUTE,
+		NLDR_NOPHASE
+	} ;
+
+/*
+ *  Typedefs of loader functions imported from a DLL, or defined in a
+ *  function table.
+ */
+
+/*
+ *  ======== NLDR_Allocate ========
+ *  Allocate resources to manage the loading of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldr:          Handle of loader that will load the node.
+ *      pPrivRef:       Handle to identify the node.
+ *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
+ *      phNldrNode:     Location to store node handle on output. This handle
+ *                      will be passed to NLDR_Load/NLDR_Unload.
+ *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldr.
+ *      pNodeProps != NULL.
+ *      phNldrNode != NULL.
+ *  Ensures:
+ *      DSP_SOK:        IsValidNode(*phNldrNode).
+ *      error:          *phNldrNode == NULL.
+ */
+	typedef DSP_STATUS(*NLDR_ALLOCATEFXN) (struct NLDR_OBJECT *hNldr,
+					       void *pPrivRef,
+					       IN CONST struct DCD_NODEPROPS
+					       *pNodeProps,
+					       OUT struct NLDR_NODEOBJECT
+					       **phNldrNode,
+					       OUT bool *pfPhaseSplit);
+
+/*
+ *  ======== NLDR_Create ========
+ *  Create a loader object. This object handles the loading and unloading of
+ *  create, delete, and execute phase functions of nodes on the DSP target.
+ *
+ *  Parameters:
+ *      phNldr:         Location to store loader handle on output.
+ *      hDevObject:     Device for this processor.
+ *      pAttrs:         Loader attributes.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *  Requires:
+ *      NLDR_Init() called.
+ *      phNldr != NULL.
+ *      hDevObject != NULL.
+ *	pAttrs != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valid *phNldr.
+ *      error:          *phNldr == NULL.
+ */
+	typedef DSP_STATUS(*NLDR_CREATEFXN) (OUT struct NLDR_OBJECT **phNldr,
+					     struct DEV_OBJECT *hDevObject,
+					     IN CONST struct NLDR_ATTRS
+					     *pAttrs);
+
+/*
+ *  ======== NLDR_Delete ========
+ *  Delete the NLDR loader.
+ *
+ *  Parameters:
+ *      hNldr:          Node manager object.
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldr.
+ *  Ensures:
+ *	hNldr invalid
+ */
+	typedef void(*NLDR_DELETEFXN) (struct NLDR_OBJECT *hNldr);
+
+/*
+ *  ======== NLDR_Exit ========
+ *  Discontinue usage of NLDR module.
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init() successfully called before.
+ *  Ensures:
+ *      Any resources acquired in NLDR_Init() will be freed when last NLDR
+ *      client calls NLDR_Exit().
+ */
+	typedef void(*NLDR_EXITFXN) ();
+
+/*
+ *  ======== NLDR_Free ========
+ *  Free resources allocated in NLDR_Allocate.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef void(*NLDR_FREEFXN) (struct NLDR_NODEOBJECT *hNldrNode);
+
+/*
+ *  ======== NLDR_GetFxnAddr ========
+ *  Get address of create, delete, or execute phase function of a node on
+ *  the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      pstrFxn:        Name of function.
+ *      pulAddr:        Location to store function address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ESYMBOL:    Address of function not found.
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldrNode.
+ *      pulAddr != NULL;
+ *      pstrFxn != NULL;
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_GETFXNADDRFXN) (struct NLDR_NODEOBJECT
+						 *hNldrNode,
+						 char *pstrFxn, u32 *pulAddr);
+
+/*
+ *  ======== NLDR_Init ========
+ *  Initialize the NLDR module.
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	typedef bool(*NLDR_INITFXN) ();
+
+/*
+ *  ======== NLDR_Load ========
+ *  Load create, delete, or execute phase function of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      phase:          Type of function to load (create, delete, or execute).
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EMEMORY:            Insufficient memory on GPP.
+ *      DSP_EOVERLAYMEMORY:     Can't overlay phase because overlay memory
+ *                              is already in use.
+ *      DSP_EDYNLOAD:           Failure in dynamic loader library.
+ *      DSP_EFWRITE:            Failed to write phase's code or date to target.
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_LOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
+					   enum NLDR_PHASE phase);
+
+/*
+ *  ======== NLDR_Unload ========
+ *  Unload create, delete, or execute phase function of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      phase:          Node function to unload (create, delete, or execute).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *  Requires:
+ *      NLDR_Init() called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_UNLOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
+					     enum NLDR_PHASE phase);
+
+/*
+ *  ======== NLDR_FXNS ========
+ */
+	struct NLDR_FXNS {
+		NLDR_ALLOCATEFXN pfnAllocate;
+		NLDR_CREATEFXN pfnCreate;
+		NLDR_DELETEFXN pfnDelete;
+		NLDR_EXITFXN pfnExit;
+		NLDR_FREEFXN pfnFree;
+		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
+		NLDR_INITFXN pfnInit;
+		NLDR_LOADFXN pfnLoad;
+		NLDR_UNLOADFXN pfnUnload;
+	} ;
+
+#endif				/* NLDRDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nldr.h
@@ -0,0 +1,81 @@
+/*
+ * bridge/inc/nldr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== nldr.h ========
+ *
+ *  Description:
+ *      DSP/BIOS Bridge dynamic loader interface. See the file dldrdefs.h
+ *  for a description of these functions.
+ *
+ *  Public Functions:
+ *      NLDR_Allocate
+ *      NLDR_Create
+ *      NLDR_Delete
+ *      NLDR_Exit
+ *      NLDR_Free
+ *      NLDR_GetFxnAddr
+ *      NLDR_Init
+ *      NLDR_Load
+ *      NLDR_Unload
+ *
+ *  Notes:
+ *
+ *! Revision History
+ *! ================
+ *! 31-Jul-2002 jeh     Removed function header comments.
+ *! 17-Apr-2002 jeh     Created.
+ */
+
+#include <dbdefs.h>
+#include <dbdcddef.h>
+#include <dev.h>
+#include <rmm.h>
+#include <nldrdefs.h>
+
+#ifndef NLDR_
+#define NLDR_
+
+	extern DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr,
+					void *pPrivRef,
+					IN CONST struct DCD_NODEPROPS
+					*pNodeProps,
+					OUT struct NLDR_NODEOBJECT **phNldrNode,
+					IN bool *pfPhaseSplit);
+
+	extern DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct NLDR_ATTRS *pAttrs);
+
+	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
+	extern void NLDR_Exit(void);
+	extern void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode);
+
+	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
+					  char *pstrFxn, u32 *pulAddr);
+
+	extern DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
+					     OUT struct RMM_TargetObj
+					     **phRmmMgr);
+
+	extern bool NLDR_Init(void);
+	extern DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode,
+				    enum NLDR_PHASE phase);
+	extern DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode,
+				    enum NLDR_PHASE phase);
+
+#endif				/* NLDR_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nodedefs.h
@@ -0,0 +1,40 @@
+/*
+ * bridge/inc/nodedefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== nodedefs.h ========
+ *  Description:
+ *      Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
+ *! Revision History
+ *! ================
+ *! 23-Apr-2001 jeh     Removed NODE_MGRATTRS.
+ *! 21-Sep-2000 jeh     Removed NODE_TYPE enum.
+ *! 17-Jul-2000 jeh     Changed order of node types to match rms_sh.h.
+ *! 20-Jun-2000 jeh     Created.
+ */
+
+#ifndef NODEDEFS_
+#define NODEDEFS_
+
+#define NODE_SUSPENDEDPRI -1
+
+/* NODE Objects: */
+	struct NODE_MGR;
+	struct NODE_OBJECT;
+
+#endif				/* NODEDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -0,0 +1,619 @@
+/*
+ * bridge/inc/node.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== node.h ========
+ *  Description:
+ *      DSP/BIOS Bridge Node Manager.
+ *
+ *  Public Functions:
+ *      NODE_Allocate
+ *      NODE_AllocMsgBuf
+ *      NODE_ChangePriority
+ *      NODE_Connect
+ *      NODE_Create
+ *      NODE_CreateMgr
+ *      NODE_Delete
+ *      NODE_DeleteMgr
+ *      NODE_EnumNodes
+ *      NODE_Exit
+ *      NODE_FreeMsgBuf
+ *      NODE_GetAttr
+ *      NODE_GetMessage
+ *      NODE_GetProcessor
+ *      NODE_Init
+ *      NODE_OnExit
+ *      NODE_Pause
+ *      NODE_PutMessage
+ *      NODE_RegisterNotify
+ *      NODE_Run
+ *      NODE_Terminate
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! =================
+ *! 23-Apr-2001 jeh     Updated with code review changes.
+ *! 16-Jan-2001 jeh     Added DSP_ESYMBOL, DSP_EUUID to return codes.
+ *! 17-Nov-2000 jeh     Added NODE_OnExit().
+ *! 27-Oct-2000 jeh     Added timeouts to NODE_GetMessage, NODE_PutMessage.
+ *! 12-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Removed
+ *!                     NODE_RegisterAllNodes().
+ *! 07-Sep-2000 jeh     Changed type HANDLE in NODE_RegisterNotify to
+ *!                     DSP_HNOTIFICATION. Added DSP_STRMATTR param to
+ *!                     NODE_Connect(). Removed NODE_GetMessageStream().
+ *! 17-Jul-2000 jeh     Updated function header descriptions.
+ *! 19-Jun-2000 jeh     Created.
+ */
+
+#ifndef NODE_
+#define NODE_
+
+#include <procpriv.h>
+
+#include <nodedefs.h>
+#include <dispdefs.h>
+#include <nldrdefs.h>
+
+/*
+ *  ======== NODE_Allocate ========
+ *  Purpose:
+ *      Allocate GPP resources to manage a node on the DSP.
+ *  Parameters:
+ *      hProcessor:         Handle of processor that is allocating the node.
+ *      pNodeId:            Pointer to a DSP_UUID for the node.
+ *      pArgs:              Optional arguments to be passed to the node.
+ *      pAttrIn:            Optional pointer to node attributes (priority,
+ *                          timeout...)
+ *      phNode:             Location to store node handle on output.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory on GPP.
+ *      DSP_EUUID:          Node UUID has not been registered.
+ *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
+ *      DSP_ERANGE:         pAttrIn != NULL and pAttrIn->iPriority out of
+ *                          range.
+ *      DSP_EFAIL:          A failure occured, unable to allocate node.
+ *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
+ *  Requires:
+ *      NODE_Init() called.
+ *      hProcessor != NULL.
+ *      pNodeId != NULL.
+ *      phNode != NULL.
+ *  Ensures:
+ *      DSP_SOK:            IsValidNode(*phNode).
+ *      error:              *phNode == NULL.
+ */
+	extern DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
+					IN CONST struct DSP_UUID *pNodeId,
+					OPTIONAL IN CONST struct DSP_CBDATA
+					*pArgs,
+					OPTIONAL IN CONST struct DSP_NODEATTRIN
+					*pAttrIn,
+					OUT struct NODE_OBJECT **phNode);
+
+/*
+ *  ======== NODE_AllocMsgBuf ========
+ *  Purpose:
+ *      Allocate and Prepare a buffer whose descriptor will be passed to a
+ *      Node within a (DSP_MSG)message
+ *  Parameters:
+ *      hNode:          The node handle.
+ *      uSize:          The size of the buffer to be allocated.
+ *      pAttr:          Pointer to a DSP_BUFFERATTR structure.
+ *      pBuffer:        Location to store the address of the allocated
+ *                      buffer on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid node handle.
+ *      DSP_EMEMORY:    Insufficent memory.
+ *      DSP_EFAIL:      General Failure.
+ *      DSP_ESIZE:      Invalid Size.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_AllocMsgBuf(struct NODE_OBJECT *hNode,
+					   u32 uSize,
+					   OPTIONAL struct DSP_BUFFERATTR
+					   *pAttr,
+					   OUT u8 **pBuffer);
+
+/*
+ *  ======== NODE_ChangePriority ========
+ *  Purpose:
+ *      Change the priority of an allocated node.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate.
+ *      nPriority:          New priority level to set node's priority to.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ERANGE:         nPriority is out of range.
+ *      DSP_ENODETYPE:      The specified node is not a task node.
+ *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,
+ *                          or NODE_RUNNING state.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_ERESTART:       A critical error has occurred and the DSP is
+ *                          being restarted.
+ *      DSP_EFAIL:          Unable to change node's runtime priority level.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ *      DSP_SOK && (Node's current priority == nPriority)
+ */
+	extern DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode,
+					      s32 nPriority);
+
+/*
+ *  ======== NODE_CloseOrphans ========
+ *  Purpose:
+ *      Delete all nodes whose owning processor is being destroyed.
+ *  Parameters:
+ *      hNodeMgr:       Node manager object.
+ *      hProc:          Handle to processor object being destroyed.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
+ *  Requires:
+ *      Valid hNodeMgr.
+ *      hProc != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_CloseOrphans(struct NODE_MGR *hNodeMgr,
+					    struct PROC_OBJECT *hProc);
+
+/*
+ *  ======== NODE_Connect ========
+ *  Purpose:
+ *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
+ *      case that the connnection is being made between a node on the DSP and
+ *      the GPP, one of the node handles (either hNode1 or hNode2) must be
+ *      the constant NODE_HGPPNODE.
+ *  Parameters:
+ *      hNode1:         Handle of first node to connect to second node. If
+ *                      this is a connection from the GPP to hNode2, hNode1
+ *                      must be the constant NODE_HGPPNODE. Otherwise, hNode1
+ *                      must be a node handle returned from a successful call
+ *                      to Node_Allocate().
+ *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
+ *                      if this is a connection from DSP node to GPP, or a
+ *                      node handle returned from a successful call to
+ *                      NODE_Allocate().
+ *      uStream1:       Output stream index on first node, to be connected
+ *                      to second node's input stream. Value must range from
+ *                      0 <= uStream1 < number of output streams.
+ *      uStream2:       Input stream index on second node. Value must range
+ *                      from 0 <= uStream2 < number of input streams.
+ *      pAttrs:         Stream attributes (NULL ==> use defaults).
+ *      pConnParam:     A pointer to a DSP_CBDATA structure that defines
+ *                      connection parameter for device nodes to pass to DSP
+ *                      side.
+ *                      If the value of this parameter is NULL, then this API
+ *                      behaves like DSPNode_Connect. This parameter will have
+ *                      length of the string and the null terminated string in
+ *                      DSP_CBDATA struct. This can be extended in future tp
+ *                      pass binary data.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            Invalid hNode1 or hNode2.
+ *      DSP_EMEMORY:            Insufficient host memory.
+ *      DSP_EVALUE:             A stream index parameter is invalid.
+ *      DSP_EALREADYCONNECTED:  A connection already exists for one of the
+ *                              indices uStream1 or uStream2.
+ *      DSP_EWRONGSTATE:        Either hNode1 or hNode2 is not in the
+ *                              NODE_ALLOCATED state.
+ *      DSP_ENOMORECONNECTIONS: No more connections available.
+ *      DSP_EFAIL:              Attempt to make an illegal connection (eg,
+ *                              Device node to device node, or device node to
+ *                              GPP), the two nodes are on different DSPs.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1,
+				       u32 uStream1,
+				       struct NODE_OBJECT *hNode2,
+				       u32 uStream2,
+				       OPTIONAL IN struct DSP_STRMATTR *pAttrs,
+				       OPTIONAL IN struct DSP_CBDATA
+				       *pConnParam);
+
+/*
+ *  ======== NODE_Create ========
+ *  Purpose:
+ *      Create a node on the DSP by remotely calling the node's create
+ *      function. If necessary, load code that contains the node's create
+ *      function.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ESYMBOL:        Create function not found in the COFF file.
+ *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
+ *      DSP_EMEMORY:        Memory allocation failure on the DSP.
+ *      DSP_ETASK:          Unable to create node's task or process on the DSP.
+ *      DSP_ESTREAM:        Stream creation failure on the DSP.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
+ *      DSP_EFAIL:          A failure occurred, unable to create node.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_CreateMgr ========
+ *  Purpose:
+ *      Create a NODE Manager object. This object handles the creation,
+ *      deletion, and execution of nodes on the DSP target. The NODE Manager
+ *      also maintains a pipe map of used and available node connections.
+ *      Each DEV object should have exactly one NODE Manager object.
+ *
+ *  Parameters:
+ *      phNodeMgr:      Location to store node manager handle on output.
+ *      hDevObject:     Device for this processor.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      NODE_Init() called.
+ *      phNodeMgr != NULL.
+ *      hDevObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valide *phNodeMgr.
+ *      error:          *phNodeMgr == NULL.
+ */
+	extern DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
+					 struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== NODE_Delete ========
+ *  Purpose:
+ *      Delete resources allocated in NODE_Allocate(). If the node was
+ *      created, delete the node on the DSP by remotely calling the node's
+ *      delete function. Loads the node's delete function if necessary.
+ *      GPP side resources are freed after node's delete function returns.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EDELETE:        A deletion failure occurred.
+ *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
+ *      DSP_EFAIL:          A failure occurred in deleting the node.
+ *      DSP_ESYMBOL:        Delete function not found in the COFF file.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ *      DSP_SOK:            hNode is invalid.
+ */
+	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_DeleteMgr ========
+ *  Purpose:
+ *      Delete the NODE Manager.
+ *  Parameters:
+ *      hNodeMgr:       Node manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *  Requires:
+ *      NODE_Init() called.
+ *      Valid hNodeMgr.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr);
+
+/*
+ *  ======== NODE_EnumNodes ========
+ *  Purpose:
+ *      Enumerate the nodes currently allocated for the DSP.
+ *  Parameters:
+ *      hNodeMgr:       Node manager returned from NODE_CreateMgr().
+ *      aNodeTab:       Array to copy node handles into.
+ *      uNodeTabSize:   Number of handles that can be written to aNodeTab.
+ *      puNumNodes:     Location where number of node handles written to
+ *                      aNodeTab will be written.
+ *      puAllocated:    Location to write total number of allocated nodes.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ESIZE:      aNodeTab is too small to hold all node handles.
+ *  Requires:
+ *      Valid hNodeMgr.
+ *      aNodeTab != NULL || uNodeTabSize == 0.
+ *      puNumNodes != NULL.
+ *      puAllocated != NULL.
+ *  Ensures:
+ *      - (DSP_ESIZE && *puNumNodes == 0)
+ *      - || (DSP_SOK && *puNumNodes <= uNodeTabSize)  &&
+ *        (*puAllocated == *puNumNodes)
+ */
+	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
+					 IN DSP_HNODE *aNodeTab,
+					 u32 uNodeTabSize,
+					 OUT u32 *puNumNodes,
+					 OUT u32 *puAllocated);
+
+/*
+ *  ======== NODE_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NODE module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NODE_Init() successfully called before.
+ *  Ensures:
+ *      Any resources acquired in NODE_Init() will be freed when last NODE
+ *      client calls NODE_Exit().
+ */
+	extern void NODE_Exit();
+
+/*
+ *  ======== NODE_FreeMsgBuf ========
+ *  Purpose:
+ *      Free a message buffer previously allocated with NODE_AllocMsgBuf.
+ *  Parameters:
+ *      hNode:          The node handle.
+ *      pBuffer:        (Address) Buffer allocated by NODE_AllocMsgBuf.
+ *      pAttr:          Same buffer attributes passed to NODE_AllocMsgBuf.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid node handle.
+ *      DSP_EFAIL:      Failure to free the buffer.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode,
+					  IN u8 *pBuffer,
+					  OPTIONAL struct DSP_BUFFERATTR
+					  *pAttr);
+
+/*
+ *  ======== NODE_GetAttr ========
+ *  Purpose:
+ *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      structure.
+ *  Parameters:
+ *      hNode:          Node object allocated from NODE_Allocate().
+ *      pAttr:          Pointer to DSP_NODEATTR structure to copy node's
+ *                      attributes.
+ *      uAttrSize:      Size of pAttr.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pAttr != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *pAttrs contains the node's current attributes.
+ */
+	extern DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
+				       OUT struct DSP_NODEATTR *pAttr,
+				       u32 uAttrSize);
+
+/*
+ *  ======== NODE_GetMessage ========
+ *  Purpose:
+ *      Retrieve a message from a node on the DSP. The node must be either a
+ *      message node, task node, or XDAIS socket node.
+ *      If a message is not available, this function will block until a
+ *      message is available, or the node's timeout value is reached.
+ *  Parameters:
+ *      hNode:          Node handle returned from NODE_Allocate().
+ *      pMessage:       Pointer to DSP_MSG structure to copy the
+ *                      message into.
+ *      uTimeout:       Timeout in milliseconds to wait for message.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
+ *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
+ *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pMessage != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode,
+					  OUT struct DSP_MSG *pMessage,
+					  u32 uTimeout);
+
+/*
+ *  ======== NODE_GetNldrObj ========
+ *  Purpose:
+ *      Retrieve the Nldr manager
+ *  Parameters:
+ *      hNodeMgr:       Node Manager
+ *      phNldrObj:      Pointer to a Nldr manager handle
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
+					  OUT struct NLDR_OBJECT **phNldrObj);
+
+/*
+ *  ======== NODE_Init ========
+ *  Purpose:
+ *      Initialize the NODE module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool NODE_Init();
+
+/*
+ *  ======== NODE_OnExit ========
+ *  Purpose:
+ *      Gets called when RMS_EXIT is received for a node. PROC needs to pass
+ *      this function as a parameter to MSG_Create(). This function then gets
+ *      called by the mini-driver when an exit message for a node is received.
+ *  Parameters:
+ *      hNode:      Handle of the node that the exit message is for.
+ *      nStatus:    Return status of the node's execute phase.
+ *  Returns:
+ *  Ensures:
+ */
+	void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus);
+
+/*
+ *  ======== NODE_Pause ========
+ *  Purpose:
+ *      Suspend execution of a node currently running on the DSP.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      Node is not a task or socket node.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
+ *      DSP_EFAIL:          Failed to pause node.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_PutMessage ========
+ *  Purpose:
+ *      Send a message to a message node, task node, or XDAIS socket node.
+ *      This function will block until the message stream can accommodate
+ *      the message, or a timeout occurs. The message will be copied, so Msg
+ *      can be re-used immediately after return.
+ *  Parameters:
+ *      hNode:              Node handle returned by NODE_Allocate().
+ *      pMsg:               Location of message to be sent to the node.
+ *      uTimeout:           Timeout in msecs to wait.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
+ *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
+ *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
+ *      DSP_EFAIL:          Unable to send message.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
+					  IN CONST struct DSP_MSG *pMsg,
+					  u32 uTimeout);
+
+/*
+ *  ======== NODE_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this node.
+ *  Parameters:
+ *      hNode:          Node handle returned by NODE_Allocate().
+ *      uEventMask:     Mask of types of events to be notified about.
+ *      uNotifyType:    Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      DSP_EVALUE:     uEventMask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *                      supported.
+ *  Requires:
+ *      NODE_Init() called.
+ *      hNotification != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== NODE_Run ========
+ *  Purpose:
+ *      Start execution of a node's execute phase, or resume execution of
+ *      a node that has been suspended (via NODE_Pause()) on the DSP. Load
+ *      the node's execute function if necessary.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      hNode doesn't represent a message, task or dais
+ *                          socket node.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
+ *      DSP_EFAIL:          Unable to start or resume execution.
+ *      DSP_ESYMBOL:        Execute function not found in the COFF file.
+ *  Requires:
+ *      NODE_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_Terminate ========
+ *  Purpose:
+ *      Signal a node running on the DSP that it should exit its execute
+ *      phase function.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *      pStatus:            Location to store execute-phase function return
+ *                          value (DSP_EUSER1-16).
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
+ *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
+ *      DSP_EFAIL:          Unable to terminate the node.
+ *  Requires:
+ *      NODE_Init() called.
+ *      pStatus != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode,
+					 OUT DSP_STATUS *pStatus);
+
+
+
+/*
+ *  ======== NODE_GetUUIDProps ========
+ *  Purpose:
+ *      Fetch Node properties given the UUID
+ *  Parameters:
+ *
+ */
+	extern DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
+					    IN CONST struct DSP_UUID *pNodeId,
+					    OUT struct DSP_NDBPROPS
+					    *pNodeProps);
+
+#endif				/* NODE_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nodepriv.h
@@ -0,0 +1,237 @@
+/*
+ * bridge/inc/nodepriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== nodepriv.h ========
+ *  Description:
+ *      Private node header shared by NODE and DISP.
+ *
+ *  Public Functions:
+ *      NODE_GetChannelId
+ *      NODE_GetStrmMgr
+ *      NODE_GetTimeout
+ *      NODE_GetType
+ *      NODE_GetLoadType
+ *
+ *! Revision History
+ *! ================
+ *! 19-Nov-2002 map     Added NODE_GetLoadType
+ *! 13-Feb-2002 jeh     Added uSysStackSize to NODE_TASKARGS.
+ *! 23-Apr-2001 jeh     Removed unused typedefs, defines.
+ *! 10-Oct-2000 jeh     Added alignment to NODE_STRMDEF.
+ *! 20-Jun-2000 jeh     Created.
+ */
+
+#ifndef NODEPRIV_
+#define NODEPRIV_
+
+#include <strmdefs.h>
+#include <nodedefs.h>
+#include <nldrdefs.h>
+
+/* DSP address of node environment structure */
+	typedef u32 NODE_ENV;
+
+/*
+ *  Node create structures
+ */
+
+/* Message node */
+	struct NODE_MSGARGS {
+		u32 uMaxMessages; /* Max # of simultaneous messages for node */
+		u32 uSegid;	/* Segment for allocating message buffers */
+		u32 uNotifyType;  /* Notify type (SEM_post, SWI_post, etc.) */
+		u32 uArgLength;  /* Length in 32-bit words of arg data block */
+		u8 *pData;	/* Argument data for node */
+	} ;
+
+	struct NODE_STRMDEF {
+		u32 uBufsize;	/* Size of buffers for SIO stream */
+		u32 uNumBufs;	/* max # of buffers in SIO stream at once */
+		u32 uSegid;	/* Memory segment id to allocate buffers */
+		u32 uTimeout;	/* Timeout for blocking SIO calls */
+		u32 uAlignment;	/* Buffer alignment */
+		char *szDevice;	/* Device name for stream */
+	} ;
+
+/* Task node */
+	struct NODE_TASKARGS {
+		struct NODE_MSGARGS msgArgs;
+		s32 nPriority;
+		u32 uStackSize;
+		u32 uSysStackSize;
+		u32 uStackSeg;
+		u32 uDSPHeapResAddr;	/* DSP virtual heap address */
+		u32 uDSPHeapAddr;	/* DSP virtual heap address */
+		u32 uHeapSize;	/* Heap size */
+		u32 uGPPHeapAddr;	/* GPP virtual heap address */
+		u32 uProfileID;	/* Profile ID */
+		u32 uNumInputs;
+		u32 uNumOutputs;
+		u32 ulDaisArg;	/* Address of iAlg object */
+		struct NODE_STRMDEF *strmInDef;
+		struct NODE_STRMDEF *strmOutDef;
+	} ;
+
+/*
+ *  ======== NODE_CREATEARGS ========
+ */
+	struct NODE_CREATEARGS {
+		union {
+			struct NODE_MSGARGS msgArgs;
+			struct NODE_TASKARGS taskArgs;
+		} asa;
+	} ;
+
+/*
+ *  Node types: Message node, task node, xDAIS socket node, and
+ *  device node. _NODE_GPP is used when defining a stream connection
+ *  between a task or socket node and the GPP.
+ *
+ *  ~~~~~~~~~~~~~~
+ *  TO DO:
+ *  Clean up when Node Manager uses only one critical section.
+ *  ~~~~~~~~~~~~~~
+ */
+	enum NODE_TYPE {
+		_NODE_DEVICE = NODE_DEVICE,
+		_NODE_TASK = NODE_TASK,
+		_NODE_DAISSOCKET = NODE_DAISSOCKET,
+		_NODE_MESSAGE = NODE_MESSAGE,
+		NODE_GPP
+	} ;
+
+/*
+ *  ======== NODE_STATE ========
+ *  Internal node states.
+ */
+	enum NODE_STATE {
+		_NODE_ALLOCATED = NODE_ALLOCATED,
+		_NODE_CREATED = NODE_CREATED,
+		_NODE_RUNNING = NODE_RUNNING,
+		_NODE_PAUSED = NODE_PAUSED,
+		_NODE_DONE = NODE_DONE,
+		NODE_CREATING,
+		NODE_STARTING,
+		NODE_PAUSING,
+		NODE_TERMINATING,
+		NODE_DELETING,
+	} ;
+
+/*
+ *  ======== NODE_GetChannelId ========
+ *  Purpose:
+ *      Get the channel index reserved for a stream connection between the
+ *      host and a node. This index is reserved when NODE_Connect() is called
+ *      to connect the node with the host. This index should be passed to
+ *      the CHNL_Open function when the stream is actually opened.
+ *  Parameters:
+ *      hNode:          Node object allocated from NODE_Allocate().
+ *      uDir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
+ *      uIndex:         Stream index.
+ *      pulId:          Location to store channel index.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_ENODETYPE:  Not a task or DAIS socket node.
+ *      DSP_EVALUE:     The node's stream corresponding to uIndex and uDir
+ *                      is not a stream to or from the host.
+ *  Requires:
+ *      NODE_Init() called.
+ *      Valid uDir.
+ *      pulId != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode,
+					    u32 uDir,
+					    u32 uIndex, OUT u32 *pulId);
+
+/*
+ *  ======== NODE_GetStrmMgr ========
+ *  Purpose:
+ *      Get the STRM manager for a node.
+ *  Parameters:
+ *      hNode:          Node allocated with NODE_Allocate().
+ *      phStrmMgr:      Location to store STRM manager on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Requires:
+ *      phStrmMgr != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
+					  struct STRM_MGR **phStrmMgr);
+
+/*
+ *  ======== NODE_GetTimeout ========
+ *  Purpose:
+ *      Get the timeout value of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node's timeout value.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern u32 NODE_GetTimeout(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_GetType ========
+ *  Purpose:
+ *      Get the type (device, message, task, or XDAIS socket) of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node type:  NODE_DEVICE, NODE_TASK, NODE_XDAIS, or NODE_GPP.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== GetNodeInfo ========
+ *  Purpose:
+ *      Get node information without holding semaphore.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node info:  priority, device owner, no. of streams, execution state
+ *                  NDB properties.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern void GetNodeInfo(struct NODE_OBJECT *hNode,
+				struct DSP_NODEINFO *pNodeInfo);
+
+/*
+ *  ======== NODE_GetLoadType ========
+ *  Purpose:
+ *      Get the load type (dynamic, overlay, static) of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node type:  NLDR_DYNAMICLOAD, NLDR_OVLYLOAD, NLDR_STATICLOAD
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode);
+
+#endif				/* NODEPRIV_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/ntfy.h
@@ -0,0 +1,146 @@
+/*
+ * bridge/inc/ntfy.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== ntfy.h ========
+ *  Purpose:
+ *      Manage lists of notification events.
+ *
+ *  Public Functions:
+ *      NTFY_Create
+ *      NTFY_Delete
+ *      NTFY_Exit
+ *      NTFY_Init
+ *      NTFY_Notify
+ *      NTFY_Register
+ *
+ *! Revision History:
+ *! =================
+ *! 05-Nov-2001 kc: Updated NTFY_Register.
+ *! 07-Sep-2000 jeh Created.
+ */
+
+#ifndef NTFY_
+#define NTFY_
+
+	struct NTFY_OBJECT;
+
+/*
+ *  ======== NTFY_Create ========
+ *  Purpose:
+ *      Create an empty list of notifications.
+ *  Parameters:
+ *      phNtfy:         Location to store handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *  Requires:
+ *      NTFY_Init() called.
+ *      phNtfy != NULL.
+ *  Ensures:
+ *      DSP_SUCCEEDED(status) <==>  IsValid(*phNtfy).
+ */
+	extern DSP_STATUS NTFY_Create(OUT struct NTFY_OBJECT **phNtfy);
+
+/*
+ *  ======== NTFY_Delete ========
+ *  Purpose:
+ *      Free resources allocated in NTFY_Create.
+ *  Parameters:
+ *      hNtfy:  Handle returned from NTFY_Create().
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init() called.
+ *      IsValid(hNtfy).
+ *  Ensures:
+ */
+	extern void NTFY_Delete(IN struct NTFY_OBJECT *hNtfy);
+
+/*
+ *  ======== NTFY_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NTFY module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init() successfully called before.
+ *  Ensures:
+ */
+	extern void NTFY_Exit();
+
+/*
+ *  ======== NTFY_Init ========
+ *  Purpose:
+ *      Initialize the NTFY module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool NTFY_Init();
+
+/*
+ *  ======== NTFY_Notify ========
+ *  Purpose:
+ *      Execute notify function (signal event or post message) for every
+ *      element in the notification list that is to be notified about the
+ *      event specified in uEventMask.
+ *  Parameters:
+ *      hNtfy:      Handle returned from NTFY_Create().
+ *      uEventMask: The type of event that has occurred.
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init() called.
+ *      IsValid(hNtfy).
+ *  Ensures:
+ */
+	extern void NTFY_Notify(IN struct NTFY_OBJECT *hNtfy,
+				IN u32 uEventMask);
+
+/*
+ *  ======== NTFY_Register ========
+ *  Purpose:
+ *      Add a notification element to the list. If the notification is already
+ *      registered, and uEventMask != 0, the notification will get posted for
+ *      events specified in the new event mask. If the notification is already
+ *      registered and uEventMask == 0, the notification will be unregistered.
+ *  Parameters:
+ *      hNtfy:              Handle returned from NTFY_Create().
+ *      hNotification:      Handle to a DSP_NOTIFICATION object.
+ *      uEventMask:         Events to be notified about.
+ *      uNotifyType:        Type of notification: DSP_SIGNALEVENT.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *      DSP_EVALUE:         uEventMask is 0 and hNotification was not
+ *                          previously registered.
+ *      DSP_EHANDLE:        NULL hNotification, hNotification event name
+ *                          too long, or hNotification event name NULL.
+ *  Requires:
+ *      NTFY_Init() called.
+ *      IsValid(hNtfy).
+ *      hNotification != NULL.
+ *      uNotifyType is DSP_SIGNALEVENT
+ *  Ensures:
+ */
+	extern DSP_STATUS NTFY_Register(IN struct NTFY_OBJECT *hNtfy,
+					IN struct DSP_NOTIFICATION
+					*hNotification,
+					IN u32 uEventMask,
+					IN u32 uNotifyType);
+
+#endif				/* NTFY_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -0,0 +1,648 @@
+/*
+ * bridge/inc/proc.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== proc.h ========
+ *  Description:
+ *	This is the Class driver RM module interface.
+ *
+ *  Public Functions:
+ *      PROC_Attach
+ *      PROC_Create
+ *      PROC_Ctrl	       (OEM-function)
+ *      PROC_Destroy
+ *      PROC_Detach
+ *      PROC_EnumNodes
+ *      PROC_Exit
+ *      PROC_FlushMemory
+ *      PROC_GetDevObject       (OEM-function)
+ *      PROC_GetResourceInfo
+ *      PROC_GetState
+ *      PROC_GetProcessorId
+ *      PROC_GetTrace	   (OEM-function)
+ *      PROC_Init
+ *      PROC_Load	       (OEM-function)
+ *      PROC_Map
+ *      PROC_NotifyAllclients
+ *      PROC_NotifyClients      (OEM-function)
+ *      PROC_RegisterNotify
+ *      PROC_ReserveMemory
+ *      PROC_Start	      (OEM-function)
+ *      PROC_UnMap
+ *      PROC_UnReserveMemory
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
+ *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
+ *! 09-Feb-2003 vp: Added PROC_GetProcessorID function
+ *! 29-Nov-2000 rr: Incorporated code review changes.
+ *! 28-Sep-2000 rr: Updated to Version 0.9.
+ *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
+ *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types). GetTrace added.
+ *! 27-Jun-2000 rr: Created from dspapi.h
+ */
+
+#ifndef PROC_
+#define PROC_
+
+#include <cfgdefs.h>
+#include <devdefs.h>
+
+/*
+ *  ======== PROC_Attach ========
+ *  Purpose:
+ *      Prepare for communication with a particular DSP processor, and return
+ *      a handle to the processor object. The PROC Object gets created
+ *  Parameters:
+ *      uProcessor  :	   The processor index (zero-based).
+ *      hMgrObject  :	   Handle to the Manager Object
+ *      pAttrIn     :	   Ptr to the DSP_PROCESSORATTRIN structure.
+ *			      A NULL value means use default values.
+ *      phProcessor :	   Ptr to location to store processor handle.
+ *  Returns:
+ *      DSP_SOK     :	   Success.
+ *      DSP_EFAIL   :	   General failure.
+ *      DSP_EHANDLE :	   Invalid processor handle.
+ *      DSP_SALREADYATTACHED:   Success; Processor already attached.
+ *  Requires:
+ *      phProcessor != NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ *      DSP_EFAIL, and *phProcessor == NULL, OR
+ *      Success and *phProcessor is a Valid Processor handle OR
+ *      DSP_SALREADYATTACHED and *phProcessor is a Valid Processor.
+ *  Details:
+ *      When pAttrIn is NULL, the default timeout value is 10 seconds.
+ */
+	extern DSP_STATUS PROC_Attach(u32 uProcessor,
+				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
+				      *pAttrIn,
+				      OUT DSP_HPROCESSOR *phProcessor);
+
+/*
+ *  ======== PROC_AutoStart =========
+ *  Purpose:
+ *      A Particular device gets loaded with the default image
+ *      if the AutoStart flag is set.
+ *  Parameters:
+ *      hDevObject  :   Handle to the Device
+ *  Returns:
+ *      DSP_SOK     :   On Successful Loading
+ *      DSP_EFILE   :   No DSP exec file found.
+ *      DSP_EFAIL   :   General Failure
+ *  Requires:
+ *      hDevObject != NULL.
+ *      hDevNode != NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
+					 struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== PROC_Ctrl ========
+ *  Purpose:
+ *      Pass control information to the GPP device driver managing the DSP
+ *      processor. This will be an OEM-only function, and not part of the
+ *      'Bridge application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      dwCmd       :       Private driver IOCTL cmd ID.
+ *      pArgs       :       Ptr to an driver defined argument structure.
+ *  Returns:
+ *      DSP_SOK     :       SUCCESS
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_ETIMEOUT:       A Timeout Occured before the Control information
+ *			  could be sent.
+ *      DSP_EACCESSDENIED:  Client does not have the access rights required
+ *			  to call this function.
+ *      DSP_ERESTART:       A Critical error has occured and the DSP is being
+ *			  restarted.
+ *      DSP_EFAIL   :       General Failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures
+ *  Details:
+ *      This function Calls WMD_BRD_Ioctl.
+ */
+	extern DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor,
+				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
+
+/*
+ *  ======== PROC_Detach ========
+ *  Purpose:
+ *      Close a DSP processor and de-allocate all (GPP) resources reserved
+ *      for it. The Processor Object is deleted.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   InValid Handle.
+ *      DSP_EFAIL   :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      PROC Object is destroyed.
+ */
+	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor);
+
+/*
+ *  ======== PROC_EnumNodes ========
+ *  Purpose:
+ *      Enumerate the nodes currently allocated on a processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      aNodeTab    :   The first Location of an array allocated for node
+ *		      handles.
+ *      uNodeTabSize:   The number of (DSP_HNODE) handles that can be held
+ *		      to the memory the client has allocated for aNodeTab
+ *      puNumNodes  :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of valid handles written to aNodeTab
+ *      puAllocated :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of nodes that are allocated on the DSP.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_ESIZE   :   The amount of memory allocated for aNodeTab is
+ *		      insufficent. That is the number of nodes actually
+ *		      allocated on the DSP is greater than the value
+ *		      specified for uNodeTabSize.
+ *      DSP_EFAIL   :   Unable to get Resource Information.
+ *  Details:
+ *  Requires
+ *      puNumNodes is not NULL.
+ *      puAllocated is not NULL.
+ *      aNodeTab is not NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor,
+					 IN DSP_HNODE *aNodeTab,
+					 IN u32 uNodeTabSize,
+					 OUT u32 *puNumNodes,
+					 OUT u32 *puAllocated);
+
+/*
+ *  ======== PROC_GetResourceInfo ========
+ *  Purpose:
+ *      Enumerate the resources currently available on a processor.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      uResourceType:      Type of resource .
+ *      pResourceInfo:      Ptr to the DSP_RESOURCEINFO structure.
+ *      uResourceInfoSize:  Size of the structure.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    The processor is not in the PROC_RUNNING state.
+ *      DSP_ETIMEOUT:       A timeout occured before the DSP responded to the
+ *			  querry.
+ *      DSP_ERESTART:       A Critical error has occured and the DSP is being
+ *			  restarted.
+ *      DSP_EFAIL   :       Unable to get Resource Information
+ *  Requires:
+ *      pResourceInfo is not NULL.
+ *      Parameter uResourceType is Valid.[TBD]
+ *      uResourceInfoSize is >= sizeof DSP_RESOURCEINFO struct.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      This function currently returns
+ *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
+ */
+	extern DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor,
+					       u32 uResourceType,
+					       OUT struct DSP_RESOURCEINFO *
+					       pResourceInfo,
+					       u32 uResourceInfoSize);
+
+/*
+ *  ======== PROC_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      PROC is initialized.
+ *  Ensures:
+ *      When reference count == 0, PROC's private resources are freed.
+ */
+       extern void PROC_Exit();
+
+/*
+ * ======== PROC_GetDevObject =========
+ *  Purpose:
+ *      Returns the DEV Hanlde for a given Processor handle
+ *  Parameters:
+ *      hProcessor  :   Processor Handle
+ *      phDevObject :   Location to store the DEV Handle.
+ *  Returns:
+ *      DSP_SOK     :   Success; *phDevObject has Dev handle
+ *      DSP_EFAIL   :   Failure; *phDevObject is zero.
+ *  Requires:
+ *      phDevObject is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *      DSP_SOK     :   *phDevObject is not NULL
+ *      DSP_EFAIL   :   *phDevObject is NULL.
+ */
+	extern DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
+					    struct DEV_OBJECT **phDevObject);
+
+/*
+ *  ======== PROC_Init ========
+ *  Purpose:
+ *      Initialize PROC's private state, keeping a reference count on each
+ *      call.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public PROC functions.
+ */
+       extern bool PROC_Init();
+
+/*
+ *  ======== PROC_GetState ========
+ *  Purpose:
+ *      Report the state of the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      pProcStatus :   Ptr to location to store the DSP_PROCESSORSTATE
+ *		      structure.
+ *      uStateInfoSize: Size of DSP_PROCESSORSTATE.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while querying processor state.
+ *  Requires:
+ *      pProcStatus is not NULL
+ *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
+					OUT struct DSP_PROCESSORSTATE
+					*pProcStatus,
+					u32 uStateInfoSize);
+
+/*
+ *  ======== PROC_GetProcessorID ========
+ *  Purpose:
+ *      Report the state of the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      procID      :   Processor ID
+ *
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while querying processor state.
+ *  Requires:
+ *      pProcStatus is not NULL
+ *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProcessor,
+					      u32 *procID);
+
+/*
+ *  ======== PROC_GetTrace ========
+ *  Purpose:
+ *      Retrieve the trace buffer from the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      pBuf	:   Ptr to buffer to hold trace output.
+ *      uMaxSize    :   Maximum size of the output buffer.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while retireving processor trace
+ *		      Buffer.
+ *  Requires:
+ *      pBuf is not NULL
+ *      uMaxSize is > 0.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf,
+					u32 uMaxSize);
+
+/*
+ *  ======== PROC_Load ========
+ *  Purpose:
+ *      Reset a processor and load a new base program image.
+ *      This will be an OEM-only function.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      iArgc       :       The number of Arguments(strings)in the aArgV[]
+ *      aArgv       :       An Array of Arguments(Unicode Strings)
+ *      aEnvp       :       An Array of Environment settings(Unicode Strings)
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EFILE   :       The DSP Execuetable was not found.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_ECORRUTFILE:    Unable to Parse the DSP Execuetable
+ *      DSP_EATTACHED:      Abort because a GPP Client is attached to the
+ *			  specified Processor
+ *      DSP_EACCESSDENIED:  Client does not have the required access rights
+ *			  to reset and load the Processor
+ *      DSP_EFAIL   :       Unable to Load the Processor
+ *  Requires:
+ *      aArgv is not NULL
+ *      iArgc is > 0
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_LOADED
+ *      or DSP_FAILED status.
+ *  Details:
+ *      Does not implement access rights to control which GPP application
+ *      can load the processor.
+ */
+	extern DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor,
+				    IN CONST s32 iArgc, IN CONST char **aArgv,
+				    IN CONST char **aEnvp);
+
+/*
+ *  ======== PROC_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified of specific processor events
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      uEventMask  :   Mask of types of events to be notified about.
+ *      uNotifyType :   Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle or hNotification.
+ *      DSP_EVALUE  :   Parameter uEventMask is Invalid
+ *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
+ *		      is not supported.
+ *      DSP_EFAIL   :   Unable to register for notification.
+ *  Requires:
+ *      hNotification is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== PROC_NotifyClients ========
+ *  Purpose:
+ *      Notify the Processor Clients
+ *  Parameters:
+ *      hProc       :   The processor handle.
+ *      uEvents     :   Event to be notified about.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *  Requires:
+ *      uEvents is Supported or Valid type of Event
+ *      hProc is a valid handle
+ *      PROC Initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc,
+					     u32 uEvents);
+
+/*
+ *  ======== PROC_NotifyAllClients ========
+ *  Purpose:
+ *      Notify the Processor Clients
+ *  Parameters:
+ *      hProc       :   The processor handle.
+ *      uEvents     :   Event to be notified about.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *  Requires:
+ *      uEvents is Supported or Valid type of Event
+ *      hProc is a valid handle
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      NODE And STRM would use this function to notify their clients
+ *      about the state changes in NODE or STRM.
+ */
+	extern DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc,
+						u32 uEvents);
+
+/*
+ *  ======== PROC_Start ========
+ *  Purpose:
+ *      Start a processor running.
+ *      Processor must be in PROC_LOADED state.
+ *      This will be an OEM-only function, and not part of the 'Bridge
+ *      application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
+ *      DSP_EFAIL   :       Unable to start the processor.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor);
+
+/*
+ *  ======== PROC_Stop ========
+ *  Purpose:
+ *      Start a processor running.
+ *      Processor must be in PROC_LOADED state.
+ *      This will be an OEM-only function, and not part of the 'Bridge
+ *      application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
+ *      DSP_EFAIL   :       Unable to start the processor.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor);
+
+/*
+ *  ======== PROC_FlushMemory ========
+ *  Purpose:
+ *      Flushes a buffer from the MPU data cache.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Buffer start address
+ *      ulSize	  :   Buffer size
+ *      ulFlags	 :   Reserved.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      All the arguments are currently ignored.
+ */
+	extern DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor,
+					   void *pMpuAddr,
+					   u32 ulSize, u32 ulFlags);
+
+
+/*
+ *  ======== PROC_InvalidateMemory ========
+ *  Purpose:
+ *      Invalidates a buffer from the MPU data cache.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Buffer start address
+ *      ulSize	  :   Buffer size
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      All the arguments are currently ignored.
+ */
+	extern DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor,
+					   void *pMpuAddr,
+					   u32 ulSize);
+
+/*
+ *  ======== PROC_Map ========
+ *  Purpose:
+ *      Maps a MPU buffer to DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Starting address of the memory region to map.
+ *      ulSize	  :   Size of the memory region to map.
+ *      pReqAddr	:   Requested DSP start address. Offset-adjusted actual
+ *			  mapped address is in the last argument.
+ *      ppMapAddr       :   Ptr to DSP side mapped u8 address.
+ *      ulMapAttr       :   Optional endianness attributes, virt to phys flag.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_EMEMORY     :   MPU side memory allocation error.
+ *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pMpuAddr is not NULL
+ *      ulSize is not zero
+ *      ppMapAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor,
+				   void *pMpuAddr,
+				   u32 ulSize,
+				   void *pReqAddr,
+				   void **ppMapAddr, u32 ulMapAttr);
+
+/*
+ *  ======== PROC_ReserveMemory ========
+ *  Purpose:
+ *      Reserve a virtually contiguous region of DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      ulSize	  :   Size of the address space to reserve.
+ *      ppRsvAddr       :   Ptr to DSP side reserved u8 address.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
+ *  Requires:
+ *      ppRsvAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor,
+					     u32 ulSize, void **ppRsvAddr);
+
+/*
+ *  ======== PROC_UnMap ========
+ *  Purpose:
+ *      Removes a MPU buffer mapping from the DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMapAddr	:   Starting address of the mapped memory region.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pMapAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr);
+
+/*
+ *  ======== PROC_UnReserveMemory ========
+ *  Purpose:
+ *      Frees a previously reserved region of DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pRsvAddr	:   Ptr to DSP side reservedBYTE address.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pRsvAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor,
+					       void *pRsvAddr);
+
+#endif				/* PROC_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/procpriv.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/plat-omap/include/bridge/procpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== procpriv.h ========
+ *  Description:
+ *      Global PROC constants and types, shared by PROC, MGR, and WCD.
+ *
+ *! Revision History:
+ *! ================
+ *! 05-July-2000 rr: Created
+ */
+
+#ifndef PROCPRIV_
+#define PROCPRIV_
+
+/* RM PROC Object */
+	struct PROC_OBJECT;
+
+#endif				/* PROCPRIV_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/pwr.h
@@ -0,0 +1,129 @@
+/*
+ * arch/arm/plat-omap/include/bridge/pwr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== pwr.h ========
+ *
+ *  Public Functions:
+ *
+ *      PWR_SleepDSP
+ *      PWR_WakeDSP
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! ================
+ *! 06-Jun-2002 sg  Replaced dspdefs.h with includes of dbdefs.h and errbase.h.
+ *! 13-May-2002 sg  Added DSP_SAREADYASLEEP and DSP_SALREADYAWAKE.
+ *! 09-May-2002 sg  Updated, added timeouts.
+ *! 02-May-2002 sg  Initial.
+ */
+
+#ifndef PWR_
+#define PWR_
+
+#include <dbdefs.h>
+#include <errbase.h>
+#include <pwr_sh.h>
+
+/*
+ *  ======== PWR_SleepDSP ========
+ *      Signal the DSP to go to sleep.
+ *
+ *  Parameters:
+ *      sleepCode:          New sleep state for DSP.  (Initially, valid codes
+ *                          are PWR_DEEPSLEEP or PWR_EMERGENCYDEEPSLEEP; both of
+ *                          these codes will simply put the DSP in deep sleep.)
+ *
+ *	timeout:            Maximum time (msec) that PWR should wait for
+ *                          confirmation that the DSP sleep state has been
+ *                          reached.  If PWR should simply send the command to
+ *                          the DSP to go to sleep and then return (i.e.,
+ *                          asynchrounous sleep), the timeout should be
+ *                          specified as zero.
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYASLEEP: Success, but the DSP was already asleep.
+ *      DSP_EINVALIDARG:    The specified sleepCode is not supported.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for DSP sleep
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send sleep command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode,
+				       IN CONST u32 timeout);
+
+/*
+ *  ======== PWR_WakeDSP ========
+ *    Signal the DSP to wake from sleep.
+ *
+ *  Parameters:
+ *	timeout:            Maximum time (msec) that PWR should wait for
+ *                          confirmation that the DSP is awake.  If PWR should
+ *                          simply send a command to the DSP to wake and then
+ *                          return (i.e., asynchrounous wake), timeout should
+ *                          be specified as zero.
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout);
+
+/*
+ *  ======== PWR_PM_PreScale ========
+ *    Prescale notification to DSP.
+ *
+ *  Parameters:
+ *	voltage_domain:   The voltage domain for which notification is sent
+ *    level:			The level of voltage domain
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level);
+
+/*
+ *  ======== PWR_PM_PostScale ========
+ *    PostScale notification to DSP.
+ *
+ *  Parameters:
+ *	voltage_domain:   The voltage domain for which notification is sent
+ *    level:			The level of voltage domain
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain,
+					   u32 level);
+
+#endif				/* PWR_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/plat-omap/include/bridge/pwr_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== pwr_sh.h ========
+ *
+ *  Power Manager shared definitions (used on both GPP and DSP sides).
+ *
+ *! Revision History
+ *! ================
+ *! 17-Apr-2002 sg: Initial.
+ */
+
+#ifndef PWR_SH_
+#define PWR_SH_
+
+#include <mbx_sh.h>
+
+/* valid sleep command codes that can be sent by GPP via mailbox: */
+#define PWR_DEEPSLEEP           MBX_PM_DSPIDLE
+#define PWR_EMERGENCYDEEPSLEEP  MBX_PM_EMERGENCYSLEEP
+#define PWR_SLEEPUNTILRESTART   MBX_PM_SLEEPUNTILRESTART
+#define PWR_WAKEUP              MBX_PM_DSPWAKEUP
+#define PWR_AUTOENABLE          MBX_PM_PWRENABLE
+#define PWR_AUTODISABLE         MBX_PM_PWRDISABLE
+#define PWR_RETENTION             MBX_PM_DSPRETN
+
+#endif				/* PWR_SH_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/reg.h
@@ -0,0 +1,257 @@
+/*
+ * arch/arm/plat-omap/include/bridge/reg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== reg.h ========
+ *  Purpose:
+ *      Provide registry functions.
+ *
+ *  Public Functions:
+ *      REG_DeleteValue
+ *      REG_EnumKey
+ *      REG_EnumValue
+ *      REG_Exit
+ *      REG_GetValue
+ *      REG_Init
+ *      REG_SetValue
+ *
+ *! Revision History:
+ *! =================
+ *! 30-Oct-2000 kc: Updated REG_SetValue & REG_GetValue; renamed
+ *!                 REG_DeleteEntry to REG_DeleteValue.
+ *! 29-Sep-2000 kc: Updated a REG functions for code review.
+ *! 12-Aug-2000 kc: Renamed REG_EnumValue to REG_EnumKey. Re-implemented
+ *!                 REG_EnumValue.
+ *! 03-Feb-2000 rr: REG_EnumValue Fxn Added
+ *! 13-Dec-1999 rr: windows.h removed
+ *! 02-Dec-1999 rr: windows.h included for retail build
+ *! 22-Nov-1999 kc: Changes from code review.
+ *! 29-Dec-1997 cr: Changes from code review.
+ *! 27-Oct-1997 cr: Added REG_DeleteValue.
+ *! 20-Oct-1997 cr: Added ability to pass bValue = NULL to REG_GetValue
+ *!                 and return size of reg entry in pdwValueSize.
+ *! 29-Sep-1997 cr: Added REG_SetValue
+ *! 29-Aug-1997 cr: Created.
+ */
+
+#ifndef _REG_H
+#define _REG_H
+
+#include <linux/types.h>
+
+/*  ------------------------- Defines, Data Structures, Typedefs for Linux */
+#ifndef UNDER_CE
+
+#ifndef REG_SZ
+#define REG_SZ          1
+#endif
+
+#ifndef REG_BINARY
+#define REG_BINARY      3
+#endif
+
+#ifndef REG_DWORD
+#define REG_DWORD       4
+#endif
+
+#endif				/* UNDER_CE */
+
+#define REG_MAXREGPATHLENGTH    255
+
+/*
+ *  ======== REG_DeleteValue ========
+ *  Purpose:
+ *      Deletes a registry entry. NOTE: A registry entry is not the same as
+ *      a registry key.
+ *  Parameters:
+ *      phKey:      Currently reserved; must be NULL.
+ *      pstrSubkey: Path to key to open.
+ *      pstrValue:  Name of entry to delete.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrSubkey & pstrValue are non-NULL values.
+ *      - phKey is NULL.
+ *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
+ *      - length of pstrValue < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey,
+					  IN CONST char *pstrSubkey,
+					  IN CONST char *pstrValue);
+
+/*
+ *  ======== REG_EnumKey ========
+ *  Purpose:
+ *      Enumerates subkeys of the specified path to the  registry key
+ *      Retrieves the  name of the subkey(given the index) and
+ *      appends with the orignal path to form the full path.
+ *  Parameters:
+ *      phKey:      Currently reserved; must be NULL.
+ *      pstrKey     The name of the registry key to be enumerated.
+ *      dwIndex     Specifies the index of the subkey to retrieve.
+ *      pstrSubkey: Pointer to buffer that receives full path name of the
+ *                  specified key + the sub-key
+ *      pdwValueSize:   Specifies bytes of memory pstrSubkey points to on input,
+ *                      on output, specifies actual memory bytes written into.
+ *                      If there is no sub key,pdwValueSize returns NULL.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrKey is non-NULL value.
+ *      - pdwValueSize is a valid pointer.
+ *      - phKey is NULL.
+ *      - length of pstrKey < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ *      - strlen(pstrSubkey) is > strlen(pstrKey) &&
+ *      - strlen(pstrSubkey) is < REG_MAXREGPATHLENGTH
+ */
+	extern DSP_STATUS REG_EnumKey(OPTIONAL IN HANDLE *phKey,
+				      IN u32 dwIndex, IN CONST char *pstrKey,
+				      IN OUT char *pstrSubkey,
+				      IN OUT u32 *pdwValueSize);
+
+/*
+ *  ======== REG_EnumValue ========
+ *  Purpose:
+ *      Enumerates values of a specified key. Retrieves each value name and
+ *      the data associated with the value.
+ *  Parameters:
+ *      phKey:          Currently reserved; must be NULL.
+ *      dwIndex:        Specifies the index of the value to retrieve.
+ *      pstrKey:        The name of the registry key to be enumerated.
+ *      pstrValue:      Pointer to buffer that receives the name of the value.
+ *      pdwValueSize:   Specifies bytes of memory pstrValue points to on input,
+ *                      On output, specifies actual memory bytes written into.
+ *                      If there is no value, pdwValueSize returns NULL
+ *      pstrData:       Pointer to buffer that receives the data of a value.
+ *      pdwDataSize:    Specifies bytes of memory in pstrData on input and
+ *                      bytes of memory written into pstrData on output.
+ *                      If there is no data, pdwDataSize returns NULL.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      REG initialized.
+ *      phKey is NULL.
+ *      pstrKey is a non-NULL value.
+ *      pstrValue, pstrData, pdwValueSize and pdwDataSize are valid pointers.
+ *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+	extern DSP_STATUS REG_EnumValue(IN HANDLE *phKey,
+					IN u32 dwIndex,
+					IN CONST char *pstrKey,
+					IN OUT char *pstrValue,
+					IN OUT u32 *pdwValueSize,
+					IN OUT char *pstrData,
+					IN OUT u32 *pdwDataSize);
+
+/*
+ *  ======== REG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      REG initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void REG_Exit();
+
+/*
+ *  ======== REG_GetValue ========
+ *  Purpose:
+ *      Retrieve a value from the registry.
+ *  Parameters:
+ *      phKey:          Currently reserved; must be NULL.
+ *      pstrSubkey:     Path to key to open.
+ *      pstrEntry:      Name of entry to retrieve.
+ *      pbValue:        Upon return, points to retrieved value.
+ *      pdwValueSize:   Specifies bytes of memory pbValue points to on input,
+ *                      on output, specifies actual memory bytes written into.
+ *                      If pbValue is NULL, pdwValueSize reports the size of
+ *                      the entry in pstrEntry.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pbValue is a valid pointer.
+ *      - phKey is NULL.
+ *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
+ *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+	extern DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey,
+				       IN CONST char *pstrSubkey,
+				       IN CONST char *pstrEntry,
+				       OUT u8 *pbValue,
+				       IN OUT u32 *pdwValueSize);
+
+/*
+ *  ======== REG_Init ========
+ *  Purpose:
+ *      Initializes private state of REG module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      REG initialized.
+ */
+	extern bool REG_Init();
+
+/*
+ *  ======== REG_SetValue ========
+ *  Purpose:
+ *      Set a value in the registry.
+ *  Parameters:
+ *      phKey:          Handle to open reg key, or NULL if pSubkey is full path.
+ *      pstrSubkey:     Path to key to open, could be based on phKey.
+ *      pstrEntry:      Name of entry to set.
+ *      dwType:         Data type of new registry value.
+ *      pbValue:        Points to buffer containing new data.
+ *      dwValueSize:    Specifies bytes of memory bValue points to.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pbValue is a valid pointer.
+ *      - phKey is NULL.
+ *      - dwValuSize > 0.
+ *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
+ *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+	extern DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey,
+				       IN CONST char *pstrSubKey,
+				       IN CONST char *pstrEntry,
+				       IN CONST u32 dwType,
+				       IN u8 *pbValue, IN u32 dwValueSize);
+
+#endif				/* _REG_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
@@ -0,0 +1,88 @@
+/*
+ * arch/arm/plat-omap/include/bridge/resourcecleanup.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef RES_CLEANUP_DISABLE
+
+#include <nodepriv.h>
+#include <drv.h>
+
+
+extern DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
+				struct DRV_OBJECT *hDrvObject);
+
+extern DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject,
+					HANDLE hPCtxt);
+
+extern DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE pCtxt);
+
+extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcUpdatestate(HANDLE pCtxt,
+				      enum GPP_PROC_RES_STATE resState);
+
+extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
+
+extern DSP_STATUS DRV_GetProcContext(u32 phProcess,
+				struct DRV_OBJECT *hDrvObject,
+				HANDLE hPCtxt, DSP_HNODE hNode,
+				u32 pMapAddr);
+
+extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
+
+extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
+				     HANDLE hPCtxt, HANDLE hProcess);
+
+extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
+					HANDLE pCtxt);
+
+extern DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE nodeRes,
+					    HANDLE pCtxt);
+
+extern void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status);
+
+extern DSP_STATUS DRV_RemoveNodeResElement(HANDLE nodeRes, HANDLE status);
+
+extern void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status);
+
+extern DSP_STATUS DRV_UpdateDMMResElement(HANDLE dmmRes, u32 pMpuAddr,
+					  u32 ulSize, u32 pReqAddr,
+					  u32 ppMapAddr, HANDLE hProcesso);
+
+extern DSP_STATUS DRV_InsertDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
+
+extern DSP_STATUS DRV_GetDMMResElement(u32 pMapAddr, HANDLE dmmRes,
+				       HANDLE pCtxt);
+
+extern DSP_STATUS DRV_RemoveDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes,
+					HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
+						HANDLE pPctxt);
+
+extern DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
+					HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcRemoveSTRMResElement(HANDLE STRMRes, HANDLE pCtxt);
+
+extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf, u32 *pSize);
+
+extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+
+#endif
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rmm.h
@@ -0,0 +1,199 @@
+/*
+ * arch/arm/plat-omap/include/bridge/rmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== rmm.h ========
+ *
+ *  This memory manager provides general heap management and arbitrary
+ *  alignment for any number of memory segments, and management of overlay
+ *  memory.
+ *
+ *  Public functions:
+ *      RMM_alloc
+ *      RMM_create
+ *      RMM_delete
+ *      RMM_exit
+ *      RMM_free
+ *      RMM_init
+ *
+ *! Revision History
+ *! ================
+ *! 25-Jun-2002 jeh     Added RMM_Addr. Removed RMM_reserve, RMM_stat.
+ *! 15-Oct-2001 jeh     Based on rm.h in gen tree.
+ */
+
+#ifndef RMM_
+#define RMM_
+
+/*
+ *  ======== RMM_Addr ========
+ *  DSP address + segid
+ */
+struct RMM_Addr {
+	u32 addr;
+	s32 segid;
+} ;
+
+/*
+ *  ======== RMM_Segment ========
+ *  Memory segment on the DSP available for remote allocations.
+ */
+struct RMM_Segment {
+	u32 base;		/* Base of the segment */
+	u32 length;		/* Size of the segment (target MAUs) */
+	s32 space;		/* Code or data */
+	u32 number;		/* Number of Allocated Blocks */
+} ;
+
+/*
+ *  ======== RMM_Target ========
+ */
+struct RMM_TargetObj;
+
+/*
+ *  ======== RMM_alloc ========
+ *
+ *  RMM_alloc is used to remotely allocate or reserve memory on the DSP.
+ *
+ *  Parameters:
+ *      target          - Target returned from RMM_create().
+ *      segid           - Memory segment to allocate from.
+ *      size            - Size (target MAUS) to allocate.
+ *      align           - alignment.
+ *      dspAddr         - If reserve is FALSE, the location to store allocated
+ *                        address on output, otherwise, the DSP address to
+ *                        reserve.
+ *      reserve         - If TRUE, reserve the memory specified by dspAddr.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EMEMORY:            Memory allocation on GPP failed.
+ *      DSP_EOVERLAYMEMORY:     Cannot "allocate" overlay memory because it's
+ *                              already in use.
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *      dspAddr != NULL.
+ *      size > 0
+ *      reserve || target->numSegs > 0.
+ *  Ensures:
+ */
+extern DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
+			    u32 align, u32 *dspAdr, bool reserve);
+
+/*
+ *  ======== RMM_create ========
+ *  Create a target object with memory segments for remote allocation. If
+ *  segTab == NULL or numSegs == 0, memory can only be reserved through
+ *  RMM_alloc().
+ *
+ *  Parameters:
+ *      pTarget:        - Location to store target on output.
+ *      segTab:         - Table of memory segments.
+ *      numSegs:        - Number of memory segments.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *      RMM initialized.
+ *      pTarget != NULL.
+ *      numSegs == 0 || segTab != NULL.
+ *  Ensures:
+ *      Success:        Valid *pTarget.
+ *      Failure:        *pTarget == NULL.
+ */
+extern DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
+			     struct RMM_Segment segTab[], u32 numSegs);
+
+/*
+ *  ======== RMM_delete ========
+ *  Delete target allocated in RMM_create().
+ *
+ *  Parameters:
+ *      target          - Target returned from RMM_create().
+ *  Returns:
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *  Ensures:
+ */
+extern void RMM_delete(struct RMM_TargetObj *target);
+
+/*
+ *  ======== RMM_exit ========
+ *  Exit the RMM module
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      RMM_init successfully called.
+ *  Ensures:
+ */
+extern void RMM_exit(void);
+
+/*
+ *  ======== RMM_free ========
+ *  Free or unreserve memory allocated through RMM_alloc().
+ *
+ *  Parameters:
+ *      target:         - Target returned from RMM_create().
+ *      segid:          - Segment of memory to free.
+ *      dspAddr:        - Address to free or unreserve.
+ *      size:           - Size of memory to free or unreserve.
+ *      reserved:       - TRUE if memory was reserved only, otherwise FALSE.
+ *  Returns:
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *      reserved || segid < target->numSegs.
+ *      reserve || [dspAddr, dspAddr + size] is a valid memory range.
+ *  Ensures:
+ */
+extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
+		     u32 size, bool reserved);
+
+/*
+ *  ======== RMM_init ========
+ *  Initialize the RMM module
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE:   Success.
+ *      FALSE:  Failure.
+ *  Requires:
+ *  Ensures:
+ */
+extern bool RMM_init(void);
+
+/*
+ *  ======== RMM_stat ========
+ *  Obtain  memory segment status
+ *
+ *  Parameters:
+ *      segid:       Segment ID of the dynamic loading segment.
+ *      pMemStatBuf: Pointer to allocated buffer into which memory stats are
+ *                   placed.
+ *  Returns:
+ *      TRUE:   Success.
+ *      FALSE:  Failure.
+ *  Requires:
+ *      segid < target->numSegs
+ *  Ensures:
+ */
+extern bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
+		     struct DSP_MEMSTAT *pMemStatBuf);
+
+#endif				/* RMM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rms_sh.h
@@ -0,0 +1,125 @@
+/*
+ * arch/arm/plat-omap/include/bridge/rms_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== rms_sh.h ========
+ *
+ *  DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
+ *  GPP and DSP sides).
+ *
+ *! Revision History
+ *! ================
+ *! 24-Mar-2003 vp  Merged updates required for CCS2.2 transition.
+ *! 24-Feb-2003 kc  Rearranged order of node types to temporarily support
+ *!		    legacy message node code
+ *! 23-Nov-2002 gp  Converted tabs -> spaces, to fix formatting.
+ *! 13-Feb-2002 jeh Added sysstacksize element to RMS_MoreTaskArgs.
+ *! 11-Dec-2000 sg  Added 'misc' element to RMS_MoreTaskArgs.
+ *! 04-Dec-2000 ag  Added RMS_BUFDESC command code.
+ *!                 C/R code value changed to allow ORing of system/user codes.
+ *! 10-Oct-2000 sg  Added 'align' field to RMS_StrmDef.
+ *! 09-Oct-2000 sg  Moved pre-defined message codes here from rmsdefs.h.
+ *! 02-Oct-2000 sg  Changed ticks to msec.
+ *! 24-Aug-2000 sg  Moved definitions that will be exposed to app developers
+ *!  		    to a separate file, rmsdefs.h.
+ *! 10-Aug-2000 sg  Added RMS_COMMANDBUFSIZE and RMS_RESPONSEBUFSIZE; added
+ *!		    pre-defined command/response codes; more comments.
+ *! 09-Aug-2000 sg  Added RMS_ETASK.
+ *! 08-Aug-2000 jeh Define RMS_WORD for GPP, rename DSP_MSG to RMS_DSPMSG.
+ *!                 Added RMS_MsgArgs, RMS_MoreTaskArgs.
+ *! 25-Jul-2000 sg: Changed SIO to STRM.
+ *! 30-Jun-2000 sg: Initial.
+ */
+
+#ifndef RMS_SH_
+#define RMS_SH_
+
+#include <rmstypes.h>
+
+/* Node Types: */
+#define RMS_TASK                1	/* Task node */
+#define RMS_DAIS                2	/* xDAIS socket node */
+#define RMS_MSG                 3	/* Message node */
+
+/* Memory Types: */
+#define RMS_CODE                0	/* Program space */
+#define RMS_DATA                1	/* Data space */
+#define RMS_IO                	2	/* I/O space */
+
+/* RM Server Command and Response Buffer Sizes: */
+#define RMS_COMMANDBUFSIZE     256	/* Size of command buffer */
+#define RMS_RESPONSEBUFSIZE    16	/* Size of response buffer */
+
+/* Pre-Defined Command/Response Codes: */
+#define RMS_EXIT                0x80000000   /* GPP->Node: shutdown */
+#define RMS_EXITACK             0x40000000   /* Node->GPP: ack shutdown */
+#define RMS_BUFDESC             0x20000000   /* Arg1 SM buf, Arg2 is SM size */
+#define RMS_KILLTASK            0x10000000  /* GPP->Node: Kill Task */
+#define RMS_USER                0x0	/* Start of user-defined msg codes */
+#define RMS_MAXUSERCODES        0xfff	/* Maximum user defined C/R Codes */
+
+
+/* RM Server RPC Command Structure: */
+	struct RMS_Command {
+		RMS_WORD fxn;	/* Server function address */
+		RMS_WORD arg1;	/* First argument */
+		RMS_WORD arg2;	/* Second argument */
+		RMS_WORD data;	/* Function-specific data array */
+	} ;
+
+/*
+ *  The RMS_StrmDef structure defines the parameters for both input and output
+ *  streams, and is passed to a node's create function.
+ */
+	struct RMS_StrmDef {
+		RMS_WORD bufsize;	/* Buffer size (in DSP words) */
+		RMS_WORD nbufs;	/* Max number of bufs in stream */
+		RMS_WORD segid;	/* Segment to allocate buffers */
+		RMS_WORD align;	/* Alignment for allocated buffers */
+		RMS_WORD timeout;	/* Timeout (msec) for blocking calls */
+		RMS_CHAR name[1];	/* Device Name (terminated by '\0') */
+	} ;
+
+/* Message node create args structure: */
+	struct RMS_MsgArgs {
+		RMS_WORD maxMessages;	/* Max # simultaneous msgs to node */
+		RMS_WORD segid;	/* Mem segment for NODE_allocMsgBuf */
+		RMS_WORD notifyType;	/* Type of message notification */
+		RMS_WORD argLength;	/* Length (in DSP chars) of arg data */
+		RMS_WORD argData;	/* Arg data for node */
+	} ;
+
+/* Partial task create args structure */
+	struct RMS_MoreTaskArgs {
+		RMS_WORD priority;	/* Task's runtime priority level */
+		RMS_WORD stackSize;	/* Task's stack size */
+		RMS_WORD sysstackSize;	/* Task's system stack size (55x) */
+		RMS_WORD stackSeg;	/* Memory segment for task's stack */
+		RMS_WORD heapAddr;   /* base address of the node memory heap in
+				      * external memory (DSP virtual address) */
+		RMS_WORD heapSize;   /* size in MAUs of the node memory heap in
+				      * external memory */
+		RMS_WORD misc;	/* Misc field.  Not used for 'normal'
+				 * task nodes; for xDAIS socket nodes
+				 * specifies the IALG_Fxn pointer.
+				 */
+		/* # input STRM definition structures */
+		RMS_WORD numInputStreams;
+	} ;
+
+#endif				/* RMS_SH_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rmstypes.h
@@ -0,0 +1,40 @@
+/*
+ * arch/arm/plat-omap/include/bridge/rmstypes.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== rmstypes.h ========
+ *
+ *  DSP/BIOS Bridge Resource Manager Server shared data type definitions.
+ *
+ *! Revision History
+ *! ================
+ *! 06-Oct-2000 sg  Added LgFxn type.
+ *! 05-Oct-2000 sg  Changed RMS_STATUS to LgUns.
+ *! 31-Aug-2000 sg  Added RMS_DSPMSG.
+ *! 25-Aug-2000 sg  Initial.
+ */
+
+#ifndef RMSTYPES_
+#define RMSTYPES_
+#include <linux/types.h>
+/*
+ *  DSP-side definitions.
+ */
+#include <std.h>
+typedef u32 RMS_WORD;
+typedef char RMS_CHAR;
+
+#endif				/* RMSTYPES_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/services.h
@@ -0,0 +1,63 @@
+/*
+ * arch/arm/plat-omap/include/bridge/services.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== services.h ========
+ *  Purpose:
+ *      Provide loading and unloading of SERVICES modules.
+ *
+ *  Public Functions:
+ *      SERVICES_Exit()
+ *      SERVICES_Init()
+ *
+ *! Revision History:
+ *! ================
+ *! 01-Feb-2000 kc: Created.
+ */
+
+#ifndef SERVICES_
+#define SERVICES_
+
+#include <host_os.h>
+/*
+ *  ======== SERVICES_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      SERVICES initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void SERVICES_Exit();
+
+/*
+ *  ======== SERVICES_Init ========
+ *  Purpose:
+ *      Initializes SERVICES modules.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if all modules initialized; otherwise FALSE.
+ *  Requires:
+ *  Ensures:
+ *      SERVICES modules initialized.
+ */
+	extern bool SERVICES_Init();
+
+#endif				/* SERVICES_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/std.h
@@ -0,0 +1,143 @@
+/*
+ * arch/arm/plat-omap/include/bridge/std.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== std.h ========
+ *
+ *! Revision History
+ *! ================
+ *! 16-Feb-2004 vp	GNU compiler 3.x defines inline keyword. Added
+ *!			appropriate macros not to redefine inline keyword in
+ *!			this file.
+ *! 24-Oct-2002	ashu	defined _TI_ and _FIXED_ symbols for 28x.
+ *! 24-Oct-2002	ashu	defined _TI_ for 24x.
+ *! 01-Mar-2002 kln	changed LARGE_MODEL and Arg definition for 28x
+ *! 01-Feb-2002 kln	added definitions for 28x
+ *! 08-Dec-2000 kw:	added 'ArgToInt' and 'ArgToPtr' macros
+ *! 30-Nov-2000 mf:	Added _64_, _6x_; removed _7d_
+ *! 30-May-2000 srid:	Added   __TMS320C55X__ for 55x; Arg is void * for 55 .
+ *! 18-Jun-1999 dr:	Added '_TI_', fixed __inline for SUN4, added inline
+ *! 10-Feb-1999 rt:	Added '55' support, changed 54's symbol to _TMS320C5XX
+ *! 29-Aug-1998 mf: 	fixed typo, removed obsolete targets
+ *! 08-Jun-1998 mf: 	_67_ is synonym for _7d_
+ *! 10-Oct-1997 rt;	added _7d_ for Raytheon C7DSP triggered by _TMS320C6700
+ *! 04-Aug-1997 cc:	added _29_ for _TMS320C2XX
+ *! 11-Jul-1997 dlr:	_5t_, and STD_SPOXTASK keyword for Tasking
+ *! 12-Jun-1997 mf: 	_TMS320C60 -> _TMS320C6200
+ *! 13-Feb-1997 mf:	_62_, with 32-bit LgInt
+ *! 26-Nov-1996 kw: 	merged bios-c00's and wsx-a27's <std.h> changes
+ *!			*and* revision history
+ *! 12-Sep-1996 kw: 	added C54x #ifdef's
+ *! 21-Aug-1996 mf: 	removed #define main smain for _21_
+ *! 14-May-1996 gp:     def'd out INT, FLOAT, and COMPLEX defines for WSX.
+ *! 11-Apr-1996 kw:     define _W32_ based on _WIN32 (defined by MS compiler)
+ *! 07-Mar-1996 mg:     added Win32 support
+ *! 06-Sep-1995 dh:	added _77_ dynamic stack support via fxns77.h
+ *! 27-Jun-1995 dh:	added _77_ support
+ *! 16-Mar-1995 mf: 	for _21_: #define main smain
+ *! 01-Mar-1995 mf: 	set _20_ and _60_ (as well as _21_ for both)
+ *! 22-Feb-1995 mf: 	Float is float for _SUN_ and _80_
+ *! 22-Dec-1994 mf: 	Added _80_ definition, for PP or MP.
+ *! 09-Dec-1994 mf: 	Added _53_ definition.
+ *!			Added definitions of _30_, etc.
+ *! 23-Aug-1994 dh	removed _21_ special case (kw)
+ *! 17-Aug-1994 dh	added _51_ support
+ *! 03-Aug-1994 kw	updated _80_ support
+ *! 30-Jun-1994 kw	added _80_ support
+ *! 05-Apr-1994 kw:	Added _SUN_ to _FLOAT_ definition
+ *! 01-Mar-1994 kw: 	Made Bool an int (was u16) for _56_ (more efficient).
+ *!			Added _53_ support.
+ */
+
+#ifndef STD_
+#define STD_
+
+#include <linux/types.h>
+
+/*
+ *  ======== _TI_ ========
+ *  _TI_ is defined for all TI targets
+ */
+#if defined(_29_) || defined(_30_) || defined(_40_) || defined(_50_) || \
+    defined(_54_) || defined(_55_) || defined(_6x_) || defined(_80_) || \
+    defined(_28_) || defined(_24_)
+#define _TI_	1
+#endif
+
+/*
+ *  ======== _FLOAT_ ========
+ *  _FLOAT_ is defined for all targets that natively support floating point
+ */
+#if defined(_SUN_) || defined(_30_) || defined(_40_) || defined(_67_) || \
+    defined(_80_)
+#define _FLOAT_	1
+#endif
+
+/*
+ *  ======== _FIXED_ ========
+ *  _FIXED_ is defined for all fixed point target architectures
+ */
+#if defined(_29_) || defined(_50_) || defined(_54_) || defined(_55_) || \
+    defined(_62_) || defined(_64_) || defined(_28_)
+#define _FIXED_	1
+#endif
+
+/*
+ *  ======== _TARGET_ ========
+ *  _TARGET_ is defined for all target architectures (as opposed to
+ *  host-side software)
+ */
+#if defined(_FIXED_) || defined(_FLOAT_)
+#define _TARGET_ 1
+#endif
+
+/*
+ *  8, 16, 32-bit type definitions
+ *
+ *  Sm*	- 8-bit type
+ *  Md* - 16-bit type
+ *  Lg* - 32-bit type
+ *
+ *  *s32 - signed type
+ *  *u32 - unsigned type
+ *  *Bits - unsigned type (bit-maps)
+ */
+
+/*
+ *  Aliases for standard C types
+ */
+
+typedef s32(*Fxn) ();		/* generic function type */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+
+/*
+ * These macros are used to cast 'Arg' types to 's32' or 'Ptr'.
+ * These macros were added for the 55x since Arg is not the same
+ * size as s32 and Ptr in 55x large model.
+ */
+#if defined(_28l_) || defined(_55l_)
+#define ArgToInt(A)	((s32)((long)(A) & 0xffff))
+#define ArgToPtr(A)	((Ptr)(A))
+#else
+#define ArgToInt(A)	((s32)(A))
+#define ArgToPtr(A)	((Ptr)(A))
+#endif
+
+#endif				/* STD_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/strmdefs.h
@@ -0,0 +1,57 @@
+/*
+ * arch/arm/plat-omap/include/bridge/strmdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== strmdefs.h ========
+ *  Purpose:
+ *      Global STRM constants and types.
+ *
+ *! Revision History
+ *! ================
+ *! 19-Nov-2001 ag      Added STRM_INFO..
+ *! 25-Sep-2000 jeh     Created.
+ */
+
+#ifndef STRMDEFS_
+#define STRMDEFS_
+
+#define STRM_MAXEVTNAMELEN      32
+
+	struct STRM_MGR;
+
+	struct STRM_OBJECT;
+
+	struct STRM_ATTR {
+		HANDLE hUserEvent;
+		char *pstrEventName;
+		void *pVirtBase;	/* Process virtual base address of
+					 * mapped SM */
+		u32 ulVirtSize;	/* Size of virtual space in bytes */
+		struct DSP_STREAMATTRIN *pStreamAttrIn;
+	} ;
+
+	struct STRM_INFO {
+		enum DSP_STRMMODE lMode;	/* transport mode of
+					 * stream(DMA, ZEROCOPY..) */
+		u32 uSegment;	/* Segment strm allocs from. 0 is local mem */
+		void *pVirtBase;	/* "      " Stream'process virt base */
+		struct DSP_STREAMINFO *pUser;	/* User's stream information
+						 * returned */
+	} ;
+
+#endif				/* STRMDEFS_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -0,0 +1,441 @@
+/*
+ * arch/arm/plat-omap/include/bridge/strm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== strm.h ========
+ *  Description:
+ *      DSPBridge Stream Manager.
+ *
+ *  Public Functions:
+ *      STRM_AllocateBuffer
+ *      STRM_Close
+ *      STRM_Create
+ *      STRM_Delete
+ *      STRM_Exit
+ *      STRM_FreeBuffer
+ *      STRM_GetEventHandle
+ *      STRM_GetInfo
+ *      STRM_Idle
+ *      STRM_Init
+ *      STRM_Issue
+ *      STRM_Open
+ *      STRM_PrepareBuffer
+ *      STRM_Reclaim
+ *      STRM_RegisterNotify
+ *      STRM_Select
+ *      STRM_UnprepareBuffer
+ *
+ *  Notes:
+ *
+ *! Revision History:
+ *! =================
+ *! 15-Nov-2001 ag  Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
+ *!                 Added DSP_ESIZE error to STRM_AllocateBuffer().
+ *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
+ *! 10-May-2001 jeh Code review cleanup.
+ *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
+ *! 06-Feb-2001 kc  Updated DBC_Ensure for STRM_Select().
+ *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open().
+ *! 25-Sep-2000 jeh Created.
+ */
+
+#ifndef STRM_
+#define STRM_
+
+#include <dev.h>
+
+#include <strmdefs.h>
+
+/*
+ *  ======== STRM_AllocateBuffer ========
+ *  Purpose:
+ *      Allocate data buffer(s) for use with a stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer(s).
+ *      uNumBufs:       Number of buffers to allocate.
+ *      apBuffer:       Array to hold buffer addresses.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
+ *      DSP_ESIZE:      uSize must be > 0 bytes.
+ *  Requires:
+ *      STRM_Init() called.
+ *      apBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
+					      u32 uSize,
+					      OUT u8 **apBuffer,
+					      u32 uNumBufs);
+
+/*
+ *  ======== STRM_Close ========
+ *  Purpose:
+ *      Close a stream opened with STRM_Open().
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EPENDING:   Some data buffers issued to the stream have not
+ *                      been reclaimed.
+ *      DSP_EFAIL:      Failure to close stream.
+ *  Requires:
+ *      STRM_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm);
+
+/*
+ *  ======== STRM_Create ========
+ *  Purpose:
+ *      Create a STRM manager object. This object holds information about the
+ *      device needed to open streams.
+ *  Parameters:
+ *      phStrmMgr:      Location to store handle to STRM manager object on
+ *                      output.
+ *      hDev:           Device for this processor.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      STRM_Init() called.
+ *      phStrmMgr != NULL.
+ *      hDev != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valid *phStrmMgr.
+ *      error:          *phStrmMgr == NULL.
+ */
+	extern DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr,
+				      struct DEV_OBJECT *hDev);
+
+/*
+ *  ======== STRM_Delete ========
+ *  Purpose:
+ *      Delete the STRM Object.
+ *  Parameters:
+ *      hStrmMgr:       Handle to STRM manager object from STRM_Create.
+ *  Returns:
+ *  Requires:
+ *      STRM_Init() called.
+ *      Valid hStrmMgr.
+ *  Ensures:
+ *      hStrmMgr is not valid.
+ */
+	extern void STRM_Delete(struct STRM_MGR *hStrmMgr);
+
+/*
+ *  ======== STRM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of STRM module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      STRM_Init() successfully called before.
+ *  Ensures:
+ */
+	extern void STRM_Exit();
+
+/*
+ *  ======== STRM_FreeBuffer ========
+ *  Purpose:
+ *      Free buffer(s) allocated with STRM_AllocateBuffer.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      apBuffer:       Array containing buffer addresses.
+ *      uNumBufs:       Number of buffers to be freed.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid stream handle.
+ *      DSP_EFAIL:      Failure occurred, unable to free buffers.
+ *  Requires:
+ *      STRM_Init() called.
+ *      apBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
+					  u8 **apBuffer, u32 uNumBufs);
+
+/*
+ *  ======== STRM_GetEventHandle ========
+ *  Purpose:
+ *      Get stream's user event handle. This function is used when closing
+ *      a stream, so the event can be closed.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      phEvent:        Location to store event handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *  Requires:
+ *      STRM_Init() called.
+ *      phEvent != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_GetEventHandle(struct STRM_OBJECT *hStrm,
+					      OUT HANDLE *phEvent);
+
+/*
+ *  ======== STRM_GetInfo ========
+ *  Purpose:
+ *      Get information about a stream. User's DSP_STREAMINFO is contained
+ *      in STRM_INFO struct. STRM_INFO also contains Bridge private info.
+ *  Parameters:
+ *      hStrm:              Stream handle returned from STRM_Open().
+ *      pStreamInfo:        Location to store stream info on output.
+ *      uSteamInfoSize:     Size of user's DSP_STREAMINFO structure.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hStrm.
+ *      DSP_ESIZE:          uStreamInfoSize < sizeof(DSP_STREAMINFO).
+ *      DSP_EFAIL:          Unable to get stream info.
+ *  Requires:
+ *      STRM_Init() called.
+ *      pStreamInfo != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
+				       OUT struct STRM_INFO *pStreamInfo,
+				       u32 uStreamInfoSize);
+
+/*
+ *  ======== STRM_Idle ========
+ *  Purpose:
+ *      Idle a stream and optionally flush output data buffers.
+ *      If this is an output stream and fFlush is TRUE, all data currently
+ *      enqueued will be discarded.
+ *      If this is an output stream and fFlush is FALSE, this function
+ *      will block until all currently buffered data is output, or the timeout
+ *      specified has been reached.
+ *      After a successful call to STRM_Idle(), all buffers can immediately
+ *      be reclaimed.
+ *  Parameters:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      fFlush:         If TRUE, discard output buffers.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_ETIMEOUT:   A timeout occurred before the stream could be idled.
+ *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
+ *      DSP_EFAIL:      Unable to idle stream.
+ *  Requires:
+ *      STRM_Init() called.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush);
+
+/*
+ *  ======== STRM_Init ========
+ *  Purpose:
+ *      Initialize the STRM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern bool STRM_Init();
+
+/*
+ *  ======== STRM_Issue ========
+ *  Purpose:
+ *      Send a buffer of data to a stream.
+ *  Parameters:
+ *      hStrm:              Stream handle returned from STRM_Open().
+ *      pBuf:               Pointer to buffer of data to be sent to the stream.
+ *      ulBytes:            Number of bytes of data in the buffer.
+ *      ulBufSize:          Actual buffer size in bytes.
+ *      dwArg:              A user argument that travels with the buffer.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hStrm.
+ *      DSP_ESTREAMFULL:    The stream is full.
+ *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
+ *  Requires:
+ *      STRM_Init() called.
+ *      pBuf != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf,
+				     u32 ulBytes, u32 ulBufSize,
+				     IN u32 dwArg);
+
+/*
+ *  ======== STRM_Open ========
+ *  Purpose:
+ *      Open a stream for sending/receiving data buffers to/from a task of
+ *      DAIS socket node on the DSP.
+ *  Parameters:
+ *      hNode:          Node handle returned from NODE_Allocate().
+ *      uDir:           DSP_TONODE or DSP_FROMNODE.
+ *      uIndex:         Stream index.
+ *      pAttr:          Pointer to structure containing attributes to be
+ *                      applied to stream. Cannot be NULL.
+ *      phStrm:         Location to store stream handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EDIRECTION: Invalid uDir.
+ *      DSP_EVALUE:     Invalid uIndex.
+ *      DSP_ENODETYPE:  hNode is not a task or DAIS socket node.
+ *      DSP_EFAIL:      Unable to open stream.
+ *  Requires:
+ *      STRM_Init() called.
+ *      phStrm != NULL.
+ *      pAttr != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *phStrm is valid.
+ *      error:          *phStrm == NULL.
+ */
+	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
+				    u32 uIndex, IN struct STRM_ATTR *pAttr,
+				    OUT struct STRM_OBJECT **phStrm);
+
+/*
+ *  ======== STRM_PrepareBuffer ========
+ *  Purpose:
+ *      Prepare a data buffer not allocated by DSPStream_AllocateBuffers()
+ *      for use with a stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer.
+ *      pBuffer:        Buffer address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
+ *  Requires:
+ *      STRM_Init() called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_PrepareBuffer(struct STRM_OBJECT *hStrm,
+					     u32 uSize,
+					     u8 *pBuffer);
+
+/*
+ *  ======== STRM_Reclaim ========
+ *  Purpose:
+ *      Request a buffer back from a stream.
+ *  Parameters:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      pBufPtr:        Location to store pointer to reclaimed buffer.
+ *      pulBytes:       Location where number of bytes of data in the
+ *                      buffer will be written.
+ *      pulBufSize:     Location where actual buffer size will be written.
+ *      pdwArg:         Location where user argument that travels with
+ *                      the buffer will be written.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_ETIMEOUT:   A timeout occurred before a buffer could be
+ *                      retrieved.
+ *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
+ *  Requires:
+ *      STRM_Init() called.
+ *      pBufPtr != NULL.
+ *      pulBytes != NULL.
+ *      pdwArg != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm,
+				       OUT u8 **pBufPtr, u32 *pulBytes,
+				       u32 *pulBufSize, u32 *pdwArg);
+
+/*
+ *  ======== STRM_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this stream.
+ *  Parameters:
+ *      hStrm:          Stream handle returned by STRM_Open().
+ *      uEventMask:     Mask of types of events to be notified about.
+ *      uNotifyType:    Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      DSP_EVALUE:     uEventMask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *                      supported.
+ *  Requires:
+ *      STRM_Init() called.
+ *      hNotification != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== STRM_Select ========
+ *  Purpose:
+ *      Select a ready stream.
+ *  Parameters:
+ *      aStrmTab:       Array of stream handles returned from STRM_Open().
+ *      nStrms:         Number of stream handles in array.
+ *      pMask:          Location to store mask of ready streams on output.
+ *      uTimeout:       Timeout value (milliseconds).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ERANGE:     nStrms out of range.
+
+ *      DSP_EHANDLE:    Invalid stream handle in array.
+ *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
+ *      DSP_EFAIL:      Failure occurred, unable to select a stream.
+ *  Requires:
+ *      STRM_Init() called.
+ *      aStrmTab != NULL.
+ *      nStrms > 0.
+ *      pMask != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *pMask != 0 || uTimeout == 0.
+ *      Error:          *pMask == 0.
+ */
+	extern DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab,
+				      u32 nStrms,
+				      OUT u32 *pMask, u32 uTimeout);
+
+/*
+ *  ======== STRM_UnprepareBuffer ========
+ *  Purpose:
+ *      Unprepare a data buffer that was previously prepared for a stream
+ *      with DSPStream_PrepareBuffer(), and that will no longer be used with
+ *      the stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer.
+ *      pBuffer:        Buffer address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
+ *  Requires:
+ *      STRM_Init() called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_UnprepareBuffer(struct STRM_OBJECT *hStrm,
+					       u32 uSize,
+					       u8 *pBuffer);
+
+#endif				/* STRM_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/sync.h
@@ -0,0 +1,339 @@
+/*
+ * arch/arm/plat-omap/include/bridge/sync.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  ======== sync.h ========
+ *  Purpose:
+ *      Provide synchronization services.
+ *
+ *  Public Functions:
+ *      SYNC_CloseEvent
+ *      SYNC_DeleteCS
+ *      SYNC_EnterCS
+ *      SYNC_Exit
+ *      SYNC_Init
+ *      SYNC_InitializeCS
+ *      SYNC_LeaveCS
+ *      SYNC_OpenEvent
+ *      SYNC_PostMessage
+ *      SYNC_ResetEvent
+ *      SYNC_SetEvent
+ *      SYNC_WaitOnEvent
+ *      SYNC_WaitOnMultipleEvents
+ *
+ *! Revision History:
+ *! ================
+ *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
+ *! 01-Dec-1999 ag: Added #define SYNC_MAXNAMELENGTH.
+ *! 04-Nov-1999 kc: Added critical section functions and objects to SYNC.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 24-Sep-1999 kc: Added WinCE notes.
+ *! 20-Oct-1997 gp: Removed unused SYNC_ critical section and must complete fxns
+ *!                 Added SYNC_HOBJECT, SYNC_ATTRS, and object validation, and
+ *!                 merged SYNC_DestroyEvent into SYNC_CloseEvent, and merged
+ *!                 SYNC_CreateEvent into SYNC_OpenEvent.
+ *! 07-Oct-1997 gp: Added SYNC_Create/DestroyEvent (for NT testing).
+ *! 06-Oct-1997 gp: Added SYNC_OpenEvent.
+ *! 03-Jun-1997 gp: Added SYNC_{Begin|End}CritSection() functions.
+ *! 03-Jan-1997 gp: Added SYNC_INFINITE define.
+ *! 05-Aug-1996 gp: Created.
+ */
+
+#ifndef _SYNC_H
+#define _SYNC_H
+
+/* Special timeout value indicating an infinite wait: */
+#define SYNC_INFINITE  0xffffffff
+
+/* Maximum string length of a named event */
+#define SYNC_MAXNAMELENGTH 32
+
+/* Generic SYNC object: */
+	struct SYNC_OBJECT;
+	/*typedef struct SYNC_OBJECT *SYNC_HOBJECT;*/
+
+/* Generic SYNC CS object: */
+	struct SYNC_CSOBJECT;
+	/*typedef struct SYNC_CSOBJECT *SYNC_HCSOBJECT;*/
+
+/* Used SYNC_CSOBJECT instead of SYNC_DPCCSOBJECT to avoid warnings */
+	/*typedef struct SYNC_CSOBJECT *SYNC_HDPCCSOBJECT;*/
+
+/* SYNC object attributes: */
+	struct SYNC_ATTRS {
+		HANDLE hUserEvent;    /* Platform's User Mode synch. object. */
+		HANDLE hKernelEvent;  /* Platform's Kernel Mode sync. object. */
+		u32 dwReserved1;	/* For future expansion.   */
+		u32 dwReserved2;	/* For future expansion.   */
+	} ;
+
+/*
+ *  ======== SYNC_CloseEvent ========
+ *  Purpose:
+ *      Close this event handle, freeing resources allocated in SYNC_OpenEvent
+ *      if necessary.
+ *  Parameters:
+ *      hEvent: Handle to a synchronization event, created/opened in
+ *              SYNC_OpenEvent.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EFAIL:      Failed to close event handle.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ *      Any subsequent usage of hEvent would be invalid.
+ */
+	extern DSP_STATUS SYNC_CloseEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_DeleteCS ========
+ *  Purpose:
+ *      Delete a critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_DeleteCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_EnterCS ========
+ *  Purpose:
+ *      Enter the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_EnterCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void SYNC_Exit();
+
+/*
+ *  ======== SYNC_Init ========
+ *  Purpose:
+ *      Initializes private state of SYNC module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      SYNC initialized.
+ */
+	extern bool SYNC_Init();
+
+/*
+ *  ======== SYNC_InitializeCS ========
+ *  Purpose:
+ *      Initialize the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Out of memory.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj);
+
+/*
+ *  ======== SYNC_InitializeDPCCS ========
+ *  Purpose:
+ *      Initialize the critical section between process context and DPC.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Out of memory.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT
+					       **phCSObj);
+
+/*
+ *  ======== SYNC_LeaveCS ========
+ *  Purpose:
+ *      Leave the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_LeaveCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_OpenEvent ========
+ *  Purpose:
+ *      Create/open and initialize an event object for thread synchronization,
+ *      which is initially in the non-signalled state.
+ *  Parameters:
+ *      phEvent:    Pointer to location to receive the event object handle.
+ *      pAttrs:     Pointer to SYNC_ATTRS object containing initial SYNC
+ *                  SYNC_OBJECT attributes.  If this pointer is NULL, then
+ *                  SYNC_OpenEvent will create and manage an OS specific
+ *                  syncronization object.
+ *          pAttrs->hUserEvent:  Platform's User Mode synchronization object.
+ *
+ *      The behaviour of the SYNC methods depend on the value of
+ *      the hUserEvent attr:
+ *
+ *      1. (hUserEvent == NULL):
+ *          A user mode event is created.
+ *      2. (hUserEvent != NULL):
+ *          A user mode event is supplied by the caller of SYNC_OpenEvent().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to create user mode event.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EINVALIDARG SYNC_ATTRS values are invalid.
+ *  Requires:
+ *      - SYNC initialized.
+ *      - phEvent != NULL.
+ *  Ensures:
+ *      If function succeeded, pEvent->hEvent must be a valid event handle.
+ */
+	extern DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
+					 IN OPTIONAL struct SYNC_ATTRS
+					 *pAttrs);
+
+/*
+ * ========= SYNC_PostMessage ========
+ *  Purpose:
+ *      To post a windows message
+ *  Parameters:
+ *      hWindow:    Handle to the window
+ *      uMsg:       Message to be posted
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EFAIL:      Post message failed
+ *      DSP_EHANDLE:    Invalid Window handle
+ *  Requires:
+ *      SYNC initialized
+ *  Ensures
+ */
+	extern DSP_STATUS SYNC_PostMessage(IN HANDLE hWindow, IN u32 uMsg);
+
+/*
+ *  ======== SYNC_ResetEvent ========
+ *  Purpose:
+ *      Reset a syncronization event object state to non-signalled.
+ *  Parameters:
+ *      hEvent:         Handle to a sync event.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EFAIL:      Failed to reset event.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_ResetEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_SetEvent ========
+ *  Purpose:
+ *      Signal the event.  Will unblock one waiting thread.
+ *  Parameters:
+ *      hEvent:         Handle to an event object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to signal event.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_SetEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_WaitOnEvent ========
+ *  Purpose:
+ *      Wait for an event to be signalled, up to the specified timeout.
+ *  Parameters:
+ *      hEvent:         Handle to an event object.
+ *      dwTimeOut:      The time-out interval, in milliseconds.
+ *                      The function returns if the interval elapses, even if
+ *                      the object's state is nonsignaled.
+ *                      If zero, the function tests the object's state and
+ *                      returns immediately.
+ *                      If SYNC_INFINITE, the function's time-out interval
+ *                      never elapses.
+ *  Returns:
+ *      DSP_SOK:        The object was signalled.
+ *      DSP_EHANDLE:    Invalid handle.
+ *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
+ *      SYNC_E_TIMEOUT: Timeout expired while waiting for event to be signalled.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_WaitOnEvent(IN struct SYNC_OBJECT *hEvent,
+					   IN u32 dwTimeOut);
+
+/*
+ *  ======== SYNC_WaitOnMultipleEvents ========
+ *  Purpose:
+ *      Wait for any of an array of events to be signalled, up to the
+ *      specified timeout.
+ *      Note: dwTimeOut must be SYNC_INFINITE to signal infinite wait.
+ *  Parameters:
+ *      hSyncEvents:    Array of handles to event objects.
+ *      uCount:         Number of event handles.
+ *      dwTimeOut:      The time-out interval, in milliseconds.
+ *                      The function returns if the interval elapses, even if
+ *                      no event is signalled.
+ *                      If zero, the function tests the object's state and
+ *                      returns immediately.
+ *                      If SYNC_INFINITE, the function's time-out interval
+ *                      never elapses.
+ *      puIndex:        Location to store index of event that was signalled.
+ *  Returns:
+ *      DSP_SOK:        The object was signalled.
+ *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
+ *      SYNC_E_TIMEOUT: Timeout expired before event was signalled.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_WaitOnMultipleEvents(IN struct SYNC_OBJECT
+						    **hSyncEvents,
+						    IN u32 uCount,
+						    IN u32 dwTimeout,
+						    OUT u32 *puIndex);
+
+#endif				/* _SYNC_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/utildefs.h
@@ -0,0 +1,51 @@
+/*
+ * arch/arm/plat-omap/include/bridge/utildefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== utildefs.h ========
+ *  Purpose:
+ *      Global UTIL constants and types, shared between WCD and DSPSYS.
+ *
+ *! Revision History:
+ *! ================
+ *! 24-Feb-2003 kc  Removed wIOPort* entries from UTIL_HOSTCONFIG.
+ *! 12-Aug-2000 ag  Added UTIL_SYSINFO typedef.
+ *! 08-Oct-1999 rr  Adopted for WinCE where test fxns will be added in util.h
+ *! 26-Dec-1996 cr  Created.
+ */
+
+#ifndef UTILDEFS_
+#define UTILDEFS_
+
+/* constants taken from configmg.h */
+#define UTIL_MAXMEMREGS     9
+#define UTIL_MAXIOPORTS     20
+#define UTIL_MAXIRQS        7
+#define UTIL_MAXDMACHNLS    7
+
+/* misc. constants */
+#define UTIL_MAXARGVS       10
+
+/* Platform specific important info */
+	struct UTIL_SYSINFO {
+		/* Granularity of page protection; usually 1k or 4k */
+		u32 dwPageSize;
+		u32 dwAllocationGranularity; /* VM granularity, usually 64K */
+		u32 dwNumberOfProcessors;	/* Used as sanity check */
+	} ;
+
+#endif				/* UTILDEFS_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/util.h
@@ -0,0 +1,173 @@
+/*
+ * arch/arm/plat-omap/include/bridge/util.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== util.h ========
+ *  Purpose:
+ *      Provide general purpose utility functions.
+ *
+ *  Public Functions:
+ *      UTIL_CDTestDll
+ *      UTIL_CmdLineToArgs
+ *      UTIL_Exit
+ *      UTIL_GetSysInfo
+ *      UTIL_Init
+ *      UTIL_Wait
+ *
+ *  Private Functions:
+ *      isspace
+ *
+ *  Notes:
+ *
+ *! Revision History
+ *! ================
+ *! 12-Aug-2000 ag: Added UTIL_GetSysInfo().
+ *! 31-Jan-2000 rr: Comments modifed for UTIL_Wait fxn.
+ *! 17-Jan-2000 rr: UTIL_Wait fxn added. Busy waits x number of micro seconds.
+ *! 12-Nov-1999 kc: Modified UTIL_CmdLineToArgs for use by different tests.
+ *! 02-Nov-1999 kc: Removed parameter from UTIL_CDTestDll.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 08-Oct-1999 kc: Renamed UTIL_TestDllExec to UTIL_CDTestDll; added
+ *!                 UTIL_CmdLineToArgs(); added isspace private func.
+ *! 26-Dec-1996 cr: Created from misc pieces of wcd95.c, ktest.c.
+ *
+ */
+
+#ifndef _UTIL_H
+#define _UTIL_H
+
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <utildefs.h>
+
+/*
+ *  ======== UTIL_CDTestDll ========
+ *  Purpose:
+ *      Provides test entry point in class driver context.
+ *  Parameters:
+ *      cArgc:  test module command line input count.
+ *      ppArgv: test module command line args.
+ *  Returns:
+ *      0 if successful, a negative value otherwise.
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ */
+	extern u32 UTIL_CDTestDll(IN s32 cArgc, IN char **ppArgv);
+
+/*
+ *  ======== UTIL_CmdLineToArgs ========
+ *  Purpose:
+ *      This function re-creates C-style cmd line argc & argv from WinMain()
+ *      cmd line args.
+ *  Parameters:
+ *      s8 *pszProgName   - The name of the program currently being executed.
+ *      s8 *argv[]        - The argument vector.
+ *      s8 *pCmdLine      - The pointer to the command line.
+ *      bool fHasProgName   - Indicats whether a program name is supplied.
+ *  Returns:
+ *      Returns the number of arguments found.
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ */
+	extern s32 UTIL_CmdLineToArgs(IN char *pszProgName,
+				      IN char *argv[UTIL_MAXARGVS],
+				      IN char *pCmdLine, IN bool fHasProgName);
+
+/*
+ *  ======== UTIL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern inline void UTIL_Exit(void)
+	{
+	}
+/*
+ *  ======== UTIL_GetSysInfo ========
+ *  Purpose:
+ *      This function return platform specific system information.
+ *
+ *  Parameters:
+ *      pSysInfo  - address to store the system information.
+ *  Returns:
+ *      DSP_SOK
+ *      S_FAIL
+ *  Requires:
+ *      UTIL initialized.
+ *      pSysInfo != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS UTIL_GetSysInfo(OUT struct UTIL_SYSINFO *pSysInfo);
+
+/*
+ *  ======== UTIL_Init ========
+ *  Purpose:
+ *      Initializes private state of UTIL module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success, else FALSE.
+ *  Requires:
+ *  Ensures:
+ *      UTIL initialized.
+ */
+	extern inline bool UTIL_Init(void)
+	{
+		return true;
+	}
+
+/*
+ *  ======== UTIL_Wait ========
+ *  Purpose:
+ *      This fucntion busy waits given a certain number of micro seconds
+ *      independent of the processor speed. This is acheived by the
+ *      OEM functions QueryPerformanceCounter and QueryPerformanceFrequency.
+ *  Parameters:
+ *      u32   Number of Micro seconds to busy wait
+ *  Returns:
+ *          Nothing
+ *  Requires:
+ *          UTIL_Initalized.
+ *  Ensures:
+ *      Busy waits x Micro seconds or Sleeps X milli seconds; in that
+ *      case, it is a blocking call there will be a context switching
+ *      hence it may not represent the absolute busy wait time.
+ */
+	extern inline void UTIL_Wait(IN u32 dwMicroSeconds)
+	{
+		if (dwMicroSeconds / 1000 <= 1) {
+			/* <= 1 millisecond delay */
+			udelay(dwMicroSeconds);
+		} else if (dwMicroSeconds * HZ / 1000000 <= 1) {
+			/* <= 10 millisecond delay */
+			mdelay(dwMicroSeconds / 1000);
+		} else {
+			/* > 10 millisecond delay */
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(dwMicroSeconds * HZ / 1000000);
+		}
+	}
+
+#endif				/* _UTIL_H */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/uuidutil.h
@@ -0,0 +1,74 @@
+/*
+ * arch/arm/plat-omap/include/bridge/uuidutil.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== uuidutil.h ========
+ *  Description:
+ *      This file contains the specification of UUID helper functions.
+ *
+ *! Revision History
+ *! ================
+ *! 09-Nov-2000 kc: Modified description of UUID utility functions.
+ *! 29-Sep-2000 kc: Appended "UUID_" prefix to UUID helper functions.
+ *! 10-Aug-2000 kc: Created.
+ *!
+ */
+
+#ifndef UUIDUTIL_
+#define UUIDUTIL_
+
+#define MAXUUIDLEN  37
+
+/*
+ *  ======== UUID_UuidToString ========
+ *  Purpose:
+ *      Converts a DSP_UUID to an ANSI string.
+ *  Parameters:
+ *      pUuid:      Pointer to a DSP_UUID object.
+ *      pszUuid:    Pointer to a buffer to receive a NULL-terminated UUID
+ *                  string.
+ *      size:	    Maximum size of the pszUuid string.
+ *  Returns:
+ *  Requires:
+ *      pUuid & pszUuid are non-NULL values.
+ *  Ensures:
+ *      Lenghth of pszUuid is less than MAXUUIDLEN.
+ *  Details:
+ *      UUID string limit currently set at MAXUUIDLEN.
+ */
+	void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
+			       s32 size);
+
+/*
+ *  ======== UUID_UuidFromString ========
+ *  Purpose:
+ *      Converts an ANSI string to a DSP_UUID.
+ *  Parameters:
+ *      pszUuid:    Pointer to a string that represents a DSP_UUID object.
+ *      pUuid:      Pointer to a DSP_UUID object.
+ *  Returns:
+ *  Requires:
+ *      pUuid & pszUuid are non-NULL values.
+ *  Ensures:
+ *  Details:
+ *      We assume the string representation of a UUID has the following format:
+ *      "12345678_1234_1234_1234_123456789abc".
+ */
+	extern void UUID_UuidFromString(IN char *pszUuid,
+					OUT struct DSP_UUID *pUuid);
+
+#endif				/* UUIDUTIL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wcd.h
@@ -0,0 +1,61 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wcd.h ========
+ *  Description:
+ *      'Bridge class driver library functions, object definitions, and
+ *      return error/status codes.  To be included by 'Bridge mini drivers.
+ *
+ *  Public Functions:
+ *      See mem.h and dbg.h.
+ *
+ *  Notes:
+ *      'Bridge Class Driver services exported to WMD's are initialized by the
+ *      WCD on behalf of the WMD.  WMD's must not call module Init/Exit
+ *      functions.
+ *
+ *      To ensure WMD binary compatibility across different platforms,
+ *      for the same processor, a WMD must restrict its usage of system
+ *      services to those exported by the 'Bridge class library.
+ *
+ *! Revision History:
+ *! ================
+ *! 07-Jun-2000 jeh Added dev.h
+ *! 01-Nov-1999 ag: #WINCE# WCD_MAJOR_VERSION=8 & WCD_MINOR_VERSION=0 to match
+ *!		    dll stamps.
+ *!                 0.80 - 0.89 Alpha, 0.90 - 0.99 Beta, 1.00 - 1.10 FCS.
+ *! 17-Sep-1997 gp: Changed size of CFG_HOSTRES structure; and ISR_Install API;
+ *!                 Changed WCD_MINOR_VERSION 3 -> 4.
+ *! 15-Sep-1997 gp: Moved WCD_(Un)registerMinidriver to drv.
+ *! 25-Jul-1997 cr: Added WCD_UnregisterMinidriver.
+ *! 22-Jul-1997 cr: Added WCD_RegisterMinidriver, WCD_MINOR_VERSION 2 -> 3.
+ *! 12-Nov-1996 gp: Defined port io macros.
+ *! 07-Nov-1996 gp: Updated for code review.
+ *! 16-Jul-1996 gp: Added CHNL fxns; updated WCD lib version to 2.
+ *! 10-May-1996 gp: Separated WMD def.s' into wmd.h.
+ *! 03-May-1996 gp: Created.
+ */
+
+#ifndef WCD_
+#define WCD_
+
+/* This WCD Library Version:  */
+#define WCD_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
+#define WCD_MINOR_VERSION   (u32)0
+
+#endif				/* WCD_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
@@ -0,0 +1,519 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wcdioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wcdioctl.h ========
+ *  Purpose:
+ *      Contains structures and commands that are used for interaction
+ *      between the DDSP API and class driver.
+ *
+ *! Revision History
+ *! ================
+ *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
+ *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping structs & offsets
+ *! 15-Oct-2002 kc  Updated definitions for private PERF module.
+ *! 16-Aug-2002 map Added ARGS_MGR_REGISTEROBJECT & ARGS_MGR_UNREGISTEROBJECT
+ *!		 Added CMD_MGR_REGISTEROBJECT_OFFSET &
+ *!		 CMD_MGR_UNREGISTEROBJECT_OFFSET
+ *! 15-Jan-2002 ag  Added actaul bufSize to ARGS_STRM_[RECLAIM][ISSUE].
+ *! 15-Nov-2001 ag  change to STRMINFO in ARGS_STRM_GETINFO.
+ *! 11-Sep-2001 ag  ARGS_CMM_GETHANDLE defn uses DSP_HPROCESSOR.
+ *! 23-Apr-2001 jeh Added pStatus to NODE_TERMINATE args.
+ *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
+ *! 22-Nov-2000 kc: Added CMD_MGR_GETPERF_DATA_OFFSET for acquiring PERF stats.
+ *! 27-Oct-2000 jeh Added timeouts to NODE_GETMESSAGE, NODE_PUTMESSAGE args.
+ *!		 Removed NODE_GETMESSAGESTRM args.
+ *! 11-Oct-2000 ag: Added SM mgr(CMM) args.
+ *! 27-Sep-2000 jeh Removed struct DSP_BUFFERATTR param from
+ *!		    ARGS_STRM_ALLOCATEBUFFER.
+ *! 25-Sep-2000 rr: Updated to Version 0.9
+ *! 07-Sep-2000 jeh Changed HANDLE to DSP_HNOTIFICATION in RegisterNotify args.
+ *!		 Added DSP_STRMATTR to DSPNode_Connect args.
+ *! 04-Aug-2000 rr: MEM and UTIL added to RM.
+ *! 27-Jul-2000 rr: NODE, MGR,STRM and PROC added
+ *! 27-Jun-2000 rr: Modifed to Use either PM or DSP/BIOS Bridge
+ *!		 IFDEF to build for PM or DSP/BIOS Bridge
+ *! 28-Jan-2000 rr: NT_CMD_FROM_OFFSET moved out to dsptrap.h
+ *! 24-Jan-2000 rr: Merged with Scott's code.
+ *! 21-Jan-2000 sg: In ARGS_CHNL_GETMODE changed mode to be u32 to be
+ *!		 consistent with chnldefs.h.
+ *! 11-Jan-2000 rr: CMD_CFG_GETCDVERSION_OFFSET added.
+ *! 12-Nov-1999 rr: CMD_BRD_MONITOR_OFFSET added
+ *! 09-Nov-1999 kc: Added MEMRY and enabled CMD_BRD_IOCTL_OFFSET.
+ *! 05-Nov-1999 ag: Added CHNL.
+ *! 02-Nov-1999 kc: Removed field from ARGS_UTIL_TESTDLL.
+ *! 29-Oct-1999 kc: Cleaned up for code review.
+ *! 08-Oct-1999 rr: Util control offsets added.
+ *! 13-Sep-1999 kc: Added ARGS_UTIL_TESTDLL for PM test infrastructure.
+ *! 19-Aug-1999 rr: Created from WSX. Minimal Implementaion of BRD_Start and BRD
+ *!		 and BRD_Stop. IOCTL Offsets and CTRL Code.
+ */
+
+#ifndef WCDIOCTL_
+#define WCDIOCTL_
+
+#include <mem.h>
+#include <cmm.h>
+#include <strmdefs.h>
+#include <dbdcd.h>
+
+union Trapped_Args {
+
+	/* MGR Module */
+	struct {
+		u32 uNode;
+		struct DSP_NDBPROPS __user *pNDBProps;
+		u32 uNDBPropsSize;
+		u32 __user *puNumNodes;
+	} ARGS_MGR_ENUMNODE_INFO;
+
+	struct {
+		u32 uProcessor;
+		struct DSP_PROCESSORINFO __user *pProcessorInfo;
+		u32 uProcessorInfoSize;
+		u32 __user *puNumProcs;
+	} ARGS_MGR_ENUMPROC_INFO;
+
+	struct {
+		struct DSP_UUID *pUuid;
+		enum DSP_DCDOBJTYPE objType;
+		char *pszPathName;
+	} ARGS_MGR_REGISTEROBJECT;
+
+	struct {
+		struct DSP_UUID *pUuid;
+		enum DSP_DCDOBJTYPE objType;
+	} ARGS_MGR_UNREGISTEROBJECT;
+
+	struct {
+		struct DSP_NOTIFICATION  __user*__user *aNotifications;
+		u32 uCount;
+		u32 __user *puIndex;
+		u32 uTimeout;
+	} ARGS_MGR_WAIT;
+
+	/* PROC Module */
+	struct {
+		u32 uProcessor;
+		struct DSP_PROCESSORATTRIN __user *pAttrIn;
+		DSP_HPROCESSOR __user *phProcessor;
+	} ARGS_PROC_ATTACH;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 dwCmd;
+		struct DSP_CBDATA __user *pArgs;
+	} ARGS_PROC_CTRL;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+	} ARGS_PROC_DETACH;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		DSP_HNODE __user *aNodeTab;
+		u32 uNodeTabSize;
+		u32 __user *puNumNodes;
+		u32 __user *puAllocated;
+	} ARGS_PROC_ENUMNODE_INFO;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 uResourceType;
+		struct DSP_RESOURCEINFO *pResourceInfo;
+		u32 uResourceInfoSize;
+	} ARGS_PROC_ENUMRESOURCES;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		struct DSP_PROCESSORSTATE __user *pProcStatus;
+		u32 uStateInfoSize;
+	} ARGS_PROC_GETSTATE;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u8 __user *pBuf;
+
+	#ifndef RES_CLEANUP_DISABLE
+	    u8 __user *pSize;
+    #endif
+		u32 uMaxSize;
+	} ARGS_PROC_GETTRACE;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		s32 iArgc;
+		char __user*__user *aArgv;
+		char *__user *aEnvp;
+	} ARGS_PROC_LOAD;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_PROC_REGISTER_NOTIFY;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+	} ARGS_PROC_START;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 ulSize;
+		void *__user *ppRsvAddr;
+	} ARGS_PROC_RSVMEM;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 ulSize;
+		void *pRsvAddr;
+	} ARGS_PROC_UNRSVMEM;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+		void *pReqAddr;
+		void *__user *ppMapAddr;
+		u32 ulMapAttr;
+	} ARGS_PROC_MAPMEM;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		u32 ulSize;
+		void *pMapAddr;
+	} ARGS_PROC_UNMAPMEM;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+		u32 ulFlags;
+	} ARGS_PROC_FLUSHMEMORY;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+	} ARGS_PROC_STOP;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+	} ARGS_PROC_INVALIDATEMEMORY;
+
+
+	/* NODE Module */
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		struct DSP_UUID __user *pNodeID;
+		struct DSP_CBDATA __user *pArgs;
+		struct DSP_NODEATTRIN __user *pAttrIn;
+		DSP_HNODE __user *phNode;
+	} ARGS_NODE_ALLOCATE;
+
+	struct {
+		DSP_HNODE hNode;
+		u32 uSize;
+		struct DSP_BUFFERATTR __user *pAttr;
+		u8 *__user *pBuffer;
+	} ARGS_NODE_ALLOCMSGBUF;
+
+	struct {
+		DSP_HNODE hNode;
+		s32 iPriority;
+	} ARGS_NODE_CHANGEPRIORITY;
+
+	struct {
+		DSP_HNODE hNode;
+		u32 uStream;
+		DSP_HNODE hOtherNode;
+		u32 uOtherStream;
+		struct DSP_STRMATTR __user *pAttrs;
+		struct DSP_CBDATA __user *pConnParam;
+	} ARGS_NODE_CONNECT;
+
+	struct {
+		DSP_HNODE hNode;
+	} ARGS_NODE_CREATE;
+
+	struct {
+		DSP_HNODE hNode;
+	} ARGS_NODE_DELETE;
+
+	struct {
+		DSP_HNODE hNode;
+		struct DSP_BUFFERATTR __user *pAttr;
+		u8 *pBuffer;
+	} ARGS_NODE_FREEMSGBUF;
+
+	struct {
+		DSP_HNODE hNode;
+		struct DSP_NODEATTR __user *pAttr;
+		u32 uAttrSize;
+	} ARGS_NODE_GETATTR;
+
+	struct {
+		DSP_HNODE hNode;
+		struct DSP_MSG __user *pMessage;
+		u32 uTimeout;
+	} ARGS_NODE_GETMESSAGE;
+
+	struct {
+		DSP_HNODE hNode;
+	} ARGS_NODE_PAUSE;
+
+	struct {
+		DSP_HNODE hNode;
+		struct DSP_MSG __user *pMessage;
+		u32 uTimeout;
+	} ARGS_NODE_PUTMESSAGE;
+
+	struct {
+		DSP_HNODE hNode;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_NODE_REGISTERNOTIFY;
+
+	struct {
+		DSP_HNODE hNode;
+	} ARGS_NODE_RUN;
+
+	struct {
+		DSP_HNODE hNode;
+		DSP_STATUS __user *pStatus;
+	} ARGS_NODE_TERMINATE;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		struct DSP_UUID __user *pNodeID;
+		struct DSP_NDBPROPS __user *pNodeProps;
+	} ARGS_NODE_GETUUIDPROPS;
+
+	/* STRM module */
+
+	struct {
+		DSP_HSTREAM hStream;
+		u32 uSize;
+		u8 *__user *apBuffer;
+		u32 uNumBufs;
+	} ARGS_STRM_ALLOCATEBUFFER;
+
+	struct {
+		DSP_HSTREAM hStream;
+	} ARGS_STRM_CLOSE;
+
+	struct {
+		DSP_HSTREAM hStream;
+		u8 *__user *apBuffer;
+		u32 uNumBufs;
+	} ARGS_STRM_FREEBUFFER;
+
+	struct {
+		DSP_HSTREAM hStream;
+		HANDLE *phEvent;
+	} ARGS_STRM_GETEVENTHANDLE;
+
+	struct {
+		DSP_HSTREAM hStream;
+		struct STRM_INFO __user *pStreamInfo;
+		u32 uStreamInfoSize;
+	} ARGS_STRM_GETINFO;
+
+	struct {
+		DSP_HSTREAM hStream;
+		bool bFlush;
+	} ARGS_STRM_IDLE;
+
+	struct {
+		DSP_HSTREAM hStream;
+		u8 *pBuffer;
+		u32 dwBytes;
+		u32 dwBufSize;
+		u32 dwArg;
+	} ARGS_STRM_ISSUE;
+
+	struct {
+		DSP_HNODE hNode;
+		u32 uDirection;
+		u32 uIndex;
+		struct STRM_ATTR __user *pAttrIn;
+		DSP_HSTREAM __user *phStream;
+	} ARGS_STRM_OPEN;
+
+	struct {
+		DSP_HSTREAM hStream;
+		u8 *__user *pBufPtr;
+		u32 __user *pBytes;
+		u32 __user *pBufSize;
+		u32 __user *pdwArg;
+	} ARGS_STRM_RECLAIM;
+
+	struct {
+		DSP_HSTREAM hStream;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_STRM_REGISTERNOTIFY;
+
+	struct {
+		DSP_HSTREAM __user *aStreamTab;
+		u32 nStreams;
+		u32 __user *pMask;
+		u32 uTimeout;
+	} ARGS_STRM_SELECT;
+
+	/* CMM Module */
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		u32 uSize;
+		struct CMM_ATTRS *pAttrs;
+		OUT void **ppBufVA;
+	} ARGS_CMM_ALLOCBUF;
+
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		void *pBufPA;
+		u32 ulSegId;
+	} ARGS_CMM_FREEBUF;
+
+	struct {
+		DSP_HPROCESSOR hProcessor;
+		struct CMM_OBJECT *__user *phCmmMgr;
+	} ARGS_CMM_GETHANDLE;
+
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		struct CMM_INFO __user *pCmmInfo;
+	} ARGS_CMM_GETINFO;
+
+	/* MEM Module */
+	struct {
+		u32 cBytes;
+		enum MEM_POOLATTRS type;
+		void *pMem;
+	} ARGS_MEM_ALLOC;
+
+	struct {
+		u32 cBytes;
+		enum MEM_POOLATTRS type;
+		void *pMem;
+	} ARGS_MEM_CALLOC;
+
+	struct {
+		void *pMem;
+	} ARGS_MEM_FREE;
+
+	struct {
+		void *pBuffer;
+		u32 cSize;
+		void *pLockedBuffer;
+	} ARGS_MEM_PAGELOCK;
+
+	struct {
+		void *pBuffer;
+		u32 cSize;
+	} ARGS_MEM_PAGEUNLOCK;
+
+	/* UTIL module */
+	struct {
+		s32 cArgc;
+		char **ppArgv;
+	} ARGS_UTIL_TESTDLL;
+} ;
+
+#define CMD_BASE		    1
+
+/* MGR module offsets */
+#define CMD_MGR_BASE_OFFSET	     CMD_BASE
+#define CMD_MGR_ENUMNODE_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 0)
+#define CMD_MGR_ENUMPROC_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 1)
+#define CMD_MGR_REGISTEROBJECT_OFFSET   (CMD_MGR_BASE_OFFSET + 2)
+#define CMD_MGR_UNREGISTEROBJECT_OFFSET (CMD_MGR_BASE_OFFSET + 3)
+#define CMD_MGR_WAIT_OFFSET	     (CMD_MGR_BASE_OFFSET + 4)
+
+#ifndef RES_CLEANUP_DISABLE
+#define CMD_MGR_RESOUCES_OFFSET	 (CMD_MGR_BASE_OFFSET + 5)
+#define CMD_MGR_END_OFFSET	      CMD_MGR_RESOUCES_OFFSET
+#else
+#define CMD_MGR_END_OFFSET	      CMD_MGR_WAIT_OFFSET
+#endif
+
+#define CMD_PROC_BASE_OFFSET	    (CMD_MGR_END_OFFSET + 1)
+#define CMD_PROC_ATTACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 0)
+#define CMD_PROC_CTRL_OFFSET	    (CMD_PROC_BASE_OFFSET + 1)
+#define CMD_PROC_DETACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 2)
+#define CMD_PROC_ENUMNODE_OFFSET	(CMD_PROC_BASE_OFFSET + 3)
+#define CMD_PROC_ENUMRESOURCES_OFFSET   (CMD_PROC_BASE_OFFSET + 4)
+#define CMD_PROC_GETSTATE_OFFSET	(CMD_PROC_BASE_OFFSET + 5)
+#define CMD_PROC_GETTRACE_OFFSET	(CMD_PROC_BASE_OFFSET + 6)
+#define CMD_PROC_LOAD_OFFSET	    (CMD_PROC_BASE_OFFSET + 7)
+#define CMD_PROC_REGISTERNOTIFY_OFFSET  (CMD_PROC_BASE_OFFSET + 8)
+#define CMD_PROC_START_OFFSET	   (CMD_PROC_BASE_OFFSET + 9)
+#define CMD_PROC_RSVMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 10)
+#define CMD_PROC_UNRSVMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 11)
+#define CMD_PROC_MAPMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 12)
+#define CMD_PROC_UNMAPMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 13)
+#define CMD_PROC_FLUSHMEMORY_OFFSET      (CMD_PROC_BASE_OFFSET + 14)
+#define CMD_PROC_STOP_OFFSET	    (CMD_PROC_BASE_OFFSET + 15)
+#define CMD_PROC_INVALIDATEMEMORY_OFFSET (CMD_PROC_BASE_OFFSET + 16)
+#define CMD_PROC_END_OFFSET	     CMD_PROC_INVALIDATEMEMORY_OFFSET
+
+
+#define CMD_NODE_BASE_OFFSET	    (CMD_PROC_END_OFFSET + 1)
+#define CMD_NODE_ALLOCATE_OFFSET	(CMD_NODE_BASE_OFFSET + 0)
+#define CMD_NODE_ALLOCMSGBUF_OFFSET     (CMD_NODE_BASE_OFFSET + 1)
+#define CMD_NODE_CHANGEPRIORITY_OFFSET  (CMD_NODE_BASE_OFFSET + 2)
+#define CMD_NODE_CONNECT_OFFSET	 (CMD_NODE_BASE_OFFSET + 3)
+#define CMD_NODE_CREATE_OFFSET	  (CMD_NODE_BASE_OFFSET + 4)
+#define CMD_NODE_DELETE_OFFSET	  (CMD_NODE_BASE_OFFSET + 5)
+#define CMD_NODE_FREEMSGBUF_OFFSET      (CMD_NODE_BASE_OFFSET + 6)
+#define CMD_NODE_GETATTR_OFFSET	 (CMD_NODE_BASE_OFFSET + 7)
+#define CMD_NODE_GETMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 8)
+#define CMD_NODE_PAUSE_OFFSET	   (CMD_NODE_BASE_OFFSET + 9)
+#define CMD_NODE_PUTMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 10)
+#define CMD_NODE_REGISTERNOTIFY_OFFSET  (CMD_NODE_BASE_OFFSET + 11)
+#define CMD_NODE_RUN_OFFSET	     (CMD_NODE_BASE_OFFSET + 12)
+#define CMD_NODE_TERMINATE_OFFSET       (CMD_NODE_BASE_OFFSET + 13)
+#define CMD_NODE_GETUUIDPROPS_OFFSET    (CMD_NODE_BASE_OFFSET + 14)
+#define CMD_NODE_END_OFFSET	     CMD_NODE_GETUUIDPROPS_OFFSET
+
+#define CMD_STRM_BASE_OFFSET	    (CMD_NODE_END_OFFSET + 1)
+#define CMD_STRM_ALLOCATEBUFFER_OFFSET  (CMD_STRM_BASE_OFFSET + 0)
+#define CMD_STRM_CLOSE_OFFSET	   (CMD_STRM_BASE_OFFSET + 1)
+#define CMD_STRM_FREEBUFFER_OFFSET      (CMD_STRM_BASE_OFFSET + 2)
+#define CMD_STRM_GETEVENTHANDLE_OFFSET  (CMD_STRM_BASE_OFFSET + 3)
+#define CMD_STRM_GETINFO_OFFSET	 (CMD_STRM_BASE_OFFSET + 4)
+#define CMD_STRM_IDLE_OFFSET	    (CMD_STRM_BASE_OFFSET + 5)
+#define CMD_STRM_ISSUE_OFFSET	   (CMD_STRM_BASE_OFFSET + 6)
+#define CMD_STRM_OPEN_OFFSET	    (CMD_STRM_BASE_OFFSET + 7)
+#define CMD_STRM_RECLAIM_OFFSET	 (CMD_STRM_BASE_OFFSET + 8)
+#define CMD_STRM_REGISTERNOTIFY_OFFSET  (CMD_STRM_BASE_OFFSET + 9)
+#define CMD_STRM_SELECT_OFFSET	  (CMD_STRM_BASE_OFFSET + 10)
+#define CMD_STRM_END_OFFSET	     CMD_STRM_SELECT_OFFSET
+
+/* Communication Memory Manager (UCMM) */
+#define CMD_CMM_BASE_OFFSET	     (CMD_STRM_END_OFFSET + 1)
+#define CMD_CMM_ALLOCBUF_OFFSET	 (CMD_CMM_BASE_OFFSET + 0)
+#define CMD_CMM_FREEBUF_OFFSET	  (CMD_CMM_BASE_OFFSET + 1)
+#define CMD_CMM_GETHANDLE_OFFSET	(CMD_CMM_BASE_OFFSET + 2)
+#define CMD_CMM_GETINFO_OFFSET	  (CMD_CMM_BASE_OFFSET + 3)
+#define CMD_CMM_END_OFFSET	      CMD_CMM_GETINFO_OFFSET
+
+#define CMD_BASE_END_OFFSET	CMD_CMM_END_OFFSET
+#endif				/* WCDIOCTL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
@@ -0,0 +1,90 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmdchnl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmdchnl.h ========
+ *  Description:
+ *      Declares the upper edge channel class library functions required by
+ *      all WMD / WCD driver interface tables.  These functions are implemented
+ *      by every class of WMD channel library.
+ *
+ *  Public Functions:
+ *
+ *  Notes:
+ *      The function comment headers reside with the function typedefs in wmd.h.
+ *
+ *! Revision History:
+ *! ================
+ *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
+ *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
+ *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream
+ *!                 support.
+ *! 11-Jul-1996 gp: Created.
+ */
+
+#ifndef WMDCHNL_
+#define WMDCHNL_
+
+	extern DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+					  struct DEV_OBJECT *hDevObject,
+					  IN CONST struct CHNL_MGRATTRS
+					  *pMgrAttrs);
+
+	extern DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+
+	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
+					struct CHNL_MGR *hChnlMgr,
+					CHNL_MODE uMode,
+					u32 uChnlId,
+					CONST IN OPTIONAL struct CHNL_ATTRS
+					*pAttrs);
+
+	extern DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl);
+
+	extern DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
+					    void *pHostBuf,
+					    u32 cBytes, u32 cBufSize,
+					    OPTIONAL u32 dwDspAddr,
+					    u32 dwArg);
+
+	extern DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl,
+					  u32 dwTimeOut,
+					  OUT struct CHNL_IOC *pIOC);
+
+	extern DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
+
+	extern DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
+					   u32 dwTimeOut);
+
+	extern DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
+					   OUT struct CHNL_INFO *pInfo);
+
+	extern DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr,
+					      u32 uChnlID,
+					      OUT struct CHNL_MGRINFO
+					      *pMgrInfo);
+
+	extern DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl,
+					u32 dwTimeOut, bool fFlush);
+
+	extern DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl,
+						  u32 uEventMask,
+						  u32 uNotifyType,
+						  struct DSP_NOTIFICATION
+						  *hNotification);
+
+#endif				/* WMDCHNL_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
@@ -0,0 +1,64 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmddeh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmddeh.h ========
+ *  Description:
+ *      Defines upper edge DEH functions required by all WMD/WCD driver
+ *      interface tables.
+ *
+ *  Public Functions:
+ *      WMD_DEH_Create
+ *      IVA_DEH_Create
+ *      WMD_DEH_Destroy
+ *      WMD_DEH_GetInfo
+ *      WMD_DEH_RegisterNotify
+ *      WMD_DEH_Notify
+ *
+ *  Notes:
+ *      Function comment headers reside with the function typedefs in wmd.h.
+ *
+ *! Revision History:
+ *! ================
+ *! 26-Dec-2004 hn: added IVA_DEH_Create.
+ *! 13-Sep-2001 kc: created.
+ */
+
+#ifndef WMDDEH_
+#define WMDDEH_
+
+#include <devdefs.h>
+
+#include <dehdefs.h>
+
+	extern DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
+					 struct DEV_OBJECT *hDevObject);
+
+	extern DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr);
+
+	extern DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
+					  struct DSP_ERRORINFO *pErrInfo);
+
+	extern DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr,
+						 u32 uEventMask,
+						 u32 uNotifyType,
+						 struct DSP_NOTIFICATION
+						 *hNotification);
+
+	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
+				   u32 ulEventMask, u32 dwErrInfo);
+#endif				/* WMDDEH_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -0,0 +1,1193 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmd.h ========
+ *  Purpose:
+ *      'Bridge mini driver entry point and interface function declarations.
+ *
+ *  Public Functions:
+ *      WMD_DRV_Entry
+ *
+ *  Notes:
+ *      The 'Bridge class driver obtains it's function interface to
+ *      the 'Bridge mini driver via a call to WMD_DRV_Entry().
+ *
+ *      'Bridge Class Driver services exported to WMD's are initialized by the
+ *      WCD on behalf of the WMD.
+ *
+ *      WMD function DBC Requires and Ensures are also made by the WCD on
+ *      behalf of the WMD, to simplify the WMD code.
+ *
+ *! Revision History:
+ *! ================
+ *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
+ *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs - WMD_BRD_MemMap/UnMap
+ *! 01-Mar-2004 vp  Added filename argument to WMD_DRV_Entry function.
+ *! 29-Aug-2002 map Added WMD_BRD_MemWrite()
+ *! 26-Aug-2002 map Added WMD_BRD_MemCopy()
+ *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
+ *! 05-Nov-2001 kc: Added error handling DEH functions.
+ *! 06-Dec-2000 jeh Added uEventMask to WMD_MSG_RegisterNotify().
+ *! 17-Nov-2000 jeh Added WMD_MSG and WMD_IO definitions.
+ *! 01-Nov-2000 jeh Added more error codes to WMD_CHNL_RegisterNotify().
+ *! 13-Oct-2000 jeh Added dwArg to WMD_CHNL_AddIOReq(), added WMD_CHNL_IDLE
+ *!                 and WMD_CHNL_RegisterNotify for DSPStream support.
+ *! 17-Jan-2000 rr: WMD_BRD_SETSTATE Added.
+ *! 30-Jul-1997 gp: Split wmd IOCTL space into reserved and private.
+ *! 07-Nov-1996 gp: Updated for code review.
+ *! 18-Oct-1996 gp: Added WMD_E_HARDWARE return code from WMD_BRD_Monitor.
+ *! 09-Sep-1996 gp: Subtly altered the semantics of WMD_CHNL_GetInfo().
+ *! 02-Aug-1996 gp: Ensured on BRD_Start that interrupts to the PC are enabled.
+ *! 11-Jul-1996 gp: Added CHNL interface. Note stronger DBC_Require conditions.
+ *! 29-May-1996 gp: Removed WCD_ prefix from functions imported from WCD.LIB.
+ *! 29-May-1996 gp: Made OUT param first in WMD_DEV_Create().
+ *! 09-May-1996 gp: Created.
+ */
+
+#ifndef WMD_
+#define WMD_
+
+#include <brddefs.h>
+#include <cfgdefs.h>
+#include <chnlpriv.h>
+#include <dehdefs.h>
+#include <devdefs.h>
+#include <iodefs.h>
+#include <msgdefs.h>
+
+/*
+ *  Any IOCTLS at or above this value are reserved for standard WMD
+ *  interfaces.
+ */
+#define WMD_RESERVEDIOCTLBASE   0x8000
+
+/* Handle to mini-driver's private device context.  */
+	struct WMD_DEV_CONTEXT;
+
+/*---------------------------------------------------------------------------*/
+/* 'Bridge MINI DRIVER FUNCTION TYPES                                        */
+/*---------------------------------------------------------------------------*/
+
+/*
+ *  ======== WMD_BRD_Monitor ========
+ *  Purpose:
+ *      Bring the board to the BRD_IDLE (monitor) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_IDLE state;
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(
+			   *WMD_BRD_MONITOR) (struct WMD_DEV_CONTEXT
+			   *hDevContext);
+
+/*
+ *  ======== WMD_BRD_SETSTATE ========
+ *  Purpose:
+ *      Sets the Mini driver state
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulBrdState:     Board state
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Ensures:
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Update the Board state to the specified state.
+ */
+       typedef DSP_STATUS(
+			   *WMD_BRD_SETSTATE) (struct WMD_DEV_CONTEXT
+			   *hDevContext, u32 ulBrdState);
+
+/*
+ *  ======== WMD_BRD_Start ========
+ *  Purpose:
+ *      Bring board to the BRD_RUNNING (start) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      dwDSPAddr:      DSP address at which to start execution.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *      Board is in monitor (BRD_IDLE) state.
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_START) (struct WMD_DEV_CONTEXT
+						*hDevContext, u32 dwDSPAddr);
+
+/*
+ *  ======== WMD_BRD_MemCopy ========
+ *  Purpose:
+ *  Copy memory from one DSP address to another
+ *  Parameters:
+ *      pDevContext:    Pointer to context handle
+ *  ulDspDestAddr:  DSP address to copy to
+ *  ulDspSrcAddr:   DSP address to copy from
+ *  ulNumBytes: Number of bytes to copy
+ *  ulMemType:  What section of memory to copy to
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      pDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMCOPY) (struct WMD_DEV_CONTEXT
+					     *hDevContext,
+					     u32 ulDspDestAddr,
+					     u32 ulDspSrcAddr,
+					     u32 ulNumBytes, u32 ulMemType);
+/*
+ *  ======== WMD_BRD_MemWrite ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.  Unlike WMD_BRD_Write, this API does reset the DSP
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMWRITE) (struct WMD_DEV_CONTEXT
+					*hDevContext,
+					IN u8 *pHostBuf,
+					u32 dwDSPAddr, u32 ulNumBytes,
+					u32 ulMemType);
+
+/*
+ *  ======== WMD_BRD_MemMap ========
+ *  Purpose:
+ *      Map a MPU memory region to a DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulMpuAddr:      MPU memory region start address.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ulNumBytes:     Number of bytes to map.
+ *      mapAttrs:       Mapping attributes (e.g. endianness).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMMAP) (struct WMD_DEV_CONTEXT
+					*hDevContext, u32 ulMpuAddr,
+					u32 ulVirtAddr, u32 ulNumBytes,
+					u32 ulMapAttrs);
+
+/*
+ *  ======== WMD_BRD_MemUnMap ========
+ *  Purpose:
+ *      UnMap an MPU memory region from DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ulNumBytes:     Number of bytes to unmap.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMUNMAP) (struct WMD_DEV_CONTEXT
+					*hDevContext,
+					u32 ulVirtAddr,
+					u32 ulNumBytes);
+
+/*
+ *  ======== WMD_BRD_Stop ========
+ *  Purpose:
+ *      Bring board to the BRD_STOPPED state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_STOPPED (stop) state;
+ *                      Interrupts to the PC are disabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_STOP) (struct WMD_DEV_CONTEXT
+					*hDevContext);
+
+/*
+ *  ======== WMD_BRD_Status ========
+ *  Purpose:
+ *      Report the current state of the board.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      pdwState:       Ptr to BRD status variable.
+ *  Returns:
+ *      DSP_SOK:
+ *  Requires:
+ *      pdwState != NULL;
+ *      hDevContext != NULL
+ *  Ensures:
+ *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
+ */
+       typedef DSP_STATUS(*
+			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
+					    OUT BRD_STATUS * pdwState);
+
+/*
+ *  ======== WMD_BRD_Read ========
+ *  Purpose:
+ *      Read a block of DSP memory, from a given memory space, into a host
+ *      buffer.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Destination).
+ *      dwDSPAddr:      Address on DSP board (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP from which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ *  Will not write more than ulNumBytes bytes into pHostBuf.
+ */
+typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
+						  OUT u8 *pHostBuf,
+						  u32 dwDSPAddr,
+						  u32 ulNumBytes,
+						  u32 ulMemType);
+
+/*
+ *  ======== WMD_BRD_Write ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
+						   IN u8 *pHostBuf,
+						   u32 dwDSPAddr,
+						   u32 ulNumBytes,
+						   u32 ulMemType);
+
+/*
+ *  ======== WMD_CHNL_Create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given 'Bridge board.
+ *  Parameters:
+ *      phChnlMgr:      Location to store a channel manager object on output.
+ *      hDevObject:     Handle to a device object.
+ *      pMgrAttrs:      Channel manager attributes.
+ *      pMgrAttrs->cChannels: Max channels
+ *      pMgrAttrs->bIRQ:      Channel's I/O IRQ number.
+ *      pMgrAttrs->fShared:   TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize: DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->dwSMBase:  Base physical address of shared memory, if any.
+ *      pMgrAttrs->uSMLength: Bytes of shared memory block.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EMEMORY:        Insufficient memory for requested resources.
+ *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
+ *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
+ *  Requires:
+ *      phChnlMgr != NULL.
+ *      pMgrAttrs != NULL
+ *      pMgrAttrs field are all valid:
+ *          0 < cChannels <= CHNL_MAXCHANNELS.
+ *          bIRQ <= 15.
+ *          uWordSize > 0.
+ *      IsValidHandle(hDevObject)
+ *      No channel manager exists for this board.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CREATE)(OUT struct CHNL_MGR
+						    **phChnlMgr,
+						    struct DEV_OBJECT
+						    *hDevObject,
+						    IN CONST struct
+						    CHNL_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== WMD_CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ *  Parameters:
+ *      hChnlMgr:       Channel manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hChnlMgr was invalid.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
+ *          CHNL_Create may subsequently be called for the same device.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_DESTROY) (struct CHNL_MGR
+						      *hChnlMgr);
+/*
+ *  ======== WMD_DEH_Notify ========
+ *  Purpose:
+ *      When notified of DSP error, take appropriate action.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *      ulEventMask:  Indicate the type of exception
+ *      dwErrInfo:     Error information
+ *  Returns:
+ *
+ *  Requires:
+ *      hDehMgr != NULL;
+ *     ulEventMask with a valid exception
+ *  Ensures:
+ */
+       typedef void (*WMD_DEH_NOTIFY)(struct DEH_MGR *hDehMgr,
+					u32 ulEventMask, u32 dwErrInfo);
+
+
+/*
+ *  ======== WMD_CHNL_Open ========
+ *  Purpose:
+ *      Open a new half-duplex channel to the DSP board.
+ *  Parameters:
+ *      phChnl:         Location to store a channel object handle.
+ *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
+ *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *                      direction of data transfer.
+ *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
+ *                      select a free channel id (default);
+ *                      otherwise this field specifies the id of the channel.
+ *      pAttrs:         Channel attributes.  Attribute fields are as follows:
+ *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
+ *                      be pending at any given time. All request packets are
+ *                      preallocated when the channel is opened.
+ *      pAttrs->hEvent: This field allows the user to supply an auto reset
+ *                      event object for channel I/O completion notifications.
+ *                      It is the responsibility of the user to destroy this
+ *                      object AFTER closing the channel.
+ *                      This channel event object can be retrieved using
+ *                      CHNL_GetEventHandle().
+ *      pAttrs->hReserved: The kernel mode handle of this event object.
+ *
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            hChnlMgr is invalid.
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      DSP_EINVALIDARG:        Invalid number of IOReqs.
+ *      CHNL_E_OUTOFSTREAMS:    No free channels available.
+ *      CHNL_E_BADCHANID:       Channel ID is out of range.
+ *      CHNL_E_CHANBUSY:        Channel is in use.
+ *      CHNL_E_NOIORPS:         No free IO request packets available for
+ *                              queuing.
+ *  Requires:
+ *      phChnl != NULL.
+ *      pAttrs != NULL.
+ *      pAttrs->hEvent is a valid event handle.
+ *      pAttrs->hReserved is the kernel mode handle for pAttrs->hEvent.
+ *  Ensures:
+ *      DSP_SOK:                *phChnl is a valid channel.
+ *      else:                   *phChnl is set to NULL if (phChnl != NULL);
+ */
+       typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
+						   **phChnl,
+						   struct CHNL_MGR *hChnlMgr,
+						   CHNL_MODE uMode,
+						   u32 uChnlId,
+						   CONST IN OPTIONAL struct
+						   CHNL_ATTRS *pAttrs);
+
+/*
+ *  ======== WMD_CHNL_Close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ *  Parameters:
+ *      hChnl:          Handle to a channel object.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *      No thread must be blocked on this channel's I/O completion event.
+ *  Ensures:
+ *      DSP_SOK:        hChnl is no longer valid.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CLOSE) (struct CHNL_OBJECT *hChnl);
+
+/*
+ *  ======== WMD_CHNL_AddIOReq ========
+ *  Purpose:
+ *      Enqueue an I/O request for data transfer on a channel to the DSP.
+ *      The direction (mode) is specified in the channel object. Note the DSP
+ *      address is specified for channels opened in direct I/O mode.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      pHostBuf:       Host buffer address source.
+ *      cBytes:         Number of PC bytes to transfer. A zero value indicates
+ *                      that this buffer is the last in the output channel.
+ *                      A zero value is invalid for an input channel.
+ *!     cBufSize:       Actual buffer size in host bytes.
+ *      dwDspAddr:      DSP address for transfer.  (Currently ignored).
+ *      dwArg:          A user argument that travels with the buffer.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pHostBuf is invalid.
+ *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
+ *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
+ *                      I/O is allowed.
+ *      CHNL_E_EOS:     End of stream was already marked on a previous
+ *                      IORequest on this channel.  No further I/O is expected.
+ *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
+ *                      the size of the physical shared memory output window.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: The buffer will be transferred if the channel is ready;
+ *          otherwise, will be queued for transfer when the channel becomes
+ *          ready.  In any case, notifications of I/O completion are
+ *          asynchronous.
+ *          If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's
+ *          on this channel will fail with error code CHNL_E_EOS.  The
+ *          corresponding IOC for this I/O request will have its status flag
+ *          set to CHNL_IOCSTATEOS.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_ADDIOREQ) (struct CHNL_OBJECT
+						       *hChnl,
+						       void *pHostBuf,
+						       u32 cBytes,
+						       u32 cBufSize,
+						       OPTIONAL u32 dwDspAddr,
+						       u32 dwArg);
+
+/*
+ *  ======== WMD_CHNL_GetIOC ========
+ *  Purpose:
+ *      Dequeue an I/O completion record, which contains information about the
+ *      completed I/O request.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
+ *                      first available IOC.
+ *      pIOC:           On output, contains host buffer address, bytes
+ *                      transferred, and status of I/O completion.
+ *      pIOC->status:   See chnldefs.h.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pIOC is invalid.
+ *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
+ *                      yet no I/O completions were queued.
+ *  Requires:
+ *      dwTimeOut == CHNL_IOCNOWAIT.
+ *  Ensures:
+ *      DSP_SOK: if there are any remaining IOC's queued before this call
+ *          returns, the channel event object will be left in a signalled
+ *          state.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETIOC) (struct CHNL_OBJECT *hChnl,
+						     u32 dwTimeOut,
+						     OUT struct CHNL_IOC *pIOC);
+
+/*
+ *  ======== WMD_CHNL_CancelIO ========
+ *  Purpose:
+ *      Return all I/O requests to the client which have not yet been
+ *      transferred.  The channel's I/O completion object is
+ *      signalled, and all the I/O requests are queued as IOC's, with the
+ *      status field set to CHNL_IOCSTATCANCEL.
+ *      This call is typically used in abort situations, and is a prelude to
+ *      CHNL_Close();
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *  Ensures:
+ *      Subsequent I/O requests to this channel will not be accepted.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CANCELIO) (struct CHNL_OBJECT
+						       *hChnl);
+
+/*
+ *  ======== WMD_CHNL_FlushIO ========
+ *  Purpose:
+ *      For an output stream (to the DSP), indicates if any IO requests are in
+ *      the output request queue.  For input streams (from the DSP), will
+ *      cancel all pending IO requests.
+ *  Parameters:
+ *      hChnl:              Channel object handle.
+ *      dwTimeOut:          Timeout value for flush operation.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            No I/O requests will be pending on this channel.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_FLUSHIO) (struct CHNL_OBJECT *hChnl,
+						      u32 dwTimeOut);
+
+/*
+ *  ======== WMD_CHNL_GetInfo ========
+ *  Purpose:
+ *      Retrieve information related to a channel.
+ *  Parameters:
+ *      hChnl:          Handle to a valid channel object, or NULL.
+ *      pInfo:          Location to store channel info.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pInfo == NULL.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:        pInfo points to a filled in CHNL_INFO struct,
+ *                      if (pInfo != NULL).
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETINFO) (struct CHNL_OBJECT *hChnl,
+						      OUT struct CHNL_INFO
+						      *pChnlInfo);
+
+/*
+ *  ======== WMD_CHNL_GetMgrInfo ========
+ *  Purpose:
+ *      Retrieve information related to the channel manager.
+ *  Parameters:
+ *      hChnlMgr:           Handle to a valid channel manager, or NULL.
+ *      uChnlID:            Channel ID.
+ *      pMgrInfo:           Location to store channel manager info.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnlMgr.
+ *      DSP_EPOINTER:       pMgrInfo == NULL.
+ *      CHNL_E_BADCHANID:   Invalid channel ID.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            pMgrInfo points to a filled in CHNL_MGRINFO
+ *                          struct, if (pMgrInfo != NULL).
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETMGRINFO) (struct CHNL_MGR
+							 *hChnlMgr,
+							 u32 uChnlID,
+							 OUT struct CHNL_MGRINFO
+							 *pMgrInfo);
+
+/*
+ *  ======== WMD_CHNL_Idle ========
+ *  Purpose:
+ *      Idle a channel. If this is an input channel, or if this is an output
+ *      channel and fFlush is TRUE, all currently enqueued buffers will be
+ *      dequeued (data discarded for output channel).
+ *      If this is an output channel and fFlush is FALSE, this function
+ *      will block until all currently buffered data is output, or the timeout
+ *      specified has been reached.
+ *
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
+ *                      to wait for buffers to be output. (Not used for
+ *                      input channel).
+ *      fFlush:         If output channel and fFlush is TRUE, discard any
+ *                      currently buffered data. If FALSE, wait for currently
+ *                      buffered data to be output, or timeout, whichever
+ *                      occurs first. fFlush is ignored for input channel.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_IDLE) (struct CHNL_OBJECT *hChnl,
+						   u32 dwTimeOut,
+						   bool fFlush);
+
+/*
+ *  ======== WMD_CHNL_RegisterNotify ========
+ *  Purpose:
+ *      Register for notification of events on a channel.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      uEventMask:     Type of events to be notified about: IO completion
+ *                      (DSP_STREAMIOCOMPLETION) or end of stream
+ *                      (DSP_STREAMDONE).
+ *      uNotifyType:    DSP_SIGNALEVENT.
+ *      hNotification:  Handle of a DSP_NOTIFICATION object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EVALUE:     uEventMask is 0 and hNotification was not
+ *                      previously registered.
+ *      DSP_EHANDLE:    NULL hNotification, hNotification event name
+ *                      too long, or hNotification event name NULL.
+ *  Requires:
+ *      Valid hChnl.
+ *      hNotification != NULL.
+ *      (uEventMask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
+ *      uNotifyType == DSP_SIGNALEVENT.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_REGISTERNOTIFY)
+				(struct CHNL_OBJECT *hChnl,
+				u32 uEventMask,
+				u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_DEV_Create ========
+ *  Purpose:
+ *      Complete creation of the device object for this board.
+ *  Parameters:
+ *      phDevContext:   Ptr to location to store a WMD device context.
+ *      hDevObject:     Handle to a Device Object, created and managed by WCD.
+ *      pConfig:        Ptr to configuration parameters provided by the Windows
+ *                      Configuration Manager during device loading.
+ *      pDspConfig:     DSP resources, as specified in the registry key for this
+ *                      device.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Unable to allocate memory for device context.
+ *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
+ *                          parameters did not satisfy hardware assumptions
+ *                          made by this WMD.
+ *  Requires:
+ *      phDevContext != NULL;
+ *      hDevObject != NULL;
+ *      pConfig != NULL;
+ *      pDspConfig != NULL;
+ *      Fields in pConfig and pDspConfig contain valid values.
+ *  Ensures:
+ *      DSP_SOK:        All mini-driver specific DSP resource and other
+ *                      board context has been allocated.
+ *      DSP_EMEMORY:    WMD failed to allocate resources.
+ *                      Any acquired resources have been freed.  The WCD will
+ *                      not call WMD_DEV_Destroy() if WMD_DEV_Create() fails.
+ *  Details:
+ *      Called during the CONFIGMG's Device_Init phase. Based on host and
+ *      DSP configuration information, create a board context, a handle to
+ *      which is passed into other WMD BRD and CHNL functions.  The
+ *      board context contains state information for the device. Since the
+ *      addresses of all IN pointer parameters may be invalid when this
+ *      function returns, they must not be stored into the device context
+ *      structure.
+ */
+       typedef DSP_STATUS(*WMD_DEV_CREATE) (OUT struct WMD_DEV_CONTEXT
+						    **phDevContext,
+						    struct DEV_OBJECT
+						    *hDevObject,
+						    IN CONST struct CFG_HOSTRES
+						    *pConfig,
+						    IN CONST struct CFG_DSPRES
+						    *pDspConfig);
+
+/*
+ *  ======== WMD_DEV_Ctrl ========
+ *  Purpose:
+ *      Mini-driver specific interface.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwCmd:          WMD defined command code.
+ *      pArgs:          Pointer to an arbitrary argument structure.
+ *  Returns:
+ *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
+ *      in the pArgs structure, and are defined by the WMD implementor.
+ *  Requires:
+ *      All calls are currently assumed to be synchronous.  There are no
+ *      IOCTL completion routines provided.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
+					u32 dwCmd,
+					IN OUT void *pArgs);
+
+/*
+ *  ======== WMD_DEV_Destroy ========
+ *  Purpose:
+ *      Deallocate WMD device extension structures and all other resources
+ *      acquired by the mini-driver.
+ *      No calls to other mini driver functions may subsequently
+ *      occur, except for WMD_DEV_Create().
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device information.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to release a resource previously acquired.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ *      DSP_SOK: Device context is freed.
+ */
+       typedef DSP_STATUS(*WMD_DEV_DESTROY) (struct WMD_DEV_CONTEXT
+					     *hDevContext);
+
+/*
+ *  ======== WMD_DEH_Create ========
+ *  Purpose:
+ *      Create an object that manages DSP exceptions from the GPP.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      hDevObject:     Handle to DEV object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      hDevObject != NULL;
+ *      phDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_CREATE) (OUT struct DEH_MGR
+						    **phDehMgr,
+						    struct DEV_OBJECT
+						    *hDevObject);
+
+/*
+ *  ======== WMD_DEH_Destroy ========
+ *  Purpose:
+ *      Destroy the DEH object.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Destroy failed.
+ *  Requires:
+ *      hDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_DESTROY) (struct DEH_MGR *hDehMgr);
+
+/*
+ *  ======== WMD_DEH_RegisterNotify ========
+ *  Purpose:
+ *      Register for DEH event notification.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Destroy failed.
+ *  Requires:
+ *      hDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_REGISTERNOTIFY)
+				(struct DEH_MGR *hDehMgr,
+				u32 uEventMask, u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_DEH_GetInfo ========
+ *  Purpose:
+ *      Get DSP exception info.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      pErrInfo:       Ptr to error info structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      phDehMgr != NULL;
+ *      pErrorInfo != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_GETINFO) (struct DEH_MGR *phDehMgr,
+					struct DSP_ERRORINFO *pErrInfo);
+
+/*
+ *  ======== WMD_IO_Create ========
+ *  Purpose:
+ *      Create an object that manages I/O between CHNL and MSG.
+ *  Parameters:
+ *      phIOMgr:        Location to store IO manager on output.
+ *      hChnlMgr:       Handle to channel manager.
+ *      hMsgMgr:        Handle to message manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      hDevObject != NULL;
+ *      Channel manager already created;
+ *      Message manager already created;
+ *      pMgrAttrs != NULL;
+ *      phIOMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_CREATE) (OUT struct IO_MGR **phIOMgr,
+					struct DEV_OBJECT *hDevObject,
+					IN CONST struct IO_ATTRS *pMgrAttrs);
+
+/*
+ *  ======== WMD_IO_Destroy ========
+ *  Purpose:
+ *      Destroy object created in WMD_IO_Create.
+ *  Parameters:
+ *      hIOMgr:         IO Manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_DESTROY) (struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== WMD_IO_OnLoaded ========
+ *  Purpose:
+ *      Called whenever a program is loaded to update internal data. For
+ *      example, if shared memory is used, this function would update the
+ *      shared memory location and address.
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Internal failure occurred.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_ONLOADED) (struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== WMD_IO_GETPROCLOAD ========
+ *  Purpose:
+ *      Called to get the Processor's current and predicted load
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *      pProcLoadStat   Processor Load statistics
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Internal failure occurred.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_GETPROCLOAD)(struct IO_MGR *hIOMgr,
+			   struct DSP_PROCLOADSTAT *pProcLoadStat);
+
+/*
+ *  ======== WMD_MSG_Create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object.
+ *  Parameters:
+ *      phMsgMgr:           Location to store MSG manager on output.
+ *      hDevObject:         Handle to a device object.
+ *      msgCallback:        Called whenever an RMS_EXIT message is received.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *  Requires:
+ *      phMsgMgr != NULL.
+ *      msgCallback != NULL.
+ *      hDevObject != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_CREATE)
+				(OUT struct MSG_MGR **phMsgMgr,
+				struct DEV_OBJECT *hDevObject,
+				MSG_ONEXIT msgCallback);
+
+/*
+ *  ======== WMD_MSG_CreateQueue ========
+ *  Purpose:
+ *      Create a MSG queue for sending or receiving messages from a Message
+ *      node on the DSP.
+ *  Parameters:
+ *      hMsgMgr:            MSG queue manager handle returned from
+ *                          WMD_MSG_Create.
+ *      phMsgQueue:         Location to store MSG queue on output.
+ *      dwId:               Identifier for messages (node environment pointer).
+ *      uMaxMsgs:           Max number of simultaneous messages for the node.
+ *      h:                  Handle passed to hMsgMgr->msgCallback().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *  Requires:
+ *      phMsgQueue != NULL.
+ *      h != NULL.
+ *      uMaxMsgs > 0.
+ *  Ensures:
+ *      phMsgQueue !=NULL <==> DSP_SOK.
+ */
+       typedef DSP_STATUS(*WMD_MSG_CREATEQUEUE)
+				(struct MSG_MGR *hMsgMgr,
+				OUT struct MSG_QUEUE **phMsgQueue,
+				u32 dwId, u32 uMaxMsgs, HANDLE h);
+
+/*
+ *  ======== WMD_MSG_Delete ========
+ *  Purpose:
+ *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *  Parameters:
+ *      hMsgMgr:    Handle returned from WMD_MSG_Create().
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgMgr.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_DELETE) (struct MSG_MGR *hMsgMgr);
+
+/*
+ *  ======== WMD_MSG_DeleteQueue ========
+ *  Purpose:
+ *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *  Parameters:
+ *      hMsgQueue:  Handle to MSG queue returned from
+ *                  WMD_MSG_CreateQueue.
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgQueue.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_DELETEQUEUE) (struct MSG_QUEUE *hMsgQueue);
+
+/*
+ *  ======== WMD_MSG_Get ========
+ *  Purpose:
+ *      Get a message from a MSG queue.
+ *  Parameters:
+ *      hMsgQueue:     Handle to MSG queue returned from
+ *                     WMD_MSG_CreateQueue.
+ *      pMsg:          Location to copy message into.
+ *      uTimeout:      Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *      DSP_ETIMEOUT:  Timeout occurred.
+ *      DSP_EFAIL:     No frames available for message (uMaxMessages too
+ *                     small).
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_GET) (struct MSG_QUEUE *hMsgQueue,
+						 struct DSP_MSG *pMsg,
+						 u32 uTimeout);
+
+/*
+ *  ======== WMD_MSG_Put ========
+ *  Purpose:
+ *      Put a message onto a MSG queue.
+ *  Parameters:
+ *      hMsgQueue:      Handle to MSG queue returned from
+ *                      WMD_MSG_CreateQueue.
+ *      pMsg:           Pointer to message.
+ *      uTimeout:       Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   Timeout occurred.
+ *      DSP_EFAIL:      No frames available for message (uMaxMessages too
+ *                      small).
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_PUT) (struct MSG_QUEUE *hMsgQueue,
+						 IN CONST struct DSP_MSG *pMsg,
+						 u32 uTimeout);
+
+/*
+ *  ======== WMD_MSG_RegisterNotify ========
+ *  Purpose:
+ *      Register notification for when a message is ready.
+ *  Parameters:
+ *      hMsgQueue:      Handle to MSG queue returned from
+ *                      WMD_MSG_CreateQueue.
+ *      uEventMask:     Type of events to be notified about: Must be
+ *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
+ *      uNotifyType:    DSP_SIGNALEVENT.
+ *      hNotification:  Handle of notification object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      hNotification != NULL.
+ *      uNotifyType == DSP_SIGNALEVENT.
+ *      uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_REGISTERNOTIFY)
+				(struct MSG_QUEUE *hMsgQueue,
+				u32 uEventMask, u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_MSG_SetQueueId ========
+ *  Purpose:
+ *      Set message queue id to node environment. Allows WMD_MSG_CreateQueue
+ *      to be called in NODE_Allocate, before the node environment is known.
+ *  Parameters:
+ *      hMsgQueue:  Handle to MSG queue returned from
+ *                  WMD_MSG_CreateQueue.
+ *      dwId:       Node environment pointer.
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      dwId != 0.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_SETQUEUEID) (struct MSG_QUEUE *hMsgQueue,
+						  u32 dwId);
+
+/*
+ *  'Bridge Mini Driver (WMD) interface function table.
+ *
+ *  The information in this table is filled in by the specific mini-driver,
+ *  and copied into the 'Bridge class driver's own space.  If any interface
+ *  function field is set to a value of NULL, then the class driver will
+ *  consider that function not implemented, and return the error code
+ *  DSP_ENOTIMPL when a WMD client attempts to call that function.
+ *
+ *  This function table contains WCD version numbers, which are used by the
+ *  WMD loader to help ensure backwards compatility between older WMD's and a
+ *  newer 'Bridge Class Driver.  These must be set to WCD_MAJOR_VERSION
+ *  and WCD_MINOR_VERSION, respectively.
+ *
+ *  A mini-driver need not export a CHNL interface.  In this case, *all* of
+ *  the WMD_CHNL_* entries must be set to NULL.
+ */
+	struct WMD_DRV_INTERFACE {
+		u32 dwWCDMajorVersion;	/* Set to WCD_MAJOR_VERSION. */
+		u32 dwWCDMinorVersion;	/* Set to WCD_MINOR_VERSION. */
+		WMD_DEV_CREATE pfnDevCreate;	/* Create device context     */
+		WMD_DEV_DESTROY pfnDevDestroy;	/* Destroy device context    */
+		WMD_DEV_CTRL pfnDevCntrl;	/* Optional vendor interface */
+		WMD_BRD_MONITOR pfnBrdMonitor;	/* Load and/or start monitor */
+		WMD_BRD_START pfnBrdStart;	/* Start DSP program.        */
+		WMD_BRD_STOP pfnBrdStop;	/* Stop/reset board.         */
+		WMD_BRD_STATUS pfnBrdStatus;	/* Get current board status. */
+		WMD_BRD_READ pfnBrdRead;	/* Read board memory         */
+		WMD_BRD_WRITE pfnBrdWrite;	/* Write board memory.       */
+		WMD_BRD_SETSTATE pfnBrdSetState;  /* Sets the Board State */
+		WMD_BRD_MEMCOPY pfnBrdMemCopy;	 /* Copies DSP Memory         */
+		WMD_BRD_MEMWRITE pfnBrdMemWrite; /* Write DSP Memory w/o halt */
+		WMD_BRD_MEMMAP pfnBrdMemMap;	 /* Maps MPU mem to DSP mem   */
+		WMD_BRD_MEMUNMAP pfnBrdMemUnMap; /* Unmaps MPU mem to DSP mem */
+		WMD_CHNL_CREATE pfnChnlCreate;	 /* Create channel manager.   */
+		WMD_CHNL_DESTROY pfnChnlDestroy; /* Destroy channel manager.  */
+		WMD_CHNL_OPEN pfnChnlOpen;	 /* Create a new channel.     */
+		WMD_CHNL_CLOSE pfnChnlClose;	 /* Close a channel.          */
+		WMD_CHNL_ADDIOREQ pfnChnlAddIOReq; /* Req I/O on a channel. */
+		WMD_CHNL_GETIOC pfnChnlGetIOC;	 /* Wait for I/O completion.  */
+		WMD_CHNL_CANCELIO pfnChnlCancelIO; /* Cancl I/O on a channel. */
+		WMD_CHNL_FLUSHIO pfnChnlFlushIO;	/* Flush I/O.         */
+		WMD_CHNL_GETINFO pfnChnlGetInfo; /* Get channel specific info */
+		/* Get channel manager info. */
+		WMD_CHNL_GETMGRINFO pfnChnlGetMgrInfo;
+		WMD_CHNL_IDLE pfnChnlIdle;	/* Idle the channel */
+		/* Register for notif. */
+		WMD_CHNL_REGISTERNOTIFY pfnChnlRegisterNotify;
+		WMD_DEH_CREATE pfnDehCreate;	/* Create DEH manager */
+		WMD_DEH_DESTROY pfnDehDestroy;	/* Destroy DEH manager */
+		WMD_DEH_NOTIFY pfnDehNotify;    /* Notify of DSP error */
+		/* register for deh notif. */
+		WMD_DEH_REGISTERNOTIFY pfnDehRegisterNotify;
+		WMD_DEH_GETINFO pfnDehGetInfo;	/* register for deh notif. */
+		WMD_IO_CREATE pfnIOCreate;	/* Create IO manager */
+		WMD_IO_DESTROY pfnIODestroy;	/* Destroy IO manager */
+		WMD_IO_ONLOADED pfnIOOnLoaded;	/* Notify of program loaded */
+		/* Get Processor's current and predicted load */
+		WMD_IO_GETPROCLOAD pfnIOGetProcLoad;
+		WMD_MSG_CREATE pfnMsgCreate;	/* Create message manager */
+		/* Create message queue */
+		WMD_MSG_CREATEQUEUE pfnMsgCreateQueue;
+		WMD_MSG_DELETE pfnMsgDelete;	/* Delete message manager */
+		/* Delete message queue */
+		WMD_MSG_DELETEQUEUE pfnMsgDeleteQueue;
+		WMD_MSG_GET pfnMsgGet;	/* Get a message */
+		WMD_MSG_PUT pfnMsgPut;	/* Send a message */
+		/* Register for notif. */
+		WMD_MSG_REGISTERNOTIFY pfnMsgRegisterNotify;
+		/* Set message queue id */
+		WMD_MSG_SETQUEUEID pfnMsgSetQueueId;
+	} ;
+
+/*
+ *  ======== WMD_DRV_Entry ========
+ *  Purpose:
+ *      Registers WMD functions with the class driver. Called only once
+ *      by the WCD.  The caller will first check WCD version compatibility, and
+ *      then copy the interface functions into its own memory space.
+ *  Parameters:
+ *      ppDrvInterface  Pointer to a location to receive a pointer to the
+ *                      mini driver interface.
+ *  Returns:
+ *  Requires:
+ *      The code segment this function resides in must expect to be discarded
+ *      after completion.
+ *  Ensures:
+ *      ppDrvInterface pointer initialized to WMD's function interface.
+ *      No system resources are acquired by this function.
+ *  Details:
+ *      Win95: Called during the Device_Init phase.
+ */
+       void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
+				 IN CONST char *pstrWMDFileName);
+
+#endif				/* WMD_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
@@ -0,0 +1,91 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmdioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmdioctl.h ========
+ *  Description:
+ *    BRIDGE Minidriver BRD_IOCtl reserved command definitions.
+ *
+ *! Revision History
+ *! ================
+ *! 19-Apr-2004 sb   Updated HW typedefs
+ *! 16-Feb-2004 vp   Added MMU endianness attributes to WMDIOCTL_EXTPROC
+ *! 21-Mar-2003 sb   Changed WMDIOCTL_NUMOFMMUTLB from 7 to 32
+ *! 14-May-2001 sg   Added codes for PWR.
+ *! 10-Aug-2001 ag   Added _SETMMUCONFIG ioctl used for DSP-MMU init.
+ *! 16-Nov-1999 rajesh ?
+ *! 18-Jun-1998 ag   Moved EMIF, SDRAM_C, & CE space init to ENBLEXTMEM ioctl.
+ *!                  Added ENBLEXTMEM, RESETDSP, UNRESETDSP & ASSERTSIG ioctls.
+ *! 07-Jun-1998 ag   Added JTAG_SELECT, MAP_TBC, GET_CONFIGURATION ioctls.
+ *! 26-Jan-1998 jeh: Added START, RECV, and SEND ioctls.
+ *! 07-Nov-1997 nn:  Added command to interrupt DSP for interrupt test.
+ *! 20-Oct-1997 nn:  Added commands for getting and resetting interrupt count.
+ *! 17-Oct-1997 gp:  Moved to src/wmd. Standardized prefix.
+ *! 08-Oct-1997 nn:  Created.
+ */
+
+#ifndef WMDIOCTL_
+#define WMDIOCTL_
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/* Any IOCTLS at or above this value are reserved for standard WMD interfaces.*/
+#define WMDIOCTL_RESERVEDBASE       0x8000
+
+#define WMDIOCTL_CHNLREAD           (WMDIOCTL_RESERVEDBASE + 0x10)
+#define WMDIOCTL_CHNLWRITE          (WMDIOCTL_RESERVEDBASE + 0x20)
+#define WMDIOCTL_GETINTRCOUNT       (WMDIOCTL_RESERVEDBASE + 0x30)
+#define WMDIOCTL_RESETINTRCOUNT     (WMDIOCTL_RESERVEDBASE + 0x40)
+#define WMDIOCTL_INTERRUPTDSP       (WMDIOCTL_RESERVEDBASE + 0x50)
+#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)   /* DMMU */
+#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)   /* PWR */
+
+/* attention, modifiers:
+ * Some of these control enumerations are made visible to user for power
+ * control, so any changes to this list, should also be updated in the user
+ * header file 'dbdefs.h' ***/
+/* These ioctls are reserved for PWR power commands for the DSP */
+#define WMDIOCTL_DEEPSLEEP          (WMDIOCTL_PWRCONTROL + 0x0)
+#define WMDIOCTL_EMERGENCYSLEEP     (WMDIOCTL_PWRCONTROL + 0x1)
+#define WMDIOCTL_WAKEUP             (WMDIOCTL_PWRCONTROL + 0x2)
+#define WMDIOCTL_PWRENABLE          (WMDIOCTL_PWRCONTROL + 0x3)
+#define WMDIOCTL_PWRDISABLE         (WMDIOCTL_PWRCONTROL + 0x4)
+#define WMDIOCTL_CLK_CTRL		    (WMDIOCTL_PWRCONTROL + 0x7)
+#define WMDIOCTL_PWR_HIBERNATE (WMDIOCTL_PWRCONTROL + 0x8) /*DSP Initiated
+							    * Hibernate*/
+#define WMDIOCTL_PRESCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0x9)
+#define WMDIOCTL_POSTSCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0xA)
+#define WMDIOCTL_CONSTRAINT_REQUEST (WMDIOCTL_PWRCONTROL + 0xB)
+
+/* Number of actual DSP-MMU TLB entrries */
+#define WMDIOCTL_NUMOFMMUTLB        32
+
+struct WMDIOCTL_EXTPROC {
+	u32 ulDspVa;		/* DSP virtual address */
+	u32 ulGppPa;		/* GPP physical address */
+	/* GPP virtual address. __va does not work for ioremapped addresses */
+	u32 ulGppVa;
+	u32 ulSize;		/* Size of the mapped memory in bytes */
+	enum HW_Endianism_t endianism;
+	enum HW_MMUMixedSize_t mixedMode;
+	enum HW_ElementSize_t elemSize;
+};
+
+#endif				/* WMDIOCTL_ */
+
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdio.h
@@ -0,0 +1,53 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmdio.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmdio.h ========
+ *  Description:
+ *      Declares the upper edge IO  functions required by
+ *      all WMD / WCD driver interface tables.
+ *
+ *  Public Functions:
+ *
+ *  Notes:
+ *      Function comment headers reside with the function typedefs in wmd.h.
+ *
+ *! Revision History:
+ *! ================
+ *! 27-Feb-2004 vp		Added IVA releated function.
+ *! 06-Nov-2000 jeh     Created.
+ */
+
+#ifndef WMDIO_
+#define WMDIO_
+
+#include <devdefs.h>
+#include <iodefs.h>
+
+	extern DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
+					struct DEV_OBJECT *hDevObject,
+					IN CONST struct IO_ATTRS *pMgrAttrs);
+
+	extern DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr);
+
+	extern DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr);
+
+	extern DSP_STATUS IVA_IO_OnLoaded(struct IO_MGR *hIOMgr);
+	extern DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
+				OUT struct DSP_PROCLOADSTAT *pProcStat);
+
+#endif				/* WMDIO_ */
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
@@ -0,0 +1,70 @@
+/*
+ * arch/arm/plat-omap/include/bridge/wmdmsg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== wmdmsg.h ========
+ *  Description:
+ *      Declares the upper edge message class library functions required by
+ *      all WMD / WCD driver interface tables.  These functions are
+ *      implemented by every class of WMD channel library.
+ *
+ *  Public Functions:
+ *
+ *  Notes:
+ *      Function comment headers reside with the function typedefs in wmd.h.
+ *
+ *! Revision History:
+ *! ================
+ *! 06-Dec-2000 jeh     Added uEventMask to WMD_MSG_RegisterNotify(). Added
+ *!                     WMD_MSG_SetQueueId().
+ *! 17-Nov-2000 jeh     Created.
+ */
+
+#ifndef WMDMSG_
+#define WMDMSG_
+
+#include <msgdefs.h>
+
+	extern DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+					 struct DEV_OBJECT *hDevObject,
+					 MSG_ONEXIT msgCallback);
+
+	extern DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
+					      OUT struct MSG_QUEUE **phMsgQueue,
+					      u32 dwId, u32 uMaxMsgs,
+					      HANDLE h);
+
+	extern void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr);
+
+	extern void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue);
+
+	extern DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
+				      struct DSP_MSG *pMsg, u32 uTimeout);
+
+	extern DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
+				      IN CONST struct DSP_MSG *pMsg,
+				      u32 uTimeout);
+
+	extern DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue,
+						 u32 uEventMask,
+						 u32 uNotifyType,
+						 struct DSP_NOTIFICATION
+						 *hNotification);
+
+	extern void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId);
+
+#endif				/* WMDMSG_ */
