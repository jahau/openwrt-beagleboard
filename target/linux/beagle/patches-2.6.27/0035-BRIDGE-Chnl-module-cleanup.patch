From 50bffd12f1e5cbe818181dcf6cc29be3dd9603be Mon Sep 17 00:00:00 2001
From: Fernando Guzman Lugo <x0095840@ti.com>
Date: Fri, 19 Sep 2008 11:31:58 -0500
Subject: [PATCH] BRIDGE: Chnl module cleanup

This patch removes all the functions not used in Chnl module

Signed-off-by: Fernando Guzman Lugo <x0095840@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/chnl.h     |  369 +----------------------
 arch/arm/plat-omap/include/dspbridge/chnlpriv.h |    2 +-
 drivers/dsp/bridge/pmgr/chnl.c                  |  256 ----------------
 drivers/dsp/bridge/wmd/chnl_sm.c                |    1 -
 4 files changed, 2 insertions(+), 626 deletions(-)

--- a/arch/arm/plat-omap/include/dspbridge/chnl.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnl.h
@@ -60,94 +60,6 @@
 #include <dspbridge/chnlpriv.h>
 
 /*
- *  ======== CHNL_AddIOReq ========
- *  Purpose:
- *      Enqueue an I/O request for data transfer with the DSP on this channel.
- *      The direction (mode) is specified in the channel object.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      pHostBuf:       Host buffer address source.
- *      cBytes:         Number of PC bytes to transfer. A zero value indicates
- *                      that this buffer is the last in the output channel.
- *                      A zero value is invalid for an input channel.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pHostBuf is invalid.
- *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
- *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
- *                      I/O is allowed.
- *      CHNL_E_EOS:     End of stream was already marked on a previous
- *                      IORequest on this output channel. Not returned for
- *                      input channels.
- *      CHNL_E_NOIORPS: No free IO request packets available for queuing.
- *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
- *                      the size of the physical shared memory output window.
- *  Requires:
- *      CHNL_Init() called.
- *      pHostBuf points to memory which can be safely accessed at interrupt
- *      time without page fault.
- *  Ensures:
- *      The buffer will be transferred if the channel is ready; otherwise, will
- *      be queued for transfer when the channel becomes ready.  In any case,
- *      notifications of I/O completion are asynchronous.
- *      If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's on
- *      this channel will fail with error code CHNL_E_EOS.  The corresponding
- *      IOC for this I/O request will have its status flag set to
- *      CHNL_IOCSTATEOS.
- */
-	extern DSP_STATUS CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
-					void *pHostBuf,
-					u32 cBytes);
-
-/*
- *  ======== CHNL_AllocBuffer ========
- *  Purpose:
- *      Allocate a zero-initialized buffer to be used in data transfers though
- *      a channel managed by this channel manager.
- *  Parameters:
- *      ppBuf:              Location to store buffer pointer.
- *      hChnlMgr:           Handle to a valid channel manager.
- *      cBytes:             Size of buffer in bytes. Must be greater than zero.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EPOINTER:       ppBuf is invalid.
- *      DSP_EHANDLE:        hChnlMgr is invalid.
- *      DSP_EMEMORY:        Insufficient memory to allocate buffer.
- *      DSP_EINVALIDARG:    Invalid cBytes value.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:            *ppBuf points to memory which can be accessed in
- *                          any context.
- *      else:               *ppBuf contains NULL if ppBuf != NULL.
- */
-	extern DSP_STATUS CHNL_AllocBuffer(OUT void **ppBuf,
-					   struct CHNL_MGR *hChnlMgr,
-					   u32 cBytes);
-
-/*
- *  ======== CHNL_CancelIO ========
- *  Purpose:
- *      Return all I/O requests to the client which have not yet been
- *      transferred.  The channel's I/O completion object is
- *      signalled, and all the I/O requests are queued as IOC's, with the
- *      status field set to CHNL_IOCSTATCANCEL.
- *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
- *  Parameters:
- *      hChnl:          Channel object handle.
- *  Returns:
- *      DSP_SOK:           Success;
- *      DSP_EHANDLE:       Invalid hChnl.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      Subsequent I/O requests to this channel will not be accepted.
- */
-	extern DSP_STATUS CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
-
-/*
  *  ======== CHNL_Close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
@@ -168,23 +80,6 @@
  */
 	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
 
-/*
- *  ======== CHNL_CloseOrphans ========
- *  Purpose:
- *      Close open channels orphaned by a closing process.
- *  Parameters:
- *      hChnlMgr:       Channel manager holding the channels.
- *      hProcess:       Kernel mode handle of the process claiming the channels.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_SFALSE:     No channels were left open by this process.
- *      DSP_EHANDLE:    Invalid hChnlMgr handle.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_CloseOrphans(struct CHNL_MGR *hChnlMgr,
-					    HANDLE hProcess);
 
 /*
  *  ======== CHNL_Create ========
@@ -256,223 +151,6 @@
  */
 	extern void CHNL_Exit();
 
-/*
- *  ======== CHNL_FlushIO ========
- *  Purpose:
- *      For an output stream (to the DSP), flush all pending IO requests to the
- *      output device.  This function will wait for IO completion for each of
- *      the queued IO requests, up to the specified timeout (per IOR).   For
- *      input streams (from the DSP), will cancel all pending IO requests.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      Timeout in milliseconds to wait for I/O completion.
- *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
- *                      The value of CHNL_IOCNOWAIT is not allowed.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EINVALIDARG:    dwTimeOut value of CHNL_IOCNOWAIT was given.
- *      CHNL_E_WAITTIMEOUT: Wait for flush of output stream timed out.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:        No I/O requests will be pending on this channel.
- */
-	extern DSP_STATUS CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
-					u32 dwTimeOut);
-
-/*
- *  ======== CHNL_FreeBuffer ========
- *  Purpose:
- *      Free a buffer previously allocated using CHNL_AllocBuffer().
- *  Parameters:
- *      hChnlMgr:       Handle to a valid channel manager.
- *      cBytes:         Size of buffer in bytes.
- *      pBuf:           Buffer pointer returned by CHNL_FreeBuffer().
- *  Returns:
- *      DSP_SOK:           Success.
- *      DSP_EHANDLE:       hChnlMgr is invalid.
- *      DSP_EINVALIDARG:   pBuf is NULL.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_FreeBuffer(struct CHNL_MGR *hChnlMgr,
-					  u32 cBytes,
-					  void *pBuf);
-
-/*
- *  ======== CHNL_GetEventHandle ========
- *  Purpose:
- *      Retrieve this channel's I/O completion auto-reset event.
- *  Parameters:
- *      hChnl:          Handle to a valid channel object.
- *      phEvent:        Location to store the I/O completion event object.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   phEvent is invalid.
- *  Requires:
- *      CHNL_Init() called.
-
- */
-	extern DSP_STATUS CHNL_GetEventHandle(struct CHNL_OBJECT *hChnl,
-					      OUT HANDLE *phEvent);
-
-/*
- *  ======== CHNL_GetHandle ========
- *  Purpose:
- *      Retrieve the channel handle given the logical ID and channel manager.
- *  Parameters:
- *      hChnlMgr:           Handle to a valid channel manager, or NULL.
- *      uChnlID:            Channel ID.
- *      phChnl:             Location to store channel handle.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnlMgr.
- *      DSP_EPOINTER:       phChnl == NULL.
- *      CHNL_E_BADCHANID:   Invalid channel ID.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:            *phChnl points to a valid channel object,
- *                          if phChnl != NULL.
- */
-	extern DSP_STATUS CHNL_GetHandle(struct CHNL_MGR *hChnlMgr,
-					 u32 uChnlID,
-					 OUT struct CHNL_OBJECT **phChnl);
-
-/*
- *  ======== CHNL_GetIOCompletion ========
- *  Purpose:
- *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
- *      completion record, which contains information about the completed
- *      I/O request.
- *  Parameters:
- *      hChnl:          Channel object handle.
- *      dwTimeOut:      Timeout in milliseconds to wait for completion.
- *                      A value of CHNL_IOCINFINITE means to wait indefinitely.
- *                      A value of CHNL_IOCNOWAIT will simply dequeue the
- *                      first available IOC.
- *      pIOC:           On output, contains host buffer address, bytes
- *                      transferred, and status of I/O completion.
- *      pIOC->status:   I/O Completion status: see chnldefs.h for definitions.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pIOC is invalid.
- *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
- *                      yet no I/O completions were queued.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- *      DSP_SOK:        If there are any remaining IOC's queued before this
- *                      call returns, the channel event object will be left
- *                      in a signalled state.
- *      If the return status is anything other than DSP_EPOINTER or DSP_SOK,
- *      then pIOC->pBuf will be set to NULL, pIOC->cBytes will be 0, and
- *      pIOC->status will be undefined.
- */
-	extern DSP_STATUS CHNL_GetIOCompletion(struct CHNL_OBJECT *hChnl,
-					       u32 dwTimeOut,
-					       OUT struct CHNL_IOC *pIOC);
-
-/*
- *  ======== CHNL_GetId ========
- *  Purpose:
- *      Retrieve the channel logical ID of this channel.
- *  Parameters:
- *      hChnl:          Handle to a valid channel object.
- *      pdwID:          Location to store logical ID.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
- *      DSP_EPOINTER:   pdwID is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetId(struct CHNL_OBJECT *hChnl,
-				     OUT u32 *pdwID);
-
-/*
- *  ======== CHNL_GetMgr ========
- *  Purpose:
- *      Retrieve a channel manager handle, required for opening new channels
- *      and closing old ones on a given board.
- *  Parameters:
- *      hDevNode:       A valid system specific DEVNODE handle.
- *      phChnlMgr:      Location to store the channel manager handle on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hDevNode is invalid.
- *      CHNL_E_NOMGR:   No channel manager exists for this board.
- *  Requires:
- *      CHNL_Init() called.
- *      phChnlMgr != NULL.
- *  Ensures:
- *      DSP_SOK: The DSP board represented by hDevNode was in the RUNNING state
- *            before this function returned.
- *      else: *phChnlMgr == NULL.
- */
-	extern DSP_STATUS CHNL_GetMgr(struct CFG_DEVNODE *hDevNode,
-				      OUT struct CHNL_MGR **phChnlMgr);
-
-/*
- *  ======== CHNL_GetMode ========
- *  Purpose:
- *      Retrieve the mode flags of this channel.
- *  Parameters:
- *      hChnl:              Handle to a valid channel object.
- *      pMode:              Location to store mode flags.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       pMode is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetMode(struct CHNL_OBJECT *hChnl,
-				       OUT CHNL_MODE * pMode);
-
-/*
- *  ======== CHNL_GetPosition ========
- *  Purpose:
- *      Retrieve the total number of bytes transferred on this channel.
- *  Parameters:
- *      hChnl:              Handle to a valid channel object.
- *      pcPosition:         Location to store number of bytes.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       pcPosition is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetPosition(struct CHNL_OBJECT *hChnl,
-					   OUT u32 *pcPosition);
-
-/*
- *  ======== CHNL_GetProcessHandle ========
- *  Purpose:
- *      Retrieve the handle of the process owning this channel.
- *  Parameters:
- *      hChnl:              Channel handle.
- *      phProcess:          Location to store the process handle.  A NULL value
- *                          indicates the channel is either closed or is not
- *                          owned by any particular process.
- *  Returns:
- *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
- *      DSP_EPOINTER:       phProcess is invalid.
- *  Requires:
- *      CHNL_Init() called.
- *  Ensures:
- */
-	extern DSP_STATUS CHNL_GetProcessHandle(struct CHNL_OBJECT *hChnl,
-						OUT HANDLE *phProcess);
 
 /*
  *  ======== CHNL_Init ========
@@ -487,51 +165,6 @@
  */
 	extern bool CHNL_Init();
 
-/*
- *  ======== CHNL_Open ========
- *  Purpose:
- *      Open a new half-duplex channel to the DSP board.
- *  Parameters:
- *      phChnl:         Location to store a channel object handle.
- *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
- *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
- *                      direction of data transfer.
- *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
- *                      select a free channel id (default);
- *                      otherwise this field specifies the id of the channel.
- *      pAttrs:         Channel attributes.  Attribute fields are as follows:
- *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
- *                       be pending at any given time. All request packets are
- *                       preallocated when the channel is opened.
- *      pAttrs->hEvent: This field allows the user to supply an auto reset
- *                      event object for channel I/O completion notifications.
- *                      It is the responsibility of the user to destroy this
- *                      object AFTER closing the channel.
- *                      This channel event object can be retrieved using
- *                      CHNL_GetEventHandle().
- *      pAttrs->hReserved: The kernel mode handle of this event object.
- *
- *  Returns:
- *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            hChnlMgr is invalid.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      DSP_EINVALIDARG:        Invalid number of IOReqs.
- *      CHNL_E_BADMODE:         Invalid mode argument.
- *      CHNL_E_OUTOFSTREAMS:    No free channels available.
- *      CHNL_E_BADCHANID:       Channel ID is out of range.
- *      CHNL_E_CHANBUSY:        Channel is in use.
- *  Requires:
- *      CHNL_Init() called.
- *      phChnl != NULL.
- *      pAttrs != NULL.
- *      pAttrs->hEvent is a valid event handle.
- *  Ensures:
- *      DSP_SOK:        *phChnl is a valid channel.
- *      else:           *phChnl is set to NULL if (phChnl != NULL);
- */
-	extern DSP_STATUS CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-				    struct CHNL_MGR *hChnlMgr, CHNL_MODE uMode,
-				    u32 uChnlId,
-				    CONST IN struct CHNL_ATTRS *pAttrs);
+
 
 #endif				/* CHNL_ */
--- a/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
@@ -110,7 +110,7 @@
 		u32 cPosition;	/* Total bytes transferred.        */
 		u32 cIOCs;	/* Number of IOCs in queue.               */
 		u32 cIOReqs;	/* Number of IO Requests in queue.        */
-		HANDLE hProcess;	/* Process owning this channel.     */
+               u32 hProcess;   /* Process owning this channel.     */
 		/*
 		 * Name of channel I/O completion event. Not required in Linux
 		 */
--- a/drivers/dsp/bridge/pmgr/chnl.c
+++ b/drivers/dsp/bridge/pmgr/chnl.c
@@ -99,99 +99,7 @@ static u32 cRefs;
 static struct GT_Mask CHNL_DebugMask = { NULL, NULL };	/* WCD CHNL Mask */
 #endif
 
-/*  ----------------------------------- Function Prototypes */
-static DSP_STATUS GetNumOpenChannels(struct CHNL_MGR *hChnlMgr,
-				    OUT u32 *pcOpenChannels);
 
-static DSP_STATUS GetNumChannels(struct CHNL_MGR *hChnlMgr,
-				 OUT u32 *pcChannels);
-
-/*
- *  ======== CHNL_Close ========
- *  Purpose:
- *      Ensures all pending I/O on this channel is cancelled, discards all
- *      queued I/O completion notifications, then frees the resources
- *      allocated for this channel, and makes the corresponding logical
- *      channel id available for subsequent use.
- */
-DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl)
-{
-	DSP_STATUS status;
-	struct CHNL_OBJECT_ *pChnl = (struct CHNL_OBJECT_ *)hChnl;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(CHNL_DebugMask, GT_ENTER,
-		  "Entered CHNL_Close:hChnl: 0x%x\n",
-		  hChnl);
-
-	if (CHNL_IsValidChnl(pChnl)) {
-		pIntfFxns = pChnl->pChnlMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlClose) (hChnl);
-	} else {
-		GT_0trace(CHNL_DebugMask, GT_7CLASS,
-			  "CHNL_Close:Invalid Handle\n");
-		status = DSP_EHANDLE;
-	}
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Exiting CHNL_Close:hChnl: 0x%x, status:"
-		  " 0x%x\n", hChnl, status);
-	return status;
-}
-
-/*
- *  ======== CHNL_CloseOrphans ========
- *  Purpose:
- *      Close open channels orphaned by a closing process.
- */
-DSP_STATUS CHNL_CloseOrphans(struct CHNL_MGR *hChnlMgr, HANDLE hProcess)
-{
-	u32 uChnlID;
-	DSP_STATUS status = DSP_SFALSE;
-	HANDLE hProc;
-	u32 cOpenChannels;
-	u32 cTotalChnls;
-	struct CHNL_OBJECT *hChnl;
-
-	DBC_Require(cRefs > 0);
-
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Enter CHNL_CloseOrphans hChnlMgr "
-		  "0x%x\t\nhProcess: 0x%x\n", hChnlMgr, hProcess);
-	if (!CHNL_IsValidMgr((struct CHNL_MGR_ *)hChnlMgr)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
-	if (DSP_SUCCEEDED(GetNumOpenChannels(hChnlMgr, &cOpenChannels)) &&
-			 (cOpenChannels > 0)) {
-		if (DSP_FAILED(GetNumChannels(hChnlMgr, &cTotalChnls)))
-			goto func_end;
-
-		/* For each channel (except for RMS), get process handle: */
-		for (uChnlID = 2; uChnlID < cTotalChnls; uChnlID++) {
-			if (DSP_FAILED(CHNL_GetHandle(hChnlMgr, uChnlID,
-			    &hChnl))) {
-				continue;
-			}
-			if (DSP_FAILED(CHNL_GetProcessHandle(hChnl,
-			    &hProc))) {
-				continue;
-			}
-			/* See if channel owned by this process: */
-			if (hProc == hProcess) {
-				/* If so, close it now. */
-				CHNL_Close(hChnl);
-				status = DSP_SOK;
-			}
-		}
-	}
-func_end:
-	GT_1trace(CHNL_DebugMask, GT_ENTER, "CHNL_CloseOrphans status 0x%x\n",
-		  status);
-
-	return status;
-}
 
 /*
  *  ======== CHNL_Create ========
@@ -320,84 +228,6 @@ void CHNL_Exit(void)
 	DBC_Ensure(cRefs >= 0);
 }
 
-/*
- *  ======== CHNL_GetHandle ========
- *  Purpose:
- *      Retrieve the channel handle given the logical ID and channel manager.
- */
-DSP_STATUS CHNL_GetHandle(struct CHNL_MGR *hChnlMgr, u32 uChnlID,
-			  OUT struct CHNL_OBJECT **phChnl)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_MGRINFO chnlMgrInfo;
-
-	DBC_Require(cRefs > 0);
-
-	GT_3trace(CHNL_DebugMask, GT_ENTER, "Entered CHNL_GetHandle: hChnlMgr: "
-		  "0x%x\tuChnlID: 0x%x\t\nphChnl: 0x%x\n", hChnlMgr, uChnlID,
-		  phChnl);
-	if (phChnl) {
-		*phChnl = NULL;
-		if (CHNL_IsValidMgr(pChnlMgr)) {
-			pIntfFxns = pChnlMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnChnlGetMgrInfo)(hChnlMgr,
-				  uChnlID, &chnlMgrInfo);
-			if (DSP_SUCCEEDED(status))
-				*phChnl = chnlMgrInfo.hChnl;
-
-		} else {
-			status = DSP_EHANDLE;
-			GT_0trace(CHNL_DebugMask, GT_7CLASS,
-				  "CHNL_GetHandle:Invalid Handle\n");
-		}
-	} else {
-		status = DSP_EPOINTER;
-	}
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Exit CHNL_GetHandle: status: 0x%x\t\n"
-		  "hChnl: 0x%x\n", status, *phChnl);
-	return status;
-}
-
-/*
- *  ======== CHNL_GetProcessHandle ========
- *  Purpose:
- *      Retrieve the handle of the process owning this channel.
- */
-DSP_STATUS CHNL_GetProcessHandle(struct CHNL_OBJECT *hChnl,
-				 OUT HANDLE *phProcess)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT_ *pChnl = (struct CHNL_OBJECT_ *)hChnl;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_INFO chnlInfo;
-
-	DBC_Require(cRefs > 0);
-
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Enter CHNL_GetProcessHandle: hChnl: "
-		  "0x%x\t\n phProcess: 0x%x\n", hChnl, phProcess);
-	if (phProcess) {
-		*phProcess = NULL;
-		if (CHNL_IsValidChnl(pChnl)) {
-			pIntfFxns = pChnl->pChnlMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnChnlGetInfo)(hChnl, &chnlInfo);
-			if (DSP_SUCCEEDED(status))
-				*phProcess = chnlInfo.hProcess;
-
-		} else {
-			status = DSP_EHANDLE;
-		}
-	} else {
-		status = DSP_EPOINTER;
-	}
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Exit CHNL_GetProcessHandle: status: "
-		  "0x%x\t\n phProcess: 0x%x\n", status, *phProcess);
-	return status;
-}
 
 /*
  *  ======== CHNL_Init ========
@@ -427,90 +257,4 @@ bool CHNL_Init(void)
 	return fRetval;
 }
 
-/*
- *  ======== GetNumOpenChannels ========
- *  Purpose:
- *      Retrieve number of open channels
- *  Parameters:
- *      hChnlMgr:       Handle to a valid channel manager, or NULL.
- *      pcOpenChannels: Location to store number of open channels.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnlMgr.
- *      E_POINTER:      pcOpenChannels == NULL.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:        *pcOpenChannels points to a valid number
- *                      if pcOpenChannels != NULL.
- */
-static DSP_STATUS GetNumOpenChannels(struct CHNL_MGR *hChnlMgr,
-				     OUT u32 *pcOpenChannels)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_MGRINFO chnlMgrInfo;
-
-	DBC_Require(cRefs > 0);
-	if (pcOpenChannels) {
-		*pcOpenChannels = 0;
-		if (CHNL_IsValidMgr(pChnlMgr)) {
-			pIntfFxns = pChnlMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnChnlGetMgrInfo)(hChnlMgr, 0,
-				 &chnlMgrInfo);
-			if (DSP_SUCCEEDED(status))
-				*pcOpenChannels = chnlMgrInfo.cOpenChannels;
-
-		} else {
-			status = DSP_EHANDLE;
-		}
-	} else {
-		status = DSP_EPOINTER;
-	}
-	return status;
-}
-
-/*
- *  ======== GetNumOpenChannels ========
- *  Purpose:
- *      Retrieve number of total channels supported.
- *  Parameters:
- *      hChnlMgr:       Handle to a valid channel manager, or NULL.
- *      pcChannels:     Location to store number of channels.
- *  Returns:
- *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnlMgr.
- *      E_POINTER:      pcOpenChannels == NULL.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:        *pcChannels points to a valid number
- *                      if pcOpenChannels != NULL.
- */
-static DSP_STATUS GetNumChannels(struct CHNL_MGR *hChnlMgr,
-				 OUT u32 *pcChannels)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_MGRINFO chnlMgrInfo;
-
-	DBC_Require(cRefs > 0);
-
-	if (pcChannels) {
-		*pcChannels = 0;
-		if (CHNL_IsValidMgr(pChnlMgr)) {
-			pIntfFxns = pChnlMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnChnlGetMgrInfo)(hChnlMgr, 0,
-				 &chnlMgrInfo);
-			if (DSP_SUCCEEDED(status))
-				*pcChannels = chnlMgrInfo.cChannels;
-
-		} else {
-			status = DSP_EHANDLE;
-		}
-	} else {
-		status = DSP_EPOINTER;
-	}
-	return status;
-}
 
--- a/drivers/dsp/bridge/wmd/chnl_sm.c
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -916,7 +916,6 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 	pChnl->cChirps = pAttrs->uIOReqs;
 	pChnl->cIOCs = 0;
 	pChnl->cIOReqs = 0;
-	/* #WinCE# Let SYNC_ create our event  */
 	status = SYNC_OpenEvent(&hSyncEvent, pSyncAttrs);
 	if (DSP_SUCCEEDED(status)) {
 		status = NTFY_Create(&pChnl->hNtfy);
